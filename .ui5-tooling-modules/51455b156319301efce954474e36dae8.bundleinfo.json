{
  "_entries": [
    {
      "name": "sinon",
      "path": "/Users/i573017/SAPDevelop/Private/Repositories/com.testing.unit/node_modules/sinon/pkg/sinon-esm.js",
      "lastModified": 1753390488025,
      "type": "module",
      "originalName": "sinon-esm",
      "code": "sap.ui.define(['./node.process'], (function (_polyfillNode_process) { 'use strict';\n\n  var exports = exports || {};\n\n  /* Sinon.JS 21.0.0, 2025-06-13, @license BSD-3 */let sinon;(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,true);if(u)return u(i,true);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\n  const behavior = require(\"./sinon/behavior\");\n  const createSandbox = require(\"./sinon/create-sandbox\");\n  const extend = require(\"./sinon/util/core/extend\");\n  const fakeTimers = require(\"./sinon/util/fake-timers\");\n  const Sandbox = require(\"./sinon/sandbox\");\n  const stub = require(\"./sinon/stub\");\n  const promise = require(\"./sinon/promise\");\n\n  /**\n   * @returns {object} a configured sandbox\n   */\n  module.exports = function createApi() {\n      const apiMethods = {\n          createSandbox: createSandbox,\n          match: require(\"@sinonjs/samsam\").createMatcher,\n          restoreObject: require(\"./sinon/restore-object\"),\n\n          expectation: require(\"./sinon/mock-expectation\"),\n\n          // fake timers\n          timers: fakeTimers.timers,\n\n          addBehavior: function (name, fn) {\n              behavior.addBehavior(stub, name, fn);\n          },\n\n          // fake promise\n          promise: promise,\n      };\n\n      const sandbox = new Sandbox();\n      return extend(sandbox, apiMethods);\n  };\n\n  },{\"./sinon/behavior\":5,\"./sinon/create-sandbox\":8,\"./sinon/mock-expectation\":12,\"./sinon/promise\":14,\"./sinon/restore-object\":19,\"./sinon/sandbox\":20,\"./sinon/stub\":23,\"./sinon/util/core/extend\":26,\"./sinon/util/fake-timers\":40,\"@sinonjs/samsam\":87}],2:[function(require,module,exports){\n  // eslint-disable-next-line no-undef\n  sinon = require(\"./sinon\");\n\n  },{\"./sinon\":3}],3:[function(require,module,exports){\n\n  const createApi = require(\"./create-sinon-api\");\n\n  module.exports = createApi();\n\n  },{\"./create-sinon-api\":1}],4:[function(require,module,exports){\n  /** @module */\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const calledInOrder = require(\"@sinonjs/commons\").calledInOrder;\n  const createMatcher = require(\"@sinonjs/samsam\").createMatcher;\n  const orderByFirstCall = require(\"@sinonjs/commons\").orderByFirstCall;\n  const timesInWords = require(\"./util/core/times-in-words\");\n  const inspect = require(\"util\").inspect;\n  const stringSlice = require(\"@sinonjs/commons\").prototypes.string.slice;\n  const globalObject = require(\"@sinonjs/commons\").global;\n\n  const arraySlice = arrayProto.slice;\n  const concat = arrayProto.concat;\n  const forEach = arrayProto.forEach;\n  const join = arrayProto.join;\n  const splice = arrayProto.splice;\n\n  function applyDefaults(obj, defaults) {\n      for (const key of Object.keys(defaults)) {\n          const val = obj[key];\n          if (val === null || typeof val === \"undefined\") {\n              obj[key] = defaults[key];\n          }\n      }\n  }\n\n  /**\n   * @typedef {object} CreateAssertOptions\n   * @global\n   *\n   * @property {boolean} [shouldLimitAssertionLogs] default is false\n   * @property {number}  [assertionLogLimit] default is 10K\n   */\n\n  /**\n   * Create an assertion object that exposes several methods to invoke\n   *\n   * @param {CreateAssertOptions}  [opts] options bag\n   * @returns {object} object with multiple assertion methods\n   */\n  function createAssertObject(opts) {\n      const cleanedAssertOptions = opts || {};\n      applyDefaults(cleanedAssertOptions, {\n          shouldLimitAssertionLogs: false,\n          assertionLogLimit: 1e4,\n      });\n\n      const assert = {\n          fail: function fail(message) {\n              let msg = message;\n              if (cleanedAssertOptions.shouldLimitAssertionLogs) {\n                  msg = message.substring(\n                      0,\n                      cleanedAssertOptions.assertionLogLimit,\n                  );\n              }\n              const error = new Error(msg);\n              error.name = \"AssertError\";\n\n              throw error;\n          },\n\n          pass: function pass() {\n              return;\n          },\n\n          callOrder: function assertCallOrder() {\n              verifyIsStub.apply(null, arguments);\n              let expected = \"\";\n              let actual = \"\";\n\n              if (!calledInOrder(arguments)) {\n                  try {\n                      expected = join(arguments, \", \");\n                      const calls = arraySlice(arguments);\n                      let i = calls.length;\n                      while (i) {\n                          if (!calls[--i].called) {\n                              splice(calls, i, 1);\n                          }\n                      }\n                      actual = join(orderByFirstCall(calls), \", \");\n                  } catch (e) {\n                      // If this fails, we'll just fall back to the blank string\n                  }\n\n                  failAssertion(\n                      this,\n                      `expected ${expected} to be called in order but were called as ${actual}`,\n                  );\n              } else {\n                  assert.pass(\"callOrder\");\n              }\n          },\n\n          callCount: function assertCallCount(method, count) {\n              verifyIsStub(method);\n\n              let msg;\n              if (typeof count !== \"number\") {\n                  msg =\n                      `expected ${inspect(count)} to be a number ` +\n                      `but was of type ${typeof count}`;\n                  failAssertion(this, msg);\n              } else if (method.callCount !== count) {\n                  msg =\n                      `expected %n to be called ${timesInWords(count)} ` +\n                      `but was called %c%C`;\n                  failAssertion(this, method.printf(msg));\n              } else {\n                  assert.pass(\"callCount\");\n              }\n          },\n\n          expose: function expose(target, options) {\n              if (!target) {\n                  throw new TypeError(\"target is null or undefined\");\n              }\n\n              const o = options || {};\n              const prefix =\n                  (typeof o.prefix === \"undefined\" && \"assert\") || o.prefix;\n              const includeFail =\n                  typeof o.includeFail === \"undefined\" || Boolean(o.includeFail);\n              const instance = this;\n\n              forEach(Object.keys(instance), function (method) {\n                  if (\n                      method !== \"expose\" &&\n                      (includeFail || !/^(fail)/.test(method))\n                  ) {\n                      target[exposedName(prefix, method)] = instance[method];\n                  }\n              });\n\n              return target;\n          },\n\n          match: function match(actual, expectation) {\n              const matcher = createMatcher(expectation);\n              if (matcher.test(actual)) {\n                  assert.pass(\"match\");\n              } else {\n                  const formatted = [\n                      \"expected value to match\",\n                      `    expected = ${inspect(expectation)}`,\n                      `    actual = ${inspect(actual)}`,\n                  ];\n\n                  failAssertion(this, join(formatted, \"\\n\"));\n              }\n          },\n      };\n\n      function verifyIsStub() {\n          const args = arraySlice(arguments);\n\n          forEach(args, function (method) {\n              if (!method) {\n                  assert.fail(\"fake is not a spy\");\n              }\n\n              if (method.proxy && method.proxy.isSinonProxy) {\n                  verifyIsStub(method.proxy);\n              } else {\n                  if (typeof method !== \"function\") {\n                      assert.fail(`${method} is not a function`);\n                  }\n\n                  if (typeof method.getCall !== \"function\") {\n                      assert.fail(`${method} is not stubbed`);\n                  }\n              }\n          });\n      }\n\n      function verifyIsValidAssertion(assertionMethod, assertionArgs) {\n          switch (assertionMethod) {\n              case \"notCalled\":\n              case \"called\":\n              case \"calledOnce\":\n              case \"calledTwice\":\n              case \"calledThrice\":\n                  if (assertionArgs.length !== 0) {\n                      assert.fail(\n                          `${assertionMethod} takes 1 argument but was called with ${\n                            assertionArgs.length + 1\n                        } arguments`,\n                      );\n                  }\n                  break;\n          }\n      }\n\n      function failAssertion(object, msg) {\n          const obj = object || globalObject;\n          const failMethod = obj.fail || assert.fail;\n          failMethod.call(obj, msg);\n      }\n\n      function mirrorPropAsAssertion(name, method, message) {\n          let msg = message;\n          let meth = method;\n          if (arguments.length === 2) {\n              msg = method;\n              meth = name;\n          }\n\n          assert[name] = function (fake) {\n              verifyIsStub(fake);\n\n              const args = arraySlice(arguments, 1);\n              let failed = false;\n\n              verifyIsValidAssertion(name, args);\n\n              if (typeof meth === \"function\") {\n                  failed = !meth(fake);\n              } else {\n                  failed =\n                      typeof fake[meth] === \"function\"\n                          ? !fake[meth].apply(fake, args)\n                          : !fake[meth];\n              }\n\n              if (failed) {\n                  failAssertion(\n                      this,\n                      (fake.printf || fake.proxy.printf).apply(\n                          fake,\n                          concat([msg], args),\n                      ),\n                  );\n              } else {\n                  assert.pass(name);\n              }\n          };\n      }\n\n      function exposedName(prefix, prop) {\n          return !prefix || /^fail/.test(prop)\n              ? prop\n              : prefix +\n                    stringSlice(prop, 0, 1).toUpperCase() +\n                    stringSlice(prop, 1);\n      }\n\n      mirrorPropAsAssertion(\n          \"called\",\n          \"expected %n to have been called at least once but was never called\",\n      );\n      mirrorPropAsAssertion(\n          \"notCalled\",\n          function (spy) {\n              return !spy.called;\n          },\n          \"expected %n to not have been called but was called %c%C\",\n      );\n      mirrorPropAsAssertion(\n          \"calledOnce\",\n          \"expected %n to be called once but was called %c%C\",\n      );\n      mirrorPropAsAssertion(\n          \"calledTwice\",\n          \"expected %n to be called twice but was called %c%C\",\n      );\n      mirrorPropAsAssertion(\n          \"calledThrice\",\n          \"expected %n to be called thrice but was called %c%C\",\n      );\n      mirrorPropAsAssertion(\n          \"calledOn\",\n          \"expected %n to be called with %1 as this but was called with %t\",\n      );\n      mirrorPropAsAssertion(\n          \"alwaysCalledOn\",\n          \"expected %n to always be called with %1 as this but was called with %t\",\n      );\n      mirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\n      mirrorPropAsAssertion(\n          \"alwaysCalledWithNew\",\n          \"expected %n to always be called with new\",\n      );\n      mirrorPropAsAssertion(\n          \"calledWith\",\n          \"expected %n to be called with arguments %D\",\n      );\n      mirrorPropAsAssertion(\n          \"calledWithMatch\",\n          \"expected %n to be called with match %D\",\n      );\n      mirrorPropAsAssertion(\n          \"alwaysCalledWith\",\n          \"expected %n to always be called with arguments %D\",\n      );\n      mirrorPropAsAssertion(\n          \"alwaysCalledWithMatch\",\n          \"expected %n to always be called with match %D\",\n      );\n      mirrorPropAsAssertion(\n          \"calledWithExactly\",\n          \"expected %n to be called with exact arguments %D\",\n      );\n      mirrorPropAsAssertion(\n          \"calledOnceWithExactly\",\n          \"expected %n to be called once and with exact arguments %D\",\n      );\n      mirrorPropAsAssertion(\n          \"calledOnceWithMatch\",\n          \"expected %n to be called once and with match %D\",\n      );\n      mirrorPropAsAssertion(\n          \"alwaysCalledWithExactly\",\n          \"expected %n to always be called with exact arguments %D\",\n      );\n      mirrorPropAsAssertion(\n          \"neverCalledWith\",\n          \"expected %n to never be called with arguments %*%C\",\n      );\n      mirrorPropAsAssertion(\n          \"neverCalledWithMatch\",\n          \"expected %n to never be called with match %*%C\",\n      );\n      mirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\n      mirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\n\n      return assert;\n  }\n\n  module.exports = createAssertObject();\n  module.exports.createAssertObject = createAssertObject;\n\n  },{\"./util/core/times-in-words\":36,\"@sinonjs/commons\":47,\"@sinonjs/samsam\":87,\"util\":91}],5:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const extend = require(\"./util/core/extend\");\n  const functionName = require(\"@sinonjs/commons\").functionName;\n  const nextTick = require(\"./util/core/next-tick\");\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n  const exportAsyncBehaviors = require(\"./util/core/export-async-behaviors\");\n\n  const concat = arrayProto.concat;\n  const join = arrayProto.join;\n  const reverse = arrayProto.reverse;\n  const slice = arrayProto.slice;\n\n  const useLeftMostCallback = -1;\n  const useRightMostCallback = -2;\n\n  function getCallback(behavior, args) {\n      const callArgAt = behavior.callArgAt;\n\n      if (callArgAt >= 0) {\n          return args[callArgAt];\n      }\n\n      let argumentList;\n\n      if (callArgAt === useLeftMostCallback) {\n          argumentList = args;\n      }\n\n      if (callArgAt === useRightMostCallback) {\n          argumentList = reverse(slice(args));\n      }\n\n      const callArgProp = behavior.callArgProp;\n\n      for (let i = 0, l = argumentList.length; i < l; ++i) {\n          if (!callArgProp && typeof argumentList[i] === \"function\") {\n              return argumentList[i];\n          }\n\n          if (\n              callArgProp &&\n              argumentList[i] &&\n              typeof argumentList[i][callArgProp] === \"function\"\n          ) {\n              return argumentList[i][callArgProp];\n          }\n      }\n\n      return null;\n  }\n\n  function getCallbackError(behavior, func, args) {\n      if (behavior.callArgAt < 0) {\n          let msg;\n\n          if (behavior.callArgProp) {\n              msg = `${functionName(\n                behavior.stub,\n            )} expected to yield to '${valueToString(\n                behavior.callArgProp,\n            )}', but no object with such a property was passed.`;\n          } else {\n              msg = `${functionName(\n                behavior.stub,\n            )} expected to yield, but no callback was passed.`;\n          }\n\n          if (args.length > 0) {\n              msg += ` Received [${join(args, \", \")}]`;\n          }\n\n          return msg;\n      }\n\n      return `argument at index ${behavior.callArgAt} is not a function: ${func}`;\n  }\n\n  function ensureArgs(name, behavior, args) {\n      // map function name to internal property\n      //   callsArg => callArgAt\n      const property = name.replace(/sArg/, \"ArgAt\");\n      const index = behavior[property];\n\n      if (index >= args.length) {\n          throw new TypeError(\n              `${name} failed: ${index + 1} arguments required but only ${\n                args.length\n            } present`,\n          );\n      }\n  }\n\n  function callCallback(behavior, args) {\n      if (typeof behavior.callArgAt === \"number\") {\n          ensureArgs(\"callsArg\", behavior, args);\n          const func = getCallback(behavior, args);\n\n          if (typeof func !== \"function\") {\n              throw new TypeError(getCallbackError(behavior, func, args));\n          }\n\n          if (behavior.callbackAsync) {\n              nextTick(function () {\n                  func.apply(\n                      behavior.callbackContext,\n                      behavior.callbackArguments,\n                  );\n              });\n          } else {\n              return func.apply(\n                  behavior.callbackContext,\n                  behavior.callbackArguments,\n              );\n          }\n      }\n\n      return undefined;\n  }\n\n  const proto = {\n      create: function create(stub) {\n          const behavior = extend({}, proto);\n          delete behavior.create;\n          delete behavior.addBehavior;\n          delete behavior.createBehavior;\n          behavior.stub = stub;\n\n          if (stub.defaultBehavior && stub.defaultBehavior.promiseLibrary) {\n              behavior.promiseLibrary = stub.defaultBehavior.promiseLibrary;\n          }\n\n          return behavior;\n      },\n\n      isPresent: function isPresent() {\n          return (\n              typeof this.callArgAt === \"number\" ||\n              this.exception ||\n              this.exceptionCreator ||\n              typeof this.returnArgAt === \"number\" ||\n              this.returnThis ||\n              typeof this.resolveArgAt === \"number\" ||\n              this.resolveThis ||\n              typeof this.throwArgAt === \"number\" ||\n              this.fakeFn ||\n              this.returnValueDefined\n          );\n      },\n\n      /*eslint complexity: [\"error\", 20]*/\n      invoke: function invoke(context, args) {\n          /*\n           * callCallback (conditionally) calls ensureArgs\n           *\n           * Note: callCallback intentionally happens before\n           * everything else and cannot be moved lower\n           */\n          const returnValue = callCallback(this, args);\n\n          if (this.exception) {\n              throw this.exception;\n          } else if (this.exceptionCreator) {\n              this.exception = this.exceptionCreator();\n              this.exceptionCreator = undefined;\n              throw this.exception;\n          } else if (typeof this.returnArgAt === \"number\") {\n              ensureArgs(\"returnsArg\", this, args);\n              return args[this.returnArgAt];\n          } else if (this.returnThis) {\n              return context;\n          } else if (typeof this.throwArgAt === \"number\") {\n              ensureArgs(\"throwsArg\", this, args);\n              throw args[this.throwArgAt];\n          } else if (this.fakeFn) {\n              return this.fakeFn.apply(context, args);\n          } else if (typeof this.resolveArgAt === \"number\") {\n              ensureArgs(\"resolvesArg\", this, args);\n              return (this.promiseLibrary || Promise).resolve(\n                  args[this.resolveArgAt],\n              );\n          } else if (this.resolveThis) {\n              return (this.promiseLibrary || Promise).resolve(context);\n          } else if (this.resolve) {\n              return (this.promiseLibrary || Promise).resolve(this.returnValue);\n          } else if (this.reject) {\n              return (this.promiseLibrary || Promise).reject(this.returnValue);\n          } else if (this.callsThrough) {\n              const wrappedMethod = this.effectiveWrappedMethod();\n\n              return wrappedMethod.apply(context, args);\n          } else if (this.callsThroughWithNew) {\n              // Get the original method (assumed to be a constructor in this case)\n              const WrappedClass = this.effectiveWrappedMethod();\n              // Turn the arguments object into a normal array\n              const argsArray = slice(args);\n              // Call the constructor\n              const F = WrappedClass.bind.apply(\n                  WrappedClass,\n                  concat([null], argsArray),\n              );\n              return new F();\n          } else if (typeof this.returnValue !== \"undefined\") {\n              return this.returnValue;\n          } else if (typeof this.callArgAt === \"number\") {\n              return returnValue;\n          }\n\n          return this.returnValue;\n      },\n\n      effectiveWrappedMethod: function effectiveWrappedMethod() {\n          for (let stubb = this.stub; stubb; stubb = stubb.parent) {\n              if (stubb.wrappedMethod) {\n                  return stubb.wrappedMethod;\n              }\n          }\n          throw new Error(\"Unable to find wrapped method\");\n      },\n\n      onCall: function onCall(index) {\n          return this.stub.onCall(index);\n      },\n\n      onFirstCall: function onFirstCall() {\n          return this.stub.onFirstCall();\n      },\n\n      onSecondCall: function onSecondCall() {\n          return this.stub.onSecondCall();\n      },\n\n      onThirdCall: function onThirdCall() {\n          return this.stub.onThirdCall();\n      },\n\n      withArgs: function withArgs(/* arguments */) {\n          throw new Error(\n              'Defining a stub by invoking \"stub.onCall(...).withArgs(...)\" ' +\n                  'is not supported. Use \"stub.withArgs(...).onCall(...)\" ' +\n                  \"to define sequential behavior for calls with certain arguments.\",\n          );\n      },\n  };\n\n  function createBehavior(behaviorMethod) {\n      return function () {\n          this.defaultBehavior = this.defaultBehavior || proto.create(this);\n          this.defaultBehavior[behaviorMethod].apply(\n              this.defaultBehavior,\n              arguments,\n          );\n          return this;\n      };\n  }\n\n  function addBehavior(stub, name, fn) {\n      proto[name] = function () {\n          fn.apply(this, concat([this], slice(arguments)));\n          return this.stub || this;\n      };\n\n      stub[name] = createBehavior(name);\n  }\n\n  proto.addBehavior = addBehavior;\n  proto.createBehavior = createBehavior;\n\n  const asyncBehaviors = exportAsyncBehaviors(proto);\n\n  module.exports = extend.nonEnum({}, proto, asyncBehaviors);\n\n  },{\"./util/core/export-async-behaviors\":25,\"./util/core/extend\":26,\"./util/core/next-tick\":34,\"@sinonjs/commons\":47}],6:[function(require,module,exports){\n\n  const walk = require(\"./util/core/walk\");\n  const getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n  const hasOwnProperty =\n      require(\"@sinonjs/commons\").prototypes.object.hasOwnProperty;\n  const push = require(\"@sinonjs/commons\").prototypes.array.push;\n\n  function collectMethod(methods, object, prop, propOwner) {\n      if (\n          typeof getPropertyDescriptor(propOwner, prop).value === \"function\" &&\n          hasOwnProperty(object, prop)\n      ) {\n          push(methods, object[prop]);\n      }\n  }\n\n  // This function returns an array of all the own methods on the passed object\n  function collectOwnMethods(object) {\n      const methods = [];\n\n      walk(object, collectMethod.bind(null, methods, object));\n\n      return methods;\n  }\n\n  module.exports = collectOwnMethods;\n\n  },{\"./util/core/get-property-descriptor\":29,\"./util/core/walk\":38,\"@sinonjs/commons\":47}],7:[function(require,module,exports){\n\n  module.exports = class Colorizer {\n      constructor(supportsColor = require(\"supports-color\")) {\n          this.supportsColor = supportsColor;\n      }\n\n      /**\n       * Should be renamed to true #privateField\n       * when we can ensure ES2022 support\n       *\n       * @private\n       */\n      colorize(str, color) {\n          if (this.supportsColor.stdout === false) {\n              return str;\n          }\n\n          return `\\x1b[${color}m${str}\\x1b[0m`;\n      }\n\n      red(str) {\n          return this.colorize(str, 31);\n      }\n\n      green(str) {\n          return this.colorize(str, 32);\n      }\n\n      cyan(str) {\n          return this.colorize(str, 96);\n      }\n\n      white(str) {\n          return this.colorize(str, 39);\n      }\n\n      bold(str) {\n          return this.colorize(str, 1);\n      }\n  };\n\n  },{\"supports-color\":94}],8:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const Sandbox = require(\"./sandbox\");\n\n  const forEach = arrayProto.forEach;\n  const push = arrayProto.push;\n\n  function prepareSandboxFromConfig(config) {\n      const sandbox = new Sandbox({ assertOptions: config.assertOptions });\n\n      if (config.useFakeTimers) {\n          if (typeof config.useFakeTimers === \"object\") {\n              sandbox.useFakeTimers(config.useFakeTimers);\n          } else {\n              sandbox.useFakeTimers();\n          }\n      }\n\n      return sandbox;\n  }\n\n  function exposeValue(sandbox, config, key, value) {\n      if (!value) {\n          return;\n      }\n\n      if (config.injectInto && !(key in config.injectInto)) {\n          config.injectInto[key] = value;\n          push(sandbox.injectedKeys, key);\n      } else {\n          push(sandbox.args, value);\n      }\n  }\n\n  /**\n   * Options to customize a sandbox\n   *\n   * The sandbox's methods can be injected into another object for\n   * convenience. The `injectInto` configuration option can name an\n   * object to add properties to.\n   *\n   * @typedef {object} SandboxConfig\n   * @property {string[]} properties The properties of the API to expose on the sandbox. Examples: ['spy', 'fake', 'restore']\n   * @property {object} injectInto an object in which to inject properties from the sandbox (a facade). This is mostly an integration feature (sinon-test being one).\n   * @property {boolean} useFakeTimers  whether timers are faked by default\n   * @property {object} [assertOptions] see CreateAssertOptions in ./assert\n   *\n   * This type def is really suffering from JSDoc not having standardized\n   * how to reference types defined in other modules :(\n   */\n\n  /**\n   * A configured sinon sandbox (private type)\n   *\n   * @typedef {object} ConfiguredSinonSandboxType\n   * @private\n   * @augments Sandbox\n   * @property {string[]} injectedKeys the keys that have been injected (from config.injectInto)\n   * @property {*[]} args the arguments for the sandbox\n   */\n\n  /**\n   * Create a sandbox\n   *\n   * As of Sinon 5 the `sinon` instance itself is a Sandbox, so you\n   * hardly ever need to create additional instances for the sake of testing\n   *\n   * @param config {SandboxConfig}\n   * @returns {Sandbox}\n   */\n  function createSandbox(config) {\n      if (!config) {\n          return new Sandbox();\n      }\n\n      const configuredSandbox = prepareSandboxFromConfig(config);\n      configuredSandbox.args = configuredSandbox.args || [];\n      configuredSandbox.injectedKeys = [];\n      configuredSandbox.injectInto = config.injectInto;\n      const exposed = configuredSandbox.inject({});\n\n      if (config.properties) {\n          forEach(config.properties, function (prop) {\n              const value =\n                  exposed[prop] || (prop === \"sandbox\" && configuredSandbox);\n              exposeValue(configuredSandbox, config, prop, value);\n          });\n      } else {\n          exposeValue(configuredSandbox, config, \"sandbox\");\n      }\n\n      return configuredSandbox;\n  }\n\n  module.exports = createSandbox;\n\n  },{\"./sandbox\":20,\"@sinonjs/commons\":47}],9:[function(require,module,exports){\n\n  const stub = require(\"./stub\");\n  const sinonType = require(\"./util/core/sinon-type\");\n  const forEach = require(\"@sinonjs/commons\").prototypes.array.forEach;\n\n  function isStub(value) {\n      return sinonType.get(value) === \"stub\";\n  }\n\n  module.exports = function createStubInstance(constructor, overrides) {\n      if (typeof constructor !== \"function\") {\n          throw new TypeError(\"The constructor should be a function.\");\n      }\n\n      const stubInstance = Object.create(constructor.prototype);\n      sinonType.set(stubInstance, \"stub-instance\");\n\n      const stubbedObject = stub(stubInstance);\n\n      forEach(Object.keys(overrides || {}), function (propertyName) {\n          if (propertyName in stubbedObject) {\n              const value = overrides[propertyName];\n              if (isStub(value)) {\n                  stubbedObject[propertyName] = value;\n              } else {\n                  stubbedObject[propertyName].returns(value);\n              }\n          } else {\n              throw new Error(\n                  `Cannot stub ${propertyName}. Property does not exist!`,\n              );\n          }\n      });\n      return stubbedObject;\n  };\n\n  },{\"./stub\":23,\"./util/core/sinon-type\":35,\"@sinonjs/commons\":47}],10:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const isPropertyConfigurable = require(\"./util/core/is-property-configurable\");\n  const exportAsyncBehaviors = require(\"./util/core/export-async-behaviors\");\n  const extend = require(\"./util/core/extend\");\n\n  const slice = arrayProto.slice;\n\n  const useLeftMostCallback = -1;\n  const useRightMostCallback = -2;\n\n  function throwsException(fake, error, message) {\n      if (typeof error === \"function\") {\n          fake.exceptionCreator = error;\n      } else if (typeof error === \"string\") {\n          fake.exceptionCreator = function () {\n              const newException = new Error(\n                  message || `Sinon-provided ${error}`,\n              );\n              newException.name = error;\n              return newException;\n          };\n      } else if (!error) {\n          fake.exceptionCreator = function () {\n              return new Error(\"Error\");\n          };\n      } else {\n          fake.exception = error;\n      }\n  }\n\n  const defaultBehaviors = {\n      callsFake: function callsFake(fake, fn) {\n          fake.fakeFn = fn;\n          fake.exception = undefined;\n          fake.exceptionCreator = undefined;\n          fake.callsThrough = false;\n      },\n\n      callsArg: function callsArg(fake, index) {\n          if (typeof index !== \"number\") {\n              throw new TypeError(\"argument index is not number\");\n          }\n\n          fake.callArgAt = index;\n          fake.callbackArguments = [];\n          fake.callbackContext = undefined;\n          fake.callArgProp = undefined;\n          fake.callbackAsync = false;\n          fake.callsThrough = false;\n      },\n\n      callsArgOn: function callsArgOn(fake, index, context) {\n          if (typeof index !== \"number\") {\n              throw new TypeError(\"argument index is not number\");\n          }\n\n          fake.callArgAt = index;\n          fake.callbackArguments = [];\n          fake.callbackContext = context;\n          fake.callArgProp = undefined;\n          fake.callbackAsync = false;\n          fake.callsThrough = false;\n      },\n\n      callsArgWith: function callsArgWith(fake, index) {\n          if (typeof index !== \"number\") {\n              throw new TypeError(\"argument index is not number\");\n          }\n\n          fake.callArgAt = index;\n          fake.callbackArguments = slice(arguments, 2);\n          fake.callbackContext = undefined;\n          fake.callArgProp = undefined;\n          fake.callbackAsync = false;\n          fake.callsThrough = false;\n      },\n\n      callsArgOnWith: function callsArgWith(fake, index, context) {\n          if (typeof index !== \"number\") {\n              throw new TypeError(\"argument index is not number\");\n          }\n\n          fake.callArgAt = index;\n          fake.callbackArguments = slice(arguments, 3);\n          fake.callbackContext = context;\n          fake.callArgProp = undefined;\n          fake.callbackAsync = false;\n          fake.callsThrough = false;\n      },\n\n      yields: function (fake) {\n          fake.callArgAt = useLeftMostCallback;\n          fake.callbackArguments = slice(arguments, 1);\n          fake.callbackContext = undefined;\n          fake.callArgProp = undefined;\n          fake.callbackAsync = false;\n          fake.fakeFn = undefined;\n          fake.callsThrough = false;\n      },\n\n      yieldsRight: function (fake) {\n          fake.callArgAt = useRightMostCallback;\n          fake.callbackArguments = slice(arguments, 1);\n          fake.callbackContext = undefined;\n          fake.callArgProp = undefined;\n          fake.callbackAsync = false;\n          fake.callsThrough = false;\n          fake.fakeFn = undefined;\n      },\n\n      yieldsOn: function (fake, context) {\n          fake.callArgAt = useLeftMostCallback;\n          fake.callbackArguments = slice(arguments, 2);\n          fake.callbackContext = context;\n          fake.callArgProp = undefined;\n          fake.callbackAsync = false;\n          fake.callsThrough = false;\n          fake.fakeFn = undefined;\n      },\n\n      yieldsTo: function (fake, prop) {\n          fake.callArgAt = useLeftMostCallback;\n          fake.callbackArguments = slice(arguments, 2);\n          fake.callbackContext = undefined;\n          fake.callArgProp = prop;\n          fake.callbackAsync = false;\n          fake.callsThrough = false;\n          fake.fakeFn = undefined;\n      },\n\n      yieldsToOn: function (fake, prop, context) {\n          fake.callArgAt = useLeftMostCallback;\n          fake.callbackArguments = slice(arguments, 3);\n          fake.callbackContext = context;\n          fake.callArgProp = prop;\n          fake.callbackAsync = false;\n          fake.fakeFn = undefined;\n      },\n\n      throws: throwsException,\n      throwsException: throwsException,\n\n      returns: function returns(fake, value) {\n          fake.callsThrough = false;\n          fake.returnValue = value;\n          fake.resolve = false;\n          fake.reject = false;\n          fake.returnValueDefined = true;\n          fake.exception = undefined;\n          fake.exceptionCreator = undefined;\n          fake.fakeFn = undefined;\n      },\n\n      returnsArg: function returnsArg(fake, index) {\n          if (typeof index !== \"number\") {\n              throw new TypeError(\"argument index is not number\");\n          }\n          fake.callsThrough = false;\n\n          fake.returnArgAt = index;\n      },\n\n      throwsArg: function throwsArg(fake, index) {\n          if (typeof index !== \"number\") {\n              throw new TypeError(\"argument index is not number\");\n          }\n          fake.callsThrough = false;\n\n          fake.throwArgAt = index;\n      },\n\n      returnsThis: function returnsThis(fake) {\n          fake.returnThis = true;\n          fake.callsThrough = false;\n      },\n\n      resolves: function resolves(fake, value) {\n          fake.returnValue = value;\n          fake.resolve = true;\n          fake.resolveThis = false;\n          fake.reject = false;\n          fake.returnValueDefined = true;\n          fake.exception = undefined;\n          fake.exceptionCreator = undefined;\n          fake.fakeFn = undefined;\n          fake.callsThrough = false;\n      },\n\n      resolvesArg: function resolvesArg(fake, index) {\n          if (typeof index !== \"number\") {\n              throw new TypeError(\"argument index is not number\");\n          }\n          fake.resolveArgAt = index;\n          fake.returnValue = undefined;\n          fake.resolve = true;\n          fake.resolveThis = false;\n          fake.reject = false;\n          fake.returnValueDefined = false;\n          fake.exception = undefined;\n          fake.exceptionCreator = undefined;\n          fake.fakeFn = undefined;\n          fake.callsThrough = false;\n      },\n\n      rejects: function rejects(fake, error, message) {\n          let reason;\n          if (typeof error === \"string\") {\n              reason = new Error(message || \"\");\n              reason.name = error;\n          } else if (!error) {\n              reason = new Error(\"Error\");\n          } else {\n              reason = error;\n          }\n          fake.returnValue = reason;\n          fake.resolve = false;\n          fake.resolveThis = false;\n          fake.reject = true;\n          fake.returnValueDefined = true;\n          fake.exception = undefined;\n          fake.exceptionCreator = undefined;\n          fake.fakeFn = undefined;\n          fake.callsThrough = false;\n\n          return fake;\n      },\n\n      resolvesThis: function resolvesThis(fake) {\n          fake.returnValue = undefined;\n          fake.resolve = false;\n          fake.resolveThis = true;\n          fake.reject = false;\n          fake.returnValueDefined = false;\n          fake.exception = undefined;\n          fake.exceptionCreator = undefined;\n          fake.fakeFn = undefined;\n          fake.callsThrough = false;\n      },\n\n      callThrough: function callThrough(fake) {\n          fake.callsThrough = true;\n      },\n\n      callThroughWithNew: function callThroughWithNew(fake) {\n          fake.callsThroughWithNew = true;\n      },\n\n      get: function get(fake, getterFunction) {\n          const rootStub = fake.stub || fake;\n\n          Object.defineProperty(rootStub.rootObj, rootStub.propName, {\n              get: getterFunction,\n              configurable: isPropertyConfigurable(\n                  rootStub.rootObj,\n                  rootStub.propName,\n              ),\n          });\n\n          return fake;\n      },\n\n      set: function set(fake, setterFunction) {\n          const rootStub = fake.stub || fake;\n\n          Object.defineProperty(\n              rootStub.rootObj,\n              rootStub.propName,\n              // eslint-disable-next-line accessor-pairs\n              {\n                  set: setterFunction,\n                  configurable: isPropertyConfigurable(\n                      rootStub.rootObj,\n                      rootStub.propName,\n                  ),\n              },\n          );\n\n          return fake;\n      },\n\n      value: function value(fake, newVal) {\n          const rootStub = fake.stub || fake;\n\n          Object.defineProperty(rootStub.rootObj, rootStub.propName, {\n              value: newVal,\n              enumerable: true,\n              writable: true,\n              configurable:\n                  rootStub.shadowsPropOnPrototype ||\n                  isPropertyConfigurable(rootStub.rootObj, rootStub.propName),\n          });\n\n          return fake;\n      },\n  };\n\n  const asyncBehaviors = exportAsyncBehaviors(defaultBehaviors);\n\n  module.exports = extend({}, defaultBehaviors, asyncBehaviors);\n\n  },{\"./util/core/export-async-behaviors\":25,\"./util/core/extend\":26,\"./util/core/is-property-configurable\":32,\"@sinonjs/commons\":47}],11:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const createProxy = require(\"./proxy\");\n  const nextTick = require(\"./util/core/next-tick\");\n\n  const slice = arrayProto.slice;\n\n  module.exports = fake;\n\n  /**\n   * Returns a `fake` that records all calls, arguments and return values.\n   *\n   * When an `f` argument is supplied, this implementation will be used.\n   *\n   * @example\n   * // create an empty fake\n   * var f1 = sinon.fake();\n   *\n   * f1();\n   *\n   * f1.calledOnce()\n   * // true\n   *\n   * @example\n   * function greet(greeting) {\n   *   console.log(`Hello ${greeting}`);\n   * }\n   *\n   * // create a fake with implementation\n   * var f2 = sinon.fake(greet);\n   *\n   * // Hello world\n   * f2(\"world\");\n   *\n   * f2.calledWith(\"world\");\n   * // true\n   *\n   * @param {Function|undefined} f\n   * @returns {Function}\n   * @namespace\n   */\n  function fake(f) {\n      if (arguments.length > 0 && typeof f !== \"function\") {\n          throw new TypeError(\"Expected f argument to be a Function\");\n      }\n\n      return wrapFunc(f);\n  }\n\n  /**\n   * Creates a `fake` that returns the provided `value`, as well as recording all\n   * calls, arguments and return values.\n   *\n   * @example\n   * var f1 = sinon.fake.returns(42);\n   *\n   * f1();\n   * // 42\n   *\n   * @memberof fake\n   * @param {*} value\n   * @returns {Function}\n   */\n  fake.returns = function returns(value) {\n      // eslint-disable-next-line jsdoc/require-jsdoc\n      function f() {\n          return value;\n      }\n\n      return wrapFunc(f);\n  };\n\n  /**\n   * Creates a `fake` that throws an Error.\n   * If the `value` argument does not have Error in its prototype chain, it will\n   * be used for creating a new error.\n   *\n   * @example\n   * var f1 = sinon.fake.throws(\"hello\");\n   *\n   * f1();\n   * // Uncaught Error: hello\n   *\n   * @example\n   * var f2 = sinon.fake.throws(new TypeError(\"Invalid argument\"));\n   *\n   * f2();\n   * // Uncaught TypeError: Invalid argument\n   *\n   * @memberof fake\n   * @param {*|Error} value\n   * @returns {Function}\n   */\n  fake.throws = function throws(value) {\n      // eslint-disable-next-line jsdoc/require-jsdoc\n      function f() {\n          throw getError(value);\n      }\n\n      return wrapFunc(f);\n  };\n\n  /**\n   * Creates a `fake` that returns a promise that resolves to the passed `value`\n   * argument.\n   *\n   * @example\n   * var f1 = sinon.fake.resolves(\"apple pie\");\n   *\n   * await f1();\n   * // \"apple pie\"\n   *\n   * @memberof fake\n   * @param {*} value\n   * @returns {Function}\n   */\n  fake.resolves = function resolves(value) {\n      // eslint-disable-next-line jsdoc/require-jsdoc\n      function f() {\n          return Promise.resolve(value);\n      }\n\n      return wrapFunc(f);\n  };\n\n  /**\n   * Creates a `fake` that returns a promise that rejects to the passed `value`\n   * argument. When `value` does not have Error in its prototype chain, it will be\n   * wrapped in an Error.\n   *\n   * @example\n   * var f1 = sinon.fake.rejects(\":(\");\n   *\n   * try {\n   *   await f1();\n   * } catch (error) {\n   *   console.log(error);\n   *   // \":(\"\n   * }\n   *\n   * @memberof fake\n   * @param {*} value\n   * @returns {Function}\n   */\n  fake.rejects = function rejects(value) {\n      // eslint-disable-next-line jsdoc/require-jsdoc\n      function f() {\n          return Promise.reject(getError(value));\n      }\n\n      return wrapFunc(f);\n  };\n\n  /**\n   * Returns a `fake` that calls the callback with the defined arguments.\n   *\n   * @example\n   * function callback() {\n   *   console.log(arguments.join(\"*\"));\n   * }\n   *\n   * const f1 = sinon.fake.yields(\"apple\", \"pie\");\n   *\n   * f1(callback);\n   * // \"apple*pie\"\n   *\n   * @memberof fake\n   * @returns {Function}\n   */\n  fake.yields = function yields() {\n      const values = slice(arguments);\n\n      // eslint-disable-next-line jsdoc/require-jsdoc\n      function f() {\n          const callback = arguments[arguments.length - 1];\n          if (typeof callback !== \"function\") {\n              throw new TypeError(\"Expected last argument to be a function\");\n          }\n\n          callback.apply(null, values);\n      }\n\n      return wrapFunc(f);\n  };\n\n  /**\n   * Returns a `fake` that calls the callback **asynchronously** with the\n   * defined arguments.\n   *\n   * @example\n   * function callback() {\n   *   console.log(arguments.join(\"*\"));\n   * }\n   *\n   * const f1 = sinon.fake.yields(\"apple\", \"pie\");\n   *\n   * f1(callback);\n   *\n   * setTimeout(() => {\n   *   // \"apple*pie\"\n   * });\n   *\n   * @memberof fake\n   * @returns {Function}\n   */\n  fake.yieldsAsync = function yieldsAsync() {\n      const values = slice(arguments);\n\n      // eslint-disable-next-line jsdoc/require-jsdoc\n      function f() {\n          const callback = arguments[arguments.length - 1];\n          if (typeof callback !== \"function\") {\n              throw new TypeError(\"Expected last argument to be a function\");\n          }\n          nextTick(function () {\n              callback.apply(null, values);\n          });\n      }\n\n      return wrapFunc(f);\n  };\n\n  let uuid = 0;\n  /**\n   * Creates a proxy (sinon concept) from the passed function.\n   *\n   * @private\n   * @param  {Function} f\n   * @returns {Function}\n   */\n  function wrapFunc(f) {\n      const fakeInstance = function () {\n          let firstArg, lastArg;\n\n          if (arguments.length > 0) {\n              firstArg = arguments[0];\n              lastArg = arguments[arguments.length - 1];\n          }\n\n          const callback =\n              lastArg && typeof lastArg === \"function\" ? lastArg : undefined;\n\n          /* eslint-disable no-use-before-define */\n          proxy.firstArg = firstArg;\n          proxy.lastArg = lastArg;\n          proxy.callback = callback;\n\n          return f && f.apply(this, arguments);\n      };\n      const proxy = createProxy(fakeInstance, f || fakeInstance);\n\n      proxy.displayName = \"fake\";\n      proxy.id = `fake#${uuid++}`;\n\n      return proxy;\n  }\n\n  /**\n   * Returns an Error instance from the passed value, if the value is not\n   * already an Error instance.\n   *\n   * @private\n   * @param  {*} value [description]\n   * @returns {Error}       [description]\n   */\n  function getError(value) {\n      return value instanceof Error ? value : new Error(value);\n  }\n\n  },{\"./proxy\":18,\"./util/core/next-tick\":34,\"@sinonjs/commons\":47}],12:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const proxyInvoke = require(\"./proxy-invoke\");\n  const proxyCallToString = require(\"./proxy-call\").toString;\n  const timesInWords = require(\"./util/core/times-in-words\");\n  const extend = require(\"./util/core/extend\");\n  const match = require(\"@sinonjs/samsam\").createMatcher;\n  const stub = require(\"./stub\");\n  const assert = require(\"./assert\");\n  const deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n  const inspect = require(\"util\").inspect;\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  const every = arrayProto.every;\n  const forEach = arrayProto.forEach;\n  const push = arrayProto.push;\n  const slice = arrayProto.slice;\n\n  function callCountInWords(callCount) {\n      if (callCount === 0) {\n          return \"never called\";\n      }\n\n      return `called ${timesInWords(callCount)}`;\n  }\n\n  function expectedCallCountInWords(expectation) {\n      const min = expectation.minCalls;\n      const max = expectation.maxCalls;\n\n      if (typeof min === \"number\" && typeof max === \"number\") {\n          let str = timesInWords(min);\n\n          if (min !== max) {\n              str = `at least ${str} and at most ${timesInWords(max)}`;\n          }\n\n          return str;\n      }\n\n      if (typeof min === \"number\") {\n          return `at least ${timesInWords(min)}`;\n      }\n\n      return `at most ${timesInWords(max)}`;\n  }\n\n  function receivedMinCalls(expectation) {\n      const hasMinLimit = typeof expectation.minCalls === \"number\";\n      return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n  }\n\n  function receivedMaxCalls(expectation) {\n      if (typeof expectation.maxCalls !== \"number\") {\n          return false;\n      }\n\n      return expectation.callCount === expectation.maxCalls;\n  }\n\n  function verifyMatcher(possibleMatcher, arg) {\n      const isMatcher = match.isMatcher(possibleMatcher);\n\n      return (isMatcher && possibleMatcher.test(arg)) || true;\n  }\n\n  const mockExpectation = {\n      minCalls: 1,\n      maxCalls: 1,\n\n      create: function create(methodName) {\n          const expectation = extend.nonEnum(stub(), mockExpectation);\n          delete expectation.create;\n          expectation.method = methodName;\n\n          return expectation;\n      },\n\n      invoke: function invoke(func, thisValue, args) {\n          this.verifyCallAllowed(thisValue, args);\n\n          return proxyInvoke.apply(this, arguments);\n      },\n\n      atLeast: function atLeast(num) {\n          if (typeof num !== \"number\") {\n              throw new TypeError(`'${valueToString(num)}' is not number`);\n          }\n\n          if (!this.limitsSet) {\n              this.maxCalls = null;\n              this.limitsSet = true;\n          }\n\n          this.minCalls = num;\n\n          return this;\n      },\n\n      atMost: function atMost(num) {\n          if (typeof num !== \"number\") {\n              throw new TypeError(`'${valueToString(num)}' is not number`);\n          }\n\n          if (!this.limitsSet) {\n              this.minCalls = null;\n              this.limitsSet = true;\n          }\n\n          this.maxCalls = num;\n\n          return this;\n      },\n\n      never: function never() {\n          return this.exactly(0);\n      },\n\n      once: function once() {\n          return this.exactly(1);\n      },\n\n      twice: function twice() {\n          return this.exactly(2);\n      },\n\n      thrice: function thrice() {\n          return this.exactly(3);\n      },\n\n      exactly: function exactly(num) {\n          if (typeof num !== \"number\") {\n              throw new TypeError(`'${valueToString(num)}' is not a number`);\n          }\n\n          this.atLeast(num);\n          return this.atMost(num);\n      },\n\n      met: function met() {\n          return !this.failed && receivedMinCalls(this);\n      },\n\n      verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n          const expectedArguments = this.expectedArguments;\n\n          if (receivedMaxCalls(this)) {\n              this.failed = true;\n              mockExpectation.fail(\n                  `${this.method} already called ${timesInWords(this.maxCalls)}`,\n              );\n          }\n\n          if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n              mockExpectation.fail(\n                  `${this.method} called with ${valueToString(\n                    thisValue,\n                )} as thisValue, expected ${valueToString(this.expectedThis)}`,\n              );\n          }\n\n          if (!(\"expectedArguments\" in this)) {\n              return;\n          }\n\n          if (!args) {\n              mockExpectation.fail(\n                  `${this.method} received no arguments, expected ${inspect(\n                    expectedArguments,\n                )}`,\n              );\n          }\n\n          if (args.length < expectedArguments.length) {\n              mockExpectation.fail(\n                  `${this.method} received too few arguments (${inspect(\n                    args,\n                )}), expected ${inspect(expectedArguments)}`,\n              );\n          }\n\n          if (\n              this.expectsExactArgCount &&\n              args.length !== expectedArguments.length\n          ) {\n              mockExpectation.fail(\n                  `${this.method} received too many arguments (${inspect(\n                    args,\n                )}), expected ${inspect(expectedArguments)}`,\n              );\n          }\n\n          forEach(\n              expectedArguments,\n              function (expectedArgument, i) {\n                  if (!verifyMatcher(expectedArgument, args[i])) ;\n\n                  if (!deepEqual(args[i], expectedArgument)) {\n                      mockExpectation.fail(\n                          `${this.method} received wrong arguments ${inspect(\n                            args,\n                        )}, expected ${inspect(expectedArguments)}`,\n                      );\n                  }\n              },\n              this,\n          );\n      },\n\n      allowsCall: function allowsCall(thisValue, args) {\n          const expectedArguments = this.expectedArguments;\n\n          if (this.met() && receivedMaxCalls(this)) {\n              return false;\n          }\n\n          if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n              return false;\n          }\n\n          if (!(\"expectedArguments\" in this)) {\n              return true;\n          }\n\n          // eslint-disable-next-line no-underscore-dangle\n          const _args = args || [];\n\n          if (_args.length < expectedArguments.length) {\n              return false;\n          }\n\n          if (\n              this.expectsExactArgCount &&\n              _args.length !== expectedArguments.length\n          ) {\n              return false;\n          }\n\n          return every(expectedArguments, function (expectedArgument, i) {\n              if (!verifyMatcher(expectedArgument, _args[i])) ;\n\n              if (!deepEqual(_args[i], expectedArgument)) {\n                  return false;\n              }\n\n              return true;\n          });\n      },\n\n      withArgs: function withArgs() {\n          this.expectedArguments = slice(arguments);\n          return this;\n      },\n\n      withExactArgs: function withExactArgs() {\n          this.withArgs.apply(this, arguments);\n          this.expectsExactArgCount = true;\n          return this;\n      },\n\n      on: function on(thisValue) {\n          this.expectedThis = thisValue;\n          return this;\n      },\n\n      toString: function () {\n          const args = slice(this.expectedArguments || []);\n\n          if (!this.expectsExactArgCount) {\n              push(args, \"[...]\");\n          }\n\n          const callStr = proxyCallToString.call({\n              proxy: this.method || \"anonymous mock expectation\",\n              args: args,\n          });\n\n          const message = `${callStr.replace(\n            \", [...\",\n            \"[, ...\",\n        )} ${expectedCallCountInWords(this)}`;\n\n          if (this.met()) {\n              return `Expectation met: ${message}`;\n          }\n\n          return `Expected ${message} (${callCountInWords(this.callCount)})`;\n      },\n\n      verify: function verify() {\n          if (!this.met()) {\n              mockExpectation.fail(String(this));\n          } else {\n              mockExpectation.pass(String(this));\n          }\n\n          return true;\n      },\n\n      pass: function pass(message) {\n          assert.pass(message);\n      },\n\n      fail: function fail(message) {\n          const exception = new Error(message);\n          exception.name = \"ExpectationError\";\n\n          throw exception;\n      },\n  };\n\n  module.exports = mockExpectation;\n\n  },{\"./assert\":4,\"./proxy-call\":16,\"./proxy-invoke\":17,\"./stub\":23,\"./util/core/extend\":26,\"./util/core/times-in-words\":36,\"@sinonjs/commons\":47,\"@sinonjs/samsam\":87,\"util\":91}],13:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const mockExpectation = require(\"./mock-expectation\");\n  const proxyCallToString = require(\"./proxy-call\").toString;\n  const extend = require(\"./util/core/extend\");\n  const deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n  const wrapMethod = require(\"./util/core/wrap-method\");\n\n  const concat = arrayProto.concat;\n  const filter = arrayProto.filter;\n  const forEach = arrayProto.forEach;\n  const every = arrayProto.every;\n  const join = arrayProto.join;\n  const push = arrayProto.push;\n  const slice = arrayProto.slice;\n  const unshift = arrayProto.unshift;\n\n  function mock(object) {\n      if (!object || typeof object === \"string\") {\n          return mockExpectation.create(object ? object : \"Anonymous mock\");\n      }\n\n      return mock.create(object);\n  }\n\n  function each(collection, callback) {\n      const col = collection || [];\n\n      forEach(col, callback);\n  }\n\n  function arrayEquals(arr1, arr2, compareLength) {\n      if (compareLength && arr1.length !== arr2.length) {\n          return false;\n      }\n\n      return every(arr1, function (element, i) {\n          return deepEqual(arr2[i], element);\n      });\n  }\n\n  extend(mock, {\n      create: function create(object) {\n          if (!object) {\n              throw new TypeError(\"object is null\");\n          }\n\n          const mockObject = extend.nonEnum({}, mock, { object: object });\n          delete mockObject.create;\n\n          return mockObject;\n      },\n\n      expects: function expects(method) {\n          if (!method) {\n              throw new TypeError(\"method is falsy\");\n          }\n\n          if (!this.expectations) {\n              this.expectations = {};\n              this.proxies = [];\n              this.failures = [];\n          }\n\n          if (!this.expectations[method]) {\n              this.expectations[method] = [];\n              const mockObject = this;\n\n              wrapMethod(this.object, method, function () {\n                  return mockObject.invokeMethod(method, this, arguments);\n              });\n\n              push(this.proxies, method);\n          }\n\n          const expectation = mockExpectation.create(method);\n          expectation.wrappedMethod = this.object[method].wrappedMethod;\n          push(this.expectations[method], expectation);\n\n          return expectation;\n      },\n\n      restore: function restore() {\n          const object = this.object;\n\n          each(this.proxies, function (proxy) {\n              if (typeof object[proxy].restore === \"function\") {\n                  object[proxy].restore();\n              }\n          });\n      },\n\n      verify: function verify() {\n          const expectations = this.expectations || {};\n          const messages = this.failures ? slice(this.failures) : [];\n          const met = [];\n\n          each(this.proxies, function (proxy) {\n              each(expectations[proxy], function (expectation) {\n                  if (!expectation.met()) {\n                      push(messages, String(expectation));\n                  } else {\n                      push(met, String(expectation));\n                  }\n              });\n          });\n\n          this.restore();\n\n          if (messages.length > 0) {\n              mockExpectation.fail(join(concat(messages, met), \"\\n\"));\n          } else if (met.length > 0) {\n              mockExpectation.pass(join(concat(messages, met), \"\\n\"));\n          }\n\n          return true;\n      },\n\n      invokeMethod: function invokeMethod(method, thisValue, args) {\n          /* if we cannot find any matching files we will explicitly call mockExpection#fail with error messages */\n          /* eslint consistent-return: \"off\" */\n          const expectations =\n              this.expectations && this.expectations[method]\n                  ? this.expectations[method]\n                  : [];\n          const currentArgs = args || [];\n          let available;\n\n          const expectationsWithMatchingArgs = filter(\n              expectations,\n              function (expectation) {\n                  const expectedArgs = expectation.expectedArguments || [];\n\n                  return arrayEquals(\n                      expectedArgs,\n                      currentArgs,\n                      expectation.expectsExactArgCount,\n                  );\n              },\n          );\n\n          const expectationsToApply = filter(\n              expectationsWithMatchingArgs,\n              function (expectation) {\n                  return (\n                      !expectation.met() &&\n                      expectation.allowsCall(thisValue, args)\n                  );\n              },\n          );\n\n          if (expectationsToApply.length > 0) {\n              return expectationsToApply[0].apply(thisValue, args);\n          }\n\n          const messages = [];\n          let exhausted = 0;\n\n          forEach(expectationsWithMatchingArgs, function (expectation) {\n              if (expectation.allowsCall(thisValue, args)) {\n                  available = available || expectation;\n              } else {\n                  exhausted += 1;\n              }\n          });\n\n          if (available && exhausted === 0) {\n              return available.apply(thisValue, args);\n          }\n\n          forEach(expectations, function (expectation) {\n              push(messages, `    ${String(expectation)}`);\n          });\n\n          unshift(\n              messages,\n              `Unexpected call: ${proxyCallToString.call({\n                proxy: method,\n                args: args,\n            })}`,\n          );\n\n          const err = new Error();\n          if (!err.stack) {\n              // PhantomJS does not serialize the stack trace until the error has been thrown\n              try {\n                  throw err;\n              } catch (e) {\n                  /* empty */\n              }\n          }\n          push(\n              this.failures,\n              `Unexpected call: ${proxyCallToString.call({\n                proxy: method,\n                args: args,\n                stack: err.stack,\n            })}`,\n          );\n\n          mockExpectation.fail(join(messages, \"\\n\"));\n      },\n  });\n\n  module.exports = mock;\n\n  },{\"./mock-expectation\":12,\"./proxy-call\":16,\"./util/core/extend\":26,\"./util/core/wrap-method\":39,\"@sinonjs/commons\":47,\"@sinonjs/samsam\":87}],14:[function(require,module,exports){\n\n  const fake = require(\"./fake\");\n  const isRestorable = require(\"./util/core/is-restorable\");\n\n  const STATUS_PENDING = \"pending\";\n  const STATUS_RESOLVED = \"resolved\";\n  const STATUS_REJECTED = \"rejected\";\n\n  /**\n   * Returns a fake for a given function or undefined. If no function is given, a\n   * new fake is returned. If the given function is already a fake, it is\n   * returned as is. Otherwise the given function is wrapped in a new fake.\n   *\n   * @param {Function} [executor] The optional executor function.\n   * @returns {Function}\n   */\n  function getFakeExecutor(executor) {\n      if (isRestorable(executor)) {\n          return executor;\n      }\n      if (executor) {\n          return fake(executor);\n      }\n      return fake();\n  }\n\n  /**\n   * Returns a new promise that exposes it's internal `status`, `resolvedValue`\n   * and `rejectedValue` and can be resolved or rejected from the outside by\n   * calling `resolve(value)` or `reject(reason)`.\n   *\n   * @param {Function} [executor] The optional executor function.\n   * @returns {Promise}\n   */\n  function promise(executor) {\n      const fakeExecutor = getFakeExecutor(executor);\n      const sinonPromise = new Promise(fakeExecutor);\n\n      sinonPromise.status = STATUS_PENDING;\n      sinonPromise\n          .then(function (value) {\n              sinonPromise.status = STATUS_RESOLVED;\n              sinonPromise.resolvedValue = value;\n          })\n          .catch(function (reason) {\n              sinonPromise.status = STATUS_REJECTED;\n              sinonPromise.rejectedValue = reason;\n          });\n\n      /**\n       * Resolves or rejects the promise with the given status and value.\n       *\n       * @param {string} status\n       * @param {*} value\n       * @param {Function} callback\n       */\n      function finalize(status, value, callback) {\n          if (sinonPromise.status !== STATUS_PENDING) {\n              throw new Error(`Promise already ${sinonPromise.status}`);\n          }\n\n          sinonPromise.status = status;\n          callback(value);\n      }\n\n      sinonPromise.resolve = function (value) {\n          finalize(STATUS_RESOLVED, value, fakeExecutor.firstCall.args[0]);\n          // Return the promise so that callers can await it:\n          return sinonPromise;\n      };\n      sinonPromise.reject = function (reason) {\n          finalize(STATUS_REJECTED, reason, fakeExecutor.firstCall.args[1]);\n          // Return a new promise that resolves when the sinon promise was\n          // rejected, so that callers can await it:\n          return new Promise(function (resolve) {\n              sinonPromise.catch(() => resolve());\n          });\n      };\n\n      return sinonPromise;\n  }\n\n  module.exports = promise;\n\n  },{\"./fake\":11,\"./util/core/is-restorable\":33}],15:[function(require,module,exports){\n\n  const push = require(\"@sinonjs/commons\").prototypes.array.push;\n\n  exports.incrementCallCount = function incrementCallCount(proxy) {\n      proxy.called = true;\n      proxy.callCount += 1;\n      proxy.notCalled = false;\n      proxy.calledOnce = proxy.callCount === 1;\n      proxy.calledTwice = proxy.callCount === 2;\n      proxy.calledThrice = proxy.callCount === 3;\n  };\n\n  exports.createCallProperties = function createCallProperties(proxy) {\n      proxy.firstCall = proxy.getCall(0);\n      proxy.secondCall = proxy.getCall(1);\n      proxy.thirdCall = proxy.getCall(2);\n      proxy.lastCall = proxy.getCall(proxy.callCount - 1);\n  };\n\n  exports.delegateToCalls = function delegateToCalls(\n      proxy,\n      method,\n      matchAny,\n      actual,\n      returnsValues,\n      notCalled,\n      totalCallCount,\n  ) {\n      proxy[method] = function () {\n          if (!this.called) {\n              if (notCalled) {\n                  return notCalled.apply(this, arguments);\n              }\n              return false;\n          }\n\n          if (totalCallCount !== undefined && this.callCount !== totalCallCount) {\n              return false;\n          }\n\n          let currentCall;\n          let matches = 0;\n          const returnValues = [];\n\n          for (let i = 0, l = this.callCount; i < l; i += 1) {\n              currentCall = this.getCall(i);\n              const returnValue = currentCall[actual || method].apply(\n                  currentCall,\n                  arguments,\n              );\n              push(returnValues, returnValue);\n              if (returnValue) {\n                  matches += 1;\n\n                  if (matchAny) {\n                      return true;\n                  }\n              }\n          }\n\n          if (returnsValues) {\n              return returnValues;\n          }\n          return matches === this.callCount;\n      };\n  };\n\n  },{\"@sinonjs/commons\":47}],16:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const match = require(\"@sinonjs/samsam\").createMatcher;\n  const deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n  const functionName = require(\"@sinonjs/commons\").functionName;\n  const inspect = require(\"util\").inspect;\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  const concat = arrayProto.concat;\n  const filter = arrayProto.filter;\n  const join = arrayProto.join;\n  const map = arrayProto.map;\n  const reduce = arrayProto.reduce;\n  const slice = arrayProto.slice;\n\n  /**\n   * @param proxy\n   * @param text\n   * @param args\n   */\n  function throwYieldError(proxy, text, args) {\n      let msg = functionName(proxy) + text;\n      if (args.length) {\n          msg += ` Received [${join(slice(args), \", \")}]`;\n      }\n      throw new Error(msg);\n  }\n\n  const callProto = {\n      calledOn: function calledOn(thisValue) {\n          if (match.isMatcher(thisValue)) {\n              return thisValue.test(this.thisValue);\n          }\n          return this.thisValue === thisValue;\n      },\n\n      calledWith: function calledWith() {\n          const self = this;\n          const calledWithArgs = slice(arguments);\n\n          if (calledWithArgs.length > self.args.length) {\n              return false;\n          }\n\n          return reduce(\n              calledWithArgs,\n              function (prev, arg, i) {\n                  return prev && deepEqual(self.args[i], arg);\n              },\n              true,\n          );\n      },\n\n      calledWithMatch: function calledWithMatch() {\n          const self = this;\n          const calledWithMatchArgs = slice(arguments);\n\n          if (calledWithMatchArgs.length > self.args.length) {\n              return false;\n          }\n\n          return reduce(\n              calledWithMatchArgs,\n              function (prev, expectation, i) {\n                  const actual = self.args[i];\n\n                  return prev && match(expectation).test(actual);\n              },\n              true,\n          );\n      },\n\n      calledWithExactly: function calledWithExactly() {\n          return (\n              arguments.length === this.args.length &&\n              this.calledWith.apply(this, arguments)\n          );\n      },\n\n      notCalledWith: function notCalledWith() {\n          return !this.calledWith.apply(this, arguments);\n      },\n\n      notCalledWithMatch: function notCalledWithMatch() {\n          return !this.calledWithMatch.apply(this, arguments);\n      },\n\n      returned: function returned(value) {\n          return deepEqual(this.returnValue, value);\n      },\n\n      threw: function threw(error) {\n          if (typeof error === \"undefined\" || !this.exception) {\n              return Boolean(this.exception);\n          }\n\n          return this.exception === error || this.exception.name === error;\n      },\n\n      calledWithNew: function calledWithNew() {\n          return this.proxy.prototype && this.thisValue instanceof this.proxy;\n      },\n\n      calledBefore: function (other) {\n          return this.callId < other.callId;\n      },\n\n      calledAfter: function (other) {\n          return this.callId > other.callId;\n      },\n\n      calledImmediatelyBefore: function (other) {\n          return this.callId === other.callId - 1;\n      },\n\n      calledImmediatelyAfter: function (other) {\n          return this.callId === other.callId + 1;\n      },\n\n      callArg: function (pos) {\n          this.ensureArgIsAFunction(pos);\n          return this.args[pos]();\n      },\n\n      callArgOn: function (pos, thisValue) {\n          this.ensureArgIsAFunction(pos);\n          return this.args[pos].apply(thisValue);\n      },\n\n      callArgWith: function (pos) {\n          return this.callArgOnWith.apply(\n              this,\n              concat([pos, null], slice(arguments, 1)),\n          );\n      },\n\n      callArgOnWith: function (pos, thisValue) {\n          this.ensureArgIsAFunction(pos);\n          const args = slice(arguments, 2);\n          return this.args[pos].apply(thisValue, args);\n      },\n\n      throwArg: function (pos) {\n          if (pos > this.args.length) {\n              throw new TypeError(\n                  `Not enough arguments: ${pos} required but only ${this.args.length} present`,\n              );\n          }\n\n          throw this.args[pos];\n      },\n\n      yield: function () {\n          return this.yieldOn.apply(this, concat([null], slice(arguments, 0)));\n      },\n\n      yieldOn: function (thisValue) {\n          const args = slice(this.args);\n          const yieldFn = filter(args, function (arg) {\n              return typeof arg === \"function\";\n          })[0];\n\n          if (!yieldFn) {\n              throwYieldError(\n                  this.proxy,\n                  \" cannot yield since no callback was passed.\",\n                  args,\n              );\n          }\n\n          return yieldFn.apply(thisValue, slice(arguments, 1));\n      },\n\n      yieldTo: function (prop) {\n          return this.yieldToOn.apply(\n              this,\n              concat([prop, null], slice(arguments, 1)),\n          );\n      },\n\n      yieldToOn: function (prop, thisValue) {\n          const args = slice(this.args);\n          const yieldArg = filter(args, function (arg) {\n              return arg && typeof arg[prop] === \"function\";\n          })[0];\n          const yieldFn = yieldArg && yieldArg[prop];\n\n          if (!yieldFn) {\n              throwYieldError(\n                  this.proxy,\n                  ` cannot yield to '${valueToString(\n                    prop,\n                )}' since no callback was passed.`,\n                  args,\n              );\n          }\n\n          return yieldFn.apply(thisValue, slice(arguments, 2));\n      },\n\n      toString: function () {\n          if (!this.args) {\n              return \":(\";\n          }\n\n          let callStr = this.proxy ? `${String(this.proxy)}(` : \"\";\n          const formattedArgs = map(this.args, function (arg) {\n              return inspect(arg);\n          });\n\n          callStr = `${callStr + join(formattedArgs, \", \")})`;\n\n          if (typeof this.returnValue !== \"undefined\") {\n              callStr += ` => ${inspect(this.returnValue)}`;\n          }\n\n          if (this.exception) {\n              callStr += ` !${this.exception.name}`;\n\n              if (this.exception.message) {\n                  callStr += `(${this.exception.message})`;\n              }\n          }\n          if (this.stack) {\n              // If we have a stack, add the first frame that's in end-user code\n              // Skip the first two frames because they will refer to Sinon code\n              callStr += (this.stack.split(\"\\n\")[3] || \"unknown\").replace(\n                  /^\\s*(?:at\\s+|@)?/,\n                  \" at \",\n              );\n          }\n\n          return callStr;\n      },\n\n      ensureArgIsAFunction: function (pos) {\n          if (typeof this.args[pos] !== \"function\") {\n              throw new TypeError(\n                  `Expected argument at position ${pos} to be a Function, but was ${typeof this\n                    .args[pos]}`,\n              );\n          }\n      },\n  };\n  Object.defineProperty(callProto, \"stack\", {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n          return (this.errorWithCallStack && this.errorWithCallStack.stack) || \"\";\n      },\n  });\n\n  callProto.invokeCallback = callProto.yield;\n\n  /**\n   * @param proxy\n   * @param thisValue\n   * @param args\n   * @param returnValue\n   * @param exception\n   * @param id\n   * @param errorWithCallStack\n   *\n   * @returns {object} proxyCall\n   */\n  function createProxyCall(\n      proxy,\n      thisValue,\n      args,\n      returnValue,\n      exception,\n      id,\n      errorWithCallStack,\n  ) {\n      if (typeof id !== \"number\") {\n          throw new TypeError(\"Call id is not a number\");\n      }\n\n      let firstArg, lastArg;\n\n      if (args.length > 0) {\n          firstArg = args[0];\n          lastArg = args[args.length - 1];\n      }\n\n      const proxyCall = Object.create(callProto);\n      const callback =\n          lastArg && typeof lastArg === \"function\" ? lastArg : undefined;\n\n      proxyCall.proxy = proxy;\n      proxyCall.thisValue = thisValue;\n      proxyCall.args = args;\n      proxyCall.firstArg = firstArg;\n      proxyCall.lastArg = lastArg;\n      proxyCall.callback = callback;\n      proxyCall.returnValue = returnValue;\n      proxyCall.exception = exception;\n      proxyCall.callId = id;\n      proxyCall.errorWithCallStack = errorWithCallStack;\n\n      return proxyCall;\n  }\n  createProxyCall.toString = callProto.toString; // used by mocks\n\n  module.exports = createProxyCall;\n\n  },{\"@sinonjs/commons\":47,\"@sinonjs/samsam\":87,\"util\":91}],17:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const proxyCallUtil = require(\"./proxy-call-util\");\n\n  const push = arrayProto.push;\n  const forEach = arrayProto.forEach;\n  const concat = arrayProto.concat;\n  const ErrorConstructor = Error.prototype.constructor;\n  const bind = Function.prototype.bind;\n\n  let callId = 0;\n\n  module.exports = function invoke(func, thisValue, args) {\n      const matchings = this.matchingFakes(args);\n      const currentCallId = callId++;\n      let exception, returnValue;\n\n      proxyCallUtil.incrementCallCount(this);\n      push(this.thisValues, thisValue);\n      push(this.args, args);\n      push(this.callIds, currentCallId);\n      forEach(matchings, function (matching) {\n          proxyCallUtil.incrementCallCount(matching);\n          push(matching.thisValues, thisValue);\n          push(matching.args, args);\n          push(matching.callIds, currentCallId);\n      });\n\n      // Make call properties available from within the spied function:\n      proxyCallUtil.createCallProperties(this);\n      forEach(matchings, proxyCallUtil.createCallProperties);\n\n      try {\n          this.invoking = true;\n\n          const thisCall = this.getCall(this.callCount - 1);\n\n          if (thisCall.calledWithNew()) {\n              // Call through with `new`\n              returnValue = new (bind.apply(\n                  this.func || func,\n                  concat([thisValue], args),\n              ))();\n\n              if (\n                  typeof returnValue !== \"object\" &&\n                  typeof returnValue !== \"function\"\n              ) {\n                  returnValue = thisValue;\n              }\n          } else {\n              returnValue = (this.func || func).apply(thisValue, args);\n          }\n      } catch (e) {\n          exception = e;\n      } finally {\n          delete this.invoking;\n      }\n\n      push(this.exceptions, exception);\n      push(this.returnValues, returnValue);\n      forEach(matchings, function (matching) {\n          push(matching.exceptions, exception);\n          push(matching.returnValues, returnValue);\n      });\n\n      const err = new ErrorConstructor();\n      // 1. Please do not get stack at this point. It may be so very slow, and not actually used\n      // 2. PhantomJS does not serialize the stack trace until the error has been thrown:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack\n      try {\n          throw err;\n      } catch (e) {\n          /* empty */\n      }\n      push(this.errorsWithCallStack, err);\n      forEach(matchings, function (matching) {\n          push(matching.errorsWithCallStack, err);\n      });\n\n      // Make return value and exception available in the calls:\n      proxyCallUtil.createCallProperties(this);\n      forEach(matchings, proxyCallUtil.createCallProperties);\n\n      if (exception !== undefined) {\n          throw exception;\n      }\n\n      return returnValue;\n  };\n\n  },{\"./proxy-call-util\":15,\"@sinonjs/commons\":47}],18:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const extend = require(\"./util/core/extend\");\n  const functionToString = require(\"./util/core/function-to-string\");\n  const proxyCall = require(\"./proxy-call\");\n  const proxyCallUtil = require(\"./proxy-call-util\");\n  const proxyInvoke = require(\"./proxy-invoke\");\n  const inspect = require(\"util\").inspect;\n\n  const push = arrayProto.push;\n  const forEach = arrayProto.forEach;\n  const slice = arrayProto.slice;\n\n  const emptyFakes = Object.freeze([]);\n\n  // Public API\n  const proxyApi = {\n      toString: functionToString,\n\n      named: function named(name) {\n          this.displayName = name;\n          const nameDescriptor = Object.getOwnPropertyDescriptor(this, \"name\");\n          if (nameDescriptor && nameDescriptor.configurable) {\n              // IE 11 functions don't have a name.\n              // Safari 9 has names that are not configurable.\n              nameDescriptor.value = name;\n              Object.defineProperty(this, \"name\", nameDescriptor);\n          }\n          return this;\n      },\n\n      invoke: proxyInvoke,\n\n      /*\n       * Hook for derived implementation to return fake instances matching the\n       * given arguments.\n       */\n      matchingFakes: function (/*args, strict*/) {\n          return emptyFakes;\n      },\n\n      getCall: function getCall(index) {\n          let i = index;\n          if (i < 0) {\n              // Negative indices means counting backwards from the last call\n              i += this.callCount;\n          }\n          if (i < 0 || i >= this.callCount) {\n              return null;\n          }\n\n          return proxyCall(\n              this,\n              this.thisValues[i],\n              this.args[i],\n              this.returnValues[i],\n              this.exceptions[i],\n              this.callIds[i],\n              this.errorsWithCallStack[i],\n          );\n      },\n\n      getCalls: function () {\n          const calls = [];\n          let i;\n\n          for (i = 0; i < this.callCount; i++) {\n              push(calls, this.getCall(i));\n          }\n\n          return calls;\n      },\n\n      calledBefore: function calledBefore(proxy) {\n          if (!this.called) {\n              return false;\n          }\n\n          if (!proxy.called) {\n              return true;\n          }\n\n          return this.callIds[0] < proxy.callIds[proxy.callIds.length - 1];\n      },\n\n      calledAfter: function calledAfter(proxy) {\n          if (!this.called || !proxy.called) {\n              return false;\n          }\n\n          return this.callIds[this.callCount - 1] > proxy.callIds[0];\n      },\n\n      calledImmediatelyBefore: function calledImmediatelyBefore(proxy) {\n          if (!this.called || !proxy.called) {\n              return false;\n          }\n\n          return (\n              this.callIds[this.callCount - 1] ===\n              proxy.callIds[proxy.callCount - 1] - 1\n          );\n      },\n\n      calledImmediatelyAfter: function calledImmediatelyAfter(proxy) {\n          if (!this.called || !proxy.called) {\n              return false;\n          }\n\n          return (\n              this.callIds[this.callCount - 1] ===\n              proxy.callIds[proxy.callCount - 1] + 1\n          );\n      },\n\n      formatters: require(\"./spy-formatters\"),\n      printf: function (format) {\n          const spyInstance = this;\n          const args = slice(arguments, 1);\n          let formatter;\n\n          return (format || \"\").replace(/%(.)/g, function (match, specifier) {\n              formatter = proxyApi.formatters[specifier];\n\n              if (typeof formatter === \"function\") {\n                  return String(formatter(spyInstance, args));\n              } else if (!isNaN(parseInt(specifier, 10))) {\n                  return inspect(args[specifier - 1]);\n              }\n\n              return `%${specifier}`;\n          });\n      },\n\n      resetHistory: function () {\n          if (this.invoking) {\n              const err = new Error(\n                  \"Cannot reset Sinon function while invoking it. \" +\n                      \"Move the call to .resetHistory outside of the callback.\",\n              );\n              err.name = \"InvalidResetException\";\n              throw err;\n          }\n\n          this.called = false;\n          this.notCalled = true;\n          this.calledOnce = false;\n          this.calledTwice = false;\n          this.calledThrice = false;\n          this.callCount = 0;\n          this.firstCall = null;\n          this.secondCall = null;\n          this.thirdCall = null;\n          this.lastCall = null;\n          this.args = [];\n          this.firstArg = null;\n          this.lastArg = null;\n          this.returnValues = [];\n          this.thisValues = [];\n          this.exceptions = [];\n          this.callIds = [];\n          this.errorsWithCallStack = [];\n\n          if (this.fakes) {\n              forEach(this.fakes, function (fake) {\n                  fake.resetHistory();\n              });\n          }\n\n          return this;\n      },\n  };\n\n  const delegateToCalls = proxyCallUtil.delegateToCalls;\n  delegateToCalls(proxyApi, \"calledOn\", true);\n  delegateToCalls(proxyApi, \"alwaysCalledOn\", false, \"calledOn\");\n  delegateToCalls(proxyApi, \"calledWith\", true);\n  delegateToCalls(\n      proxyApi,\n      \"calledOnceWith\",\n      true,\n      \"calledWith\",\n      false,\n      undefined,\n      1,\n  );\n  delegateToCalls(proxyApi, \"calledWithMatch\", true);\n  delegateToCalls(proxyApi, \"alwaysCalledWith\", false, \"calledWith\");\n  delegateToCalls(proxyApi, \"alwaysCalledWithMatch\", false, \"calledWithMatch\");\n  delegateToCalls(proxyApi, \"calledWithExactly\", true);\n  delegateToCalls(\n      proxyApi,\n      \"calledOnceWithExactly\",\n      true,\n      \"calledWithExactly\",\n      false,\n      undefined,\n      1,\n  );\n  delegateToCalls(\n      proxyApi,\n      \"calledOnceWithMatch\",\n      true,\n      \"calledWithMatch\",\n      false,\n      undefined,\n      1,\n  );\n  delegateToCalls(\n      proxyApi,\n      \"alwaysCalledWithExactly\",\n      false,\n      \"calledWithExactly\",\n  );\n  delegateToCalls(\n      proxyApi,\n      \"neverCalledWith\",\n      false,\n      \"notCalledWith\",\n      false,\n      function () {\n          return true;\n      },\n  );\n  delegateToCalls(\n      proxyApi,\n      \"neverCalledWithMatch\",\n      false,\n      \"notCalledWithMatch\",\n      false,\n      function () {\n          return true;\n      },\n  );\n  delegateToCalls(proxyApi, \"threw\", true);\n  delegateToCalls(proxyApi, \"alwaysThrew\", false, \"threw\");\n  delegateToCalls(proxyApi, \"returned\", true);\n  delegateToCalls(proxyApi, \"alwaysReturned\", false, \"returned\");\n  delegateToCalls(proxyApi, \"calledWithNew\", true);\n  delegateToCalls(proxyApi, \"alwaysCalledWithNew\", false, \"calledWithNew\");\n\n  function createProxy(func, originalFunc) {\n      const proxy = wrapFunction(func, originalFunc);\n\n      // Inherit function properties:\n      extend(proxy, func);\n\n      proxy.prototype = func.prototype;\n\n      extend.nonEnum(proxy, proxyApi);\n\n      return proxy;\n  }\n\n  function wrapFunction(func, originalFunc) {\n      const arity = originalFunc.length;\n      let p;\n      // Do not change this to use an eval. Projects that depend on sinon block the use of eval.\n      // ref: https://github.com/sinonjs/sinon/issues/710\n      switch (arity) {\n          /*eslint-disable no-unused-vars, max-len*/\n          case 0:\n              p = function proxy() {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 1:\n              p = function proxy(a) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 2:\n              p = function proxy(a, b) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 3:\n              p = function proxy(a, b, c) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 4:\n              p = function proxy(a, b, c, d) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 5:\n              p = function proxy(a, b, c, d, e) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 6:\n              p = function proxy(a, b, c, d, e, f) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 7:\n              p = function proxy(a, b, c, d, e, f, g) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 8:\n              p = function proxy(a, b, c, d, e, f, g, h) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 9:\n              p = function proxy(a, b, c, d, e, f, g, h, i) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 10:\n              p = function proxy(a, b, c, d, e, f, g, h, i, j) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 11:\n              p = function proxy(a, b, c, d, e, f, g, h, i, j, k) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          case 12:\n              p = function proxy(a, b, c, d, e, f, g, h, i, j, k, l) {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          default:\n              p = function proxy() {\n                  return p.invoke(func, this, slice(arguments));\n              };\n              break;\n          /*eslint-enable*/\n      }\n      const nameDescriptor = Object.getOwnPropertyDescriptor(\n          originalFunc,\n          \"name\",\n      );\n      if (nameDescriptor && nameDescriptor.configurable) {\n          // IE 11 functions don't have a name.\n          // Safari 9 has names that are not configurable.\n          Object.defineProperty(p, \"name\", nameDescriptor);\n      }\n      extend.nonEnum(p, {\n          isSinonProxy: true,\n\n          called: false,\n          notCalled: true,\n          calledOnce: false,\n          calledTwice: false,\n          calledThrice: false,\n          callCount: 0,\n          firstCall: null,\n          firstArg: null,\n          secondCall: null,\n          thirdCall: null,\n          lastCall: null,\n          lastArg: null,\n          args: [],\n          returnValues: [],\n          thisValues: [],\n          exceptions: [],\n          callIds: [],\n          errorsWithCallStack: [],\n      });\n      return p;\n  }\n\n  module.exports = createProxy;\n\n  },{\"./proxy-call\":16,\"./proxy-call-util\":15,\"./proxy-invoke\":17,\"./spy-formatters\":21,\"./util/core/extend\":26,\"./util/core/function-to-string\":27,\"@sinonjs/commons\":47,\"util\":91}],19:[function(require,module,exports){\n\n  const walkObject = require(\"./util/core/walk-object\");\n\n  function filter(object, property) {\n      return object[property].restore && object[property].restore.sinon;\n  }\n\n  function restore(object, property) {\n      object[property].restore();\n  }\n\n  function restoreObject(object) {\n      return walkObject(restore, object, filter);\n  }\n\n  module.exports = restoreObject;\n\n  },{\"./util/core/walk-object\":37}],20:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const logger = require(\"@sinonjs/commons\").deprecated;\n  const collectOwnMethods = require(\"./collect-own-methods\");\n  const getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n  const isPropertyConfigurable = require(\"./util/core/is-property-configurable\");\n  const match = require(\"@sinonjs/samsam\").createMatcher;\n  const sinonAssert = require(\"./assert\");\n  const sinonClock = require(\"./util/fake-timers\");\n  const sinonMock = require(\"./mock\");\n  const sinonSpy = require(\"./spy\");\n  const sinonStub = require(\"./stub\");\n  const sinonCreateStubInstance = require(\"./create-stub-instance\");\n  const sinonFake = require(\"./fake\");\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  const DEFAULT_LEAK_THRESHOLD = 10000;\n\n  const filter = arrayProto.filter;\n  const forEach = arrayProto.forEach;\n  const push = arrayProto.push;\n  const reverse = arrayProto.reverse;\n\n  function applyOnEach(fakes, method) {\n      const matchingFakes = filter(fakes, function (fake) {\n          return typeof fake[method] === \"function\";\n      });\n\n      forEach(matchingFakes, function (fake) {\n          fake[method]();\n      });\n  }\n\n  function throwOnAccessors(descriptor) {\n      if (typeof descriptor.get === \"function\") {\n          throw new Error(\"Use sandbox.replaceGetter for replacing getters\");\n      }\n\n      if (typeof descriptor.set === \"function\") {\n          throw new Error(\"Use sandbox.replaceSetter for replacing setters\");\n      }\n  }\n\n  function verifySameType(object, property, replacement) {\n      if (typeof object[property] !== typeof replacement) {\n          throw new TypeError(\n              `Cannot replace ${typeof object[\n                property\n            ]} with ${typeof replacement}`,\n          );\n      }\n  }\n\n  function checkForValidArguments(descriptor, property, replacement) {\n      if (typeof descriptor === \"undefined\") {\n          throw new TypeError(\n              `Cannot replace non-existent property ${valueToString(\n                property,\n            )}. Perhaps you meant sandbox.define()?`,\n          );\n      }\n\n      if (typeof replacement === \"undefined\") {\n          throw new TypeError(\"Expected replacement argument to be defined\");\n      }\n  }\n\n  /**\n   * A sinon sandbox\n   *\n   * @param opts\n   * @param {object} [opts.assertOptions] see the CreateAssertOptions in ./assert\n   * @class\n   */\n  function Sandbox(opts = {}) {\n      const sandbox = this;\n      const assertOptions = opts.assertOptions || {};\n      let fakeRestorers = [];\n\n      let collection = [];\n      let loggedLeakWarning = false;\n      sandbox.leakThreshold = DEFAULT_LEAK_THRESHOLD;\n\n      function addToCollection(object) {\n          if (\n              push(collection, object) > sandbox.leakThreshold &&\n              !loggedLeakWarning\n          ) {\n              // eslint-disable-next-line no-console\n              logger.printWarning(\n                  \"Potential memory leak detected; be sure to call restore() to clean up your sandbox. To suppress this warning, modify the leakThreshold property of your sandbox.\",\n              );\n              loggedLeakWarning = true;\n          }\n      }\n\n      sandbox.assert = sinonAssert.createAssertObject(assertOptions);\n\n      // this is for testing only\n      sandbox.getFakes = function getFakes() {\n          return collection;\n      };\n\n      sandbox.createStubInstance = function createStubInstance() {\n          const stubbed = sinonCreateStubInstance.apply(null, arguments);\n\n          const ownMethods = collectOwnMethods(stubbed);\n\n          forEach(ownMethods, function (method) {\n              addToCollection(method);\n          });\n\n          return stubbed;\n      };\n\n      sandbox.inject = function inject(obj) {\n          obj.spy = function () {\n              return sandbox.spy.apply(null, arguments);\n          };\n\n          obj.stub = function () {\n              return sandbox.stub.apply(null, arguments);\n          };\n\n          obj.mock = function () {\n              return sandbox.mock.apply(null, arguments);\n          };\n\n          obj.createStubInstance = function () {\n              return sandbox.createStubInstance.apply(sandbox, arguments);\n          };\n\n          obj.fake = function () {\n              return sandbox.fake.apply(null, arguments);\n          };\n\n          obj.define = function () {\n              return sandbox.define.apply(null, arguments);\n          };\n\n          obj.replace = function () {\n              return sandbox.replace.apply(null, arguments);\n          };\n\n          obj.replaceSetter = function () {\n              return sandbox.replaceSetter.apply(null, arguments);\n          };\n\n          obj.replaceGetter = function () {\n              return sandbox.replaceGetter.apply(null, arguments);\n          };\n\n          if (sandbox.clock) {\n              obj.clock = sandbox.clock;\n          }\n\n          obj.match = match;\n\n          return obj;\n      };\n\n      sandbox.mock = function mock() {\n          const m = sinonMock.apply(null, arguments);\n\n          addToCollection(m);\n\n          return m;\n      };\n\n      sandbox.reset = function reset() {\n          applyOnEach(collection, \"reset\");\n          applyOnEach(collection, \"resetHistory\");\n      };\n\n      sandbox.resetBehavior = function resetBehavior() {\n          applyOnEach(collection, \"resetBehavior\");\n      };\n\n      sandbox.resetHistory = function resetHistory() {\n          function privateResetHistory(f) {\n              const method = f.resetHistory || f.reset;\n              if (method) {\n                  method.call(f);\n              }\n          }\n\n          forEach(collection, privateResetHistory);\n      };\n\n      sandbox.restore = function restore() {\n          if (arguments.length) {\n              throw new Error(\n                  \"sandbox.restore() does not take any parameters. Perhaps you meant stub.restore()\",\n              );\n          }\n\n          reverse(collection);\n          applyOnEach(collection, \"restore\");\n          collection = [];\n\n          forEach(fakeRestorers, function (restorer) {\n              restorer();\n          });\n          fakeRestorers = [];\n\n          sandbox.restoreContext();\n      };\n\n      sandbox.restoreContext = function restoreContext() {\n          if (!sandbox.injectedKeys) {\n              return;\n          }\n\n          forEach(sandbox.injectedKeys, function (injectedKey) {\n              delete sandbox.injectInto[injectedKey];\n          });\n\n          sandbox.injectedKeys.length = 0;\n      };\n\n      /**\n       * Creates a restorer function for the property\n       *\n       * @param {object|Function} object\n       * @param {string} property\n       * @param {boolean} forceAssignment\n       * @returns {Function} restorer function\n       */\n      function getFakeRestorer(object, property, forceAssignment = false) {\n          const descriptor = getPropertyDescriptor(object, property);\n          const value = forceAssignment && object[property];\n\n          function restorer() {\n              if (forceAssignment) {\n                  object[property] = value;\n              } else if (descriptor?.isOwn) {\n                  Object.defineProperty(object, property, descriptor);\n              } else {\n                  delete object[property];\n              }\n          }\n\n          restorer.object = object;\n          restorer.property = property;\n          return restorer;\n      }\n\n      function verifyNotReplaced(object, property) {\n          forEach(fakeRestorers, function (fakeRestorer) {\n              if (\n                  fakeRestorer.object === object &&\n                  fakeRestorer.property === property\n              ) {\n                  throw new TypeError(\n                      `Attempted to replace ${property} which is already replaced`,\n                  );\n              }\n          });\n      }\n\n      /**\n       * Replace an existing property\n       *\n       * @param {object|Function} object\n       * @param {string} property\n       * @param {*} replacement a fake, stub, spy or any other value\n       * @returns {*}\n       */\n      sandbox.replace = function replace(object, property, replacement) {\n          const descriptor = getPropertyDescriptor(object, property);\n          checkForValidArguments(descriptor, property, replacement);\n          throwOnAccessors(descriptor);\n          verifySameType(object, property, replacement);\n\n          verifyNotReplaced(object, property);\n\n          // store a function for restoring the replaced property\n          push(fakeRestorers, getFakeRestorer(object, property));\n\n          object[property] = replacement;\n\n          return replacement;\n      };\n\n      sandbox.replace.usingAccessor = function replaceUsingAccessor(\n          object,\n          property,\n          replacement,\n      ) {\n          const descriptor = getPropertyDescriptor(object, property);\n          checkForValidArguments(descriptor, property, replacement);\n          verifySameType(object, property, replacement);\n\n          verifyNotReplaced(object, property);\n\n          // store a function for restoring the replaced property\n          push(fakeRestorers, getFakeRestorer(object, property, true));\n\n          object[property] = replacement;\n\n          return replacement;\n      };\n\n      sandbox.define = function define(object, property, value) {\n          const descriptor = getPropertyDescriptor(object, property);\n\n          if (descriptor) {\n              throw new TypeError(\n                  `Cannot define the already existing property ${valueToString(\n                    property,\n                )}. Perhaps you meant sandbox.replace()?`,\n              );\n          }\n\n          if (typeof value === \"undefined\") {\n              throw new TypeError(\"Expected value argument to be defined\");\n          }\n\n          verifyNotReplaced(object, property);\n\n          // store a function for restoring the defined property\n          push(fakeRestorers, getFakeRestorer(object, property));\n\n          object[property] = value;\n\n          return value;\n      };\n\n      sandbox.replaceGetter = function replaceGetter(\n          object,\n          property,\n          replacement,\n      ) {\n          const descriptor = getPropertyDescriptor(object, property);\n\n          if (typeof descriptor === \"undefined\") {\n              throw new TypeError(\n                  `Cannot replace non-existent property ${valueToString(\n                    property,\n                )}`,\n              );\n          }\n\n          if (typeof replacement !== \"function\") {\n              throw new TypeError(\n                  \"Expected replacement argument to be a function\",\n              );\n          }\n\n          if (typeof descriptor.get !== \"function\") {\n              throw new Error(\"`object.property` is not a getter\");\n          }\n\n          verifyNotReplaced(object, property);\n\n          // store a function for restoring the replaced property\n          push(fakeRestorers, getFakeRestorer(object, property));\n\n          Object.defineProperty(object, property, {\n              get: replacement,\n              configurable: isPropertyConfigurable(object, property),\n          });\n\n          return replacement;\n      };\n\n      sandbox.replaceSetter = function replaceSetter(\n          object,\n          property,\n          replacement,\n      ) {\n          const descriptor = getPropertyDescriptor(object, property);\n\n          if (typeof descriptor === \"undefined\") {\n              throw new TypeError(\n                  `Cannot replace non-existent property ${valueToString(\n                    property,\n                )}`,\n              );\n          }\n\n          if (typeof replacement !== \"function\") {\n              throw new TypeError(\n                  \"Expected replacement argument to be a function\",\n              );\n          }\n\n          if (typeof descriptor.set !== \"function\") {\n              throw new Error(\"`object.property` is not a setter\");\n          }\n\n          verifyNotReplaced(object, property);\n\n          // store a function for restoring the replaced property\n          push(fakeRestorers, getFakeRestorer(object, property));\n\n          // eslint-disable-next-line accessor-pairs\n          Object.defineProperty(object, property, {\n              set: replacement,\n              configurable: isPropertyConfigurable(object, property),\n          });\n\n          return replacement;\n      };\n\n      function commonPostInitSetup(args, spy) {\n          const [object, property, types] = args;\n\n          const isSpyingOnEntireObject =\n              typeof property === \"undefined\" && typeof object === \"object\";\n\n          if (isSpyingOnEntireObject) {\n              const ownMethods = collectOwnMethods(spy);\n\n              forEach(ownMethods, function (method) {\n                  addToCollection(method);\n              });\n          } else if (Array.isArray(types)) {\n              for (const accessorType of types) {\n                  addToCollection(spy[accessorType]);\n              }\n          } else {\n              addToCollection(spy);\n          }\n\n          return spy;\n      }\n\n      sandbox.spy = function spy() {\n          const createdSpy = sinonSpy.apply(sinonSpy, arguments);\n          return commonPostInitSetup(arguments, createdSpy);\n      };\n\n      sandbox.stub = function stub() {\n          const createdStub = sinonStub.apply(sinonStub, arguments);\n          return commonPostInitSetup(arguments, createdStub);\n      };\n\n      // eslint-disable-next-line no-unused-vars\n      sandbox.fake = function fake(f) {\n          const s = sinonFake.apply(sinonFake, arguments);\n\n          addToCollection(s);\n\n          return s;\n      };\n\n      forEach(Object.keys(sinonFake), function (key) {\n          const fakeBehavior = sinonFake[key];\n          if (typeof fakeBehavior === \"function\") {\n              sandbox.fake[key] = function () {\n                  const s = fakeBehavior.apply(fakeBehavior, arguments);\n\n                  addToCollection(s);\n\n                  return s;\n              };\n          }\n      });\n\n      sandbox.useFakeTimers = function useFakeTimers(args) {\n          const clock = sinonClock.useFakeTimers.call(null, args);\n\n          sandbox.clock = clock;\n          addToCollection(clock);\n\n          return clock;\n      };\n\n      sandbox.verify = function verify() {\n          applyOnEach(collection, \"verify\");\n      };\n\n      sandbox.verifyAndRestore = function verifyAndRestore() {\n          let exception;\n\n          try {\n              sandbox.verify();\n          } catch (e) {\n              exception = e;\n          }\n\n          sandbox.restore();\n\n          if (exception) {\n              throw exception;\n          }\n      };\n  }\n\n  Sandbox.prototype.match = match;\n\n  module.exports = Sandbox;\n\n  },{\"./assert\":4,\"./collect-own-methods\":6,\"./create-stub-instance\":9,\"./fake\":11,\"./mock\":13,\"./spy\":22,\"./stub\":23,\"./util/core/get-property-descriptor\":29,\"./util/core/is-property-configurable\":32,\"./util/fake-timers\":40,\"@sinonjs/commons\":47,\"@sinonjs/samsam\":87}],21:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const Colorizer = require(\"./colorizer\");\n  const colororizer = new Colorizer();\n  const match = require(\"@sinonjs/samsam\").createMatcher;\n  const timesInWords = require(\"./util/core/times-in-words\");\n  const inspect = require(\"util\").inspect;\n  const jsDiff = require(\"diff\");\n\n  const join = arrayProto.join;\n  const map = arrayProto.map;\n  const push = arrayProto.push;\n  const slice = arrayProto.slice;\n\n  /**\n   *\n   * @param matcher\n   * @param calledArg\n   * @param calledArgMessage\n   *\n   * @returns {string} the colored text\n   */\n  function colorSinonMatchText(matcher, calledArg, calledArgMessage) {\n      let calledArgumentMessage = calledArgMessage;\n      let matcherMessage = matcher.message;\n      if (!matcher.test(calledArg)) {\n          matcherMessage = colororizer.red(matcher.message);\n          if (calledArgumentMessage) {\n              calledArgumentMessage = colororizer.green(calledArgumentMessage);\n          }\n      }\n      return `${calledArgumentMessage} ${matcherMessage}`;\n  }\n\n  /**\n   * @param diff\n   *\n   * @returns {string} the colored diff\n   */\n  function colorDiffText(diff) {\n      const objects = map(diff, function (part) {\n          let text = part.value;\n          if (part.added) {\n              text = colororizer.green(text);\n          } else if (part.removed) {\n              text = colororizer.red(text);\n          }\n          if (diff.length === 2) {\n              text += \" \"; // format simple diffs\n          }\n          return text;\n      });\n      return join(objects, \"\");\n  }\n\n  /**\n   *\n   * @param value\n   * @returns {string} a quoted string\n   */\n  function quoteStringValue(value) {\n      if (typeof value === \"string\") {\n          return JSON.stringify(value);\n      }\n      return value;\n  }\n\n  module.exports = {\n      c: function (spyInstance) {\n          return timesInWords(spyInstance.callCount);\n      },\n\n      n: function (spyInstance) {\n          // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n          return spyInstance.toString();\n      },\n\n      D: function (spyInstance, args) {\n          let message = \"\";\n\n          for (let i = 0, l = spyInstance.callCount; i < l; ++i) {\n              // describe multiple calls\n              if (l > 1) {\n                  message += `\\nCall ${i + 1}:`;\n              }\n              const calledArgs = spyInstance.getCall(i).args;\n              const expectedArgs = slice(args);\n\n              for (\n                  let j = 0;\n                  j < calledArgs.length || j < expectedArgs.length;\n                  ++j\n              ) {\n                  let calledArg = calledArgs[j];\n                  let expectedArg = expectedArgs[j];\n                  if (calledArg) {\n                      calledArg = quoteStringValue(calledArg);\n                  }\n\n                  if (expectedArg) {\n                      expectedArg = quoteStringValue(expectedArg);\n                  }\n\n                  message += \"\\n\";\n\n                  const calledArgMessage =\n                      j < calledArgs.length ? inspect(calledArg) : \"\";\n                  if (match.isMatcher(expectedArg)) {\n                      message += colorSinonMatchText(\n                          expectedArg,\n                          calledArg,\n                          calledArgMessage,\n                      );\n                  } else {\n                      const expectedArgMessage =\n                          j < expectedArgs.length ? inspect(expectedArg) : \"\";\n                      const diff = jsDiff.diffJson(\n                          calledArgMessage,\n                          expectedArgMessage,\n                      );\n                      message += colorDiffText(diff);\n                  }\n              }\n          }\n\n          return message;\n      },\n\n      C: function (spyInstance) {\n          const calls = [];\n\n          for (let i = 0, l = spyInstance.callCount; i < l; ++i) {\n              // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n              let stringifiedCall = `    ${spyInstance.getCall(i).toString()}`;\n              if (/\\n/.test(calls[i - 1])) {\n                  stringifiedCall = `\\n${stringifiedCall}`;\n              }\n              push(calls, stringifiedCall);\n          }\n\n          return calls.length > 0 ? `\\n${join(calls, \"\\n\")}` : \"\";\n      },\n\n      t: function (spyInstance) {\n          const objects = [];\n\n          for (let i = 0, l = spyInstance.callCount; i < l; ++i) {\n              push(objects, inspect(spyInstance.thisValues[i]));\n          }\n\n          return join(objects, \", \");\n      },\n\n      \"*\": function (spyInstance, args) {\n          return join(\n              map(args, function (arg) {\n                  return inspect(arg);\n              }),\n              \", \",\n          );\n      },\n  };\n\n  },{\"./colorizer\":7,\"./util/core/times-in-words\":36,\"@sinonjs/commons\":47,\"@sinonjs/samsam\":87,\"diff\":92,\"util\":91}],22:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const createProxy = require(\"./proxy\");\n  const extend = require(\"./util/core/extend\");\n  const functionName = require(\"@sinonjs/commons\").functionName;\n  const getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n  const deepEqual = require(\"@sinonjs/samsam\").deepEqual;\n  const isEsModule = require(\"./util/core/is-es-module\");\n  const proxyCallUtil = require(\"./proxy-call-util\");\n  const walkObject = require(\"./util/core/walk-object\");\n  const wrapMethod = require(\"./util/core/wrap-method\");\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  /* cache references to library methods so that they also can be stubbed without problems */\n  const forEach = arrayProto.forEach;\n  const pop = arrayProto.pop;\n  const push = arrayProto.push;\n  const slice = arrayProto.slice;\n  const filter = Array.prototype.filter;\n\n  let uuid = 0;\n\n  function matches(fake, args, strict) {\n      const margs = fake.matchingArguments;\n      if (\n          margs.length <= args.length &&\n          deepEqual(slice(args, 0, margs.length), margs)\n      ) {\n          return !strict || margs.length === args.length;\n      }\n      return false;\n  }\n\n  // Public API\n  const spyApi = {\n      withArgs: function () {\n          const args = slice(arguments);\n          const matching = pop(this.matchingFakes(args, true));\n          if (matching) {\n              return matching;\n          }\n\n          const original = this;\n          const fake = this.instantiateFake();\n          fake.matchingArguments = args;\n          fake.parent = this;\n          push(this.fakes, fake);\n\n          fake.withArgs = function () {\n              return original.withArgs.apply(original, arguments);\n          };\n\n          forEach(original.args, function (arg, i) {\n              if (!matches(fake, arg)) {\n                  return;\n              }\n\n              proxyCallUtil.incrementCallCount(fake);\n              push(fake.thisValues, original.thisValues[i]);\n              push(fake.args, arg);\n              push(fake.returnValues, original.returnValues[i]);\n              push(fake.exceptions, original.exceptions[i]);\n              push(fake.callIds, original.callIds[i]);\n          });\n\n          proxyCallUtil.createCallProperties(fake);\n\n          return fake;\n      },\n\n      // Override proxy default implementation\n      matchingFakes: function (args, strict) {\n          return filter.call(this.fakes, function (fake) {\n              return matches(fake, args, strict);\n          });\n      },\n  };\n\n  /* eslint-disable @sinonjs/no-prototype-methods/no-prototype-methods */\n  const delegateToCalls = proxyCallUtil.delegateToCalls;\n  delegateToCalls(spyApi, \"callArg\", false, \"callArgWith\", true, function () {\n      throw new Error(\n          `${this.toString()} cannot call arg since it was not yet invoked.`,\n      );\n  });\n  spyApi.callArgWith = spyApi.callArg;\n  delegateToCalls(spyApi, \"callArgOn\", false, \"callArgOnWith\", true, function () {\n      throw new Error(\n          `${this.toString()} cannot call arg since it was not yet invoked.`,\n      );\n  });\n  spyApi.callArgOnWith = spyApi.callArgOn;\n  delegateToCalls(spyApi, \"throwArg\", false, \"throwArg\", false, function () {\n      throw new Error(\n          `${this.toString()} cannot throw arg since it was not yet invoked.`,\n      );\n  });\n  delegateToCalls(spyApi, \"yield\", false, \"yield\", true, function () {\n      throw new Error(\n          `${this.toString()} cannot yield since it was not yet invoked.`,\n      );\n  });\n  // \"invokeCallback\" is an alias for \"yield\" since \"yield\" is invalid in strict mode.\n  spyApi.invokeCallback = spyApi.yield;\n  delegateToCalls(spyApi, \"yieldOn\", false, \"yieldOn\", true, function () {\n      throw new Error(\n          `${this.toString()} cannot yield since it was not yet invoked.`,\n      );\n  });\n  delegateToCalls(spyApi, \"yieldTo\", false, \"yieldTo\", true, function (property) {\n      throw new Error(\n          `${this.toString()} cannot yield to '${valueToString(\n            property,\n        )}' since it was not yet invoked.`,\n      );\n  });\n  delegateToCalls(\n      spyApi,\n      \"yieldToOn\",\n      false,\n      \"yieldToOn\",\n      true,\n      function (property) {\n          throw new Error(\n              `${this.toString()} cannot yield to '${valueToString(\n                property,\n            )}' since it was not yet invoked.`,\n          );\n      },\n  );\n\n  function createSpy(func) {\n      let name;\n      let funk = func;\n\n      if (typeof funk !== \"function\") {\n          funk = function () {\n              return;\n          };\n      } else {\n          name = functionName(funk);\n      }\n\n      const proxy = createProxy(funk, funk);\n\n      // Inherit spy API:\n      extend.nonEnum(proxy, spyApi);\n      extend.nonEnum(proxy, {\n          displayName: name || \"spy\",\n          fakes: [],\n          instantiateFake: createSpy,\n          id: `spy#${uuid++}`,\n      });\n      return proxy;\n  }\n\n  function spy(object, property, types) {\n      if (isEsModule(object)) {\n          throw new TypeError(\"ES Modules cannot be spied\");\n      }\n\n      if (!property && typeof object === \"function\") {\n          return createSpy(object);\n      }\n\n      if (!property && typeof object === \"object\") {\n          return walkObject(spy, object);\n      }\n\n      if (!object && !property) {\n          return createSpy(function () {\n              return;\n          });\n      }\n\n      if (!types) {\n          return wrapMethod(object, property, createSpy(object[property]));\n      }\n\n      const descriptor = {};\n      const methodDesc = getPropertyDescriptor(object, property);\n\n      forEach(types, function (type) {\n          descriptor[type] = createSpy(methodDesc[type]);\n      });\n\n      return wrapMethod(object, property, descriptor);\n  }\n\n  extend(spy, spyApi);\n  module.exports = spy;\n\n  },{\"./proxy\":18,\"./proxy-call-util\":15,\"./util/core/extend\":26,\"./util/core/get-property-descriptor\":29,\"./util/core/is-es-module\":30,\"./util/core/walk-object\":37,\"./util/core/wrap-method\":39,\"@sinonjs/commons\":47,\"@sinonjs/samsam\":87}],23:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const behavior = require(\"./behavior\");\n  const behaviors = require(\"./default-behaviors\");\n  const createProxy = require(\"./proxy\");\n  const functionName = require(\"@sinonjs/commons\").functionName;\n  const hasOwnProperty =\n      require(\"@sinonjs/commons\").prototypes.object.hasOwnProperty;\n  const isNonExistentProperty = require(\"./util/core/is-non-existent-property\");\n  const spy = require(\"./spy\");\n  const extend = require(\"./util/core/extend\");\n  const getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n  const isEsModule = require(\"./util/core/is-es-module\");\n  const sinonType = require(\"./util/core/sinon-type\");\n  const wrapMethod = require(\"./util/core/wrap-method\");\n  const throwOnFalsyObject = require(\"./throw-on-falsy-object\");\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n  const walkObject = require(\"./util/core/walk-object\");\n\n  const forEach = arrayProto.forEach;\n  const pop = arrayProto.pop;\n  const slice = arrayProto.slice;\n  const sort = arrayProto.sort;\n\n  let uuid = 0;\n\n  function createStub(originalFunc) {\n      // eslint-disable-next-line prefer-const\n      let proxy;\n\n      function functionStub() {\n          const args = slice(arguments);\n          const matchings = proxy.matchingFakes(args);\n\n          const fnStub =\n              pop(\n                  sort(matchings, function (a, b) {\n                      return (\n                          a.matchingArguments.length - b.matchingArguments.length\n                      );\n                  }),\n              ) || proxy;\n          return getCurrentBehavior(fnStub).invoke(this, arguments);\n      }\n\n      proxy = createProxy(functionStub, originalFunc || functionStub);\n      // Inherit spy API:\n      extend.nonEnum(proxy, spy);\n      // Inherit stub API:\n      extend.nonEnum(proxy, stub);\n\n      const name = originalFunc ? functionName(originalFunc) : null;\n      extend.nonEnum(proxy, {\n          fakes: [],\n          instantiateFake: createStub,\n          displayName: name || \"stub\",\n          defaultBehavior: null,\n          behaviors: [],\n          id: `stub#${uuid++}`,\n      });\n\n      sinonType.set(proxy, \"stub\");\n\n      return proxy;\n  }\n\n  function stub(object, property) {\n      if (arguments.length > 2) {\n          throw new TypeError(\n              \"stub(obj, 'meth', fn) has been removed, see documentation\",\n          );\n      }\n\n      if (isEsModule(object)) {\n          throw new TypeError(\"ES Modules cannot be stubbed\");\n      }\n\n      throwOnFalsyObject.apply(null, arguments);\n\n      if (isNonExistentProperty(object, property)) {\n          throw new TypeError(\n              `Cannot stub non-existent property ${valueToString(property)}`,\n          );\n      }\n\n      const actualDescriptor = getPropertyDescriptor(object, property);\n\n      assertValidPropertyDescriptor(actualDescriptor, property);\n\n      const isObjectOrFunction =\n          typeof object === \"object\" || typeof object === \"function\";\n      const isStubbingEntireObject =\n          typeof property === \"undefined\" && isObjectOrFunction;\n      const isCreatingNewStub = !object && typeof property === \"undefined\";\n      const isStubbingNonFuncProperty =\n          isObjectOrFunction &&\n          typeof property !== \"undefined\" &&\n          (typeof actualDescriptor === \"undefined\" ||\n              typeof actualDescriptor.value !== \"function\");\n\n      if (isStubbingEntireObject) {\n          return walkObject(stub, object);\n      }\n\n      if (isCreatingNewStub) {\n          return createStub();\n      }\n\n      const func =\n          typeof actualDescriptor.value === \"function\"\n              ? actualDescriptor.value\n              : null;\n      const s = createStub(func);\n\n      extend.nonEnum(s, {\n          rootObj: object,\n          propName: property,\n          shadowsPropOnPrototype: !actualDescriptor.isOwn,\n          restore: function restore() {\n              if (actualDescriptor !== undefined && actualDescriptor.isOwn) {\n                  Object.defineProperty(object, property, actualDescriptor);\n                  return;\n              }\n\n              delete object[property];\n          },\n      });\n\n      return isStubbingNonFuncProperty ? s : wrapMethod(object, property, s);\n  }\n\n  function assertValidPropertyDescriptor(descriptor, property) {\n      if (!descriptor || !property) {\n          return;\n      }\n      if (descriptor.isOwn && !descriptor.configurable && !descriptor.writable) {\n          throw new TypeError(\n              `Descriptor for property ${property} is non-configurable and non-writable`,\n          );\n      }\n      if ((descriptor.get || descriptor.set) && !descriptor.configurable) {\n          throw new TypeError(\n              `Descriptor for accessor property ${property} is non-configurable`,\n          );\n      }\n      if (isDataDescriptor(descriptor) && !descriptor.writable) {\n          throw new TypeError(\n              `Descriptor for data property ${property} is non-writable`,\n          );\n      }\n  }\n\n  function isDataDescriptor(descriptor) {\n      return (\n          !descriptor.value &&\n          !descriptor.writable &&\n          !descriptor.set &&\n          !descriptor.get\n      );\n  }\n\n  /*eslint-disable no-use-before-define*/\n  function getParentBehaviour(stubInstance) {\n      return stubInstance.parent && getCurrentBehavior(stubInstance.parent);\n  }\n\n  function getDefaultBehavior(stubInstance) {\n      return (\n          stubInstance.defaultBehavior ||\n          getParentBehaviour(stubInstance) ||\n          behavior.create(stubInstance)\n      );\n  }\n\n  function getCurrentBehavior(stubInstance) {\n      const currentBehavior = stubInstance.behaviors[stubInstance.callCount - 1];\n      return currentBehavior && currentBehavior.isPresent()\n          ? currentBehavior\n          : getDefaultBehavior(stubInstance);\n  }\n  /*eslint-enable no-use-before-define*/\n\n  const proto = {\n      resetBehavior: function () {\n          this.defaultBehavior = null;\n          this.behaviors = [];\n\n          delete this.returnValue;\n          delete this.returnArgAt;\n          delete this.throwArgAt;\n          delete this.resolveArgAt;\n          delete this.fakeFn;\n          this.returnThis = false;\n          this.resolveThis = false;\n\n          forEach(this.fakes, function (fake) {\n              fake.resetBehavior();\n          });\n      },\n\n      reset: function () {\n          this.resetHistory();\n          this.resetBehavior();\n      },\n\n      onCall: function onCall(index) {\n          if (!this.behaviors[index]) {\n              this.behaviors[index] = behavior.create(this);\n          }\n\n          return this.behaviors[index];\n      },\n\n      onFirstCall: function onFirstCall() {\n          return this.onCall(0);\n      },\n\n      onSecondCall: function onSecondCall() {\n          return this.onCall(1);\n      },\n\n      onThirdCall: function onThirdCall() {\n          return this.onCall(2);\n      },\n\n      withArgs: function withArgs() {\n          const fake = spy.withArgs.apply(this, arguments);\n          if (this.defaultBehavior && this.defaultBehavior.promiseLibrary) {\n              fake.defaultBehavior =\n                  fake.defaultBehavior || behavior.create(fake);\n              fake.defaultBehavior.promiseLibrary =\n                  this.defaultBehavior.promiseLibrary;\n          }\n          return fake;\n      },\n  };\n\n  forEach(Object.keys(behavior), function (method) {\n      if (\n          hasOwnProperty(behavior, method) &&\n          !hasOwnProperty(proto, method) &&\n          method !== \"create\" &&\n          method !== \"invoke\"\n      ) {\n          proto[method] = behavior.createBehavior(method);\n      }\n  });\n\n  forEach(Object.keys(behaviors), function (method) {\n      if (hasOwnProperty(behaviors, method) && !hasOwnProperty(proto, method)) {\n          behavior.addBehavior(stub, method, behaviors[method]);\n      }\n  });\n\n  extend(stub, proto);\n  module.exports = stub;\n\n  },{\"./behavior\":5,\"./default-behaviors\":10,\"./proxy\":18,\"./spy\":22,\"./throw-on-falsy-object\":24,\"./util/core/extend\":26,\"./util/core/get-property-descriptor\":29,\"./util/core/is-es-module\":30,\"./util/core/is-non-existent-property\":31,\"./util/core/sinon-type\":35,\"./util/core/walk-object\":37,\"./util/core/wrap-method\":39,\"@sinonjs/commons\":47}],24:[function(require,module,exports){\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  function throwOnFalsyObject(object, property) {\n      if (property && !object) {\n          const type = object === null ? \"null\" : \"undefined\";\n          throw new Error(\n              `Trying to stub property '${valueToString(property)}' of ${type}`,\n          );\n      }\n  }\n\n  module.exports = throwOnFalsyObject;\n\n  },{\"@sinonjs/commons\":47}],25:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const reduce = arrayProto.reduce;\n\n  module.exports = function exportAsyncBehaviors(behaviorMethods) {\n      return reduce(\n          Object.keys(behaviorMethods),\n          function (acc, method) {\n              // need to avoid creating another async versions of the newly added async methods\n              if (method.match(/^(callsArg|yields)/) && !method.match(/Async/)) {\n                  acc[`${method}Async`] = function () {\n                      const result = behaviorMethods[method].apply(\n                          this,\n                          arguments,\n                      );\n                      this.callbackAsync = true;\n                      return result;\n                  };\n              }\n              return acc;\n          },\n          {},\n      );\n  };\n\n  },{\"@sinonjs/commons\":47}],26:[function(require,module,exports){\n\n  const arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  const hasOwnProperty =\n      require(\"@sinonjs/commons\").prototypes.object.hasOwnProperty;\n\n  const join = arrayProto.join;\n  const push = arrayProto.push;\n\n  // Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n  const hasDontEnumBug = (function () {\n      const obj = {\n          constructor: function () {\n              return \"0\";\n          },\n          toString: function () {\n              return \"1\";\n          },\n          valueOf: function () {\n              return \"2\";\n          },\n          toLocaleString: function () {\n              return \"3\";\n          },\n          prototype: function () {\n              return \"4\";\n          },\n          isPrototypeOf: function () {\n              return \"5\";\n          },\n          propertyIsEnumerable: function () {\n              return \"6\";\n          },\n          hasOwnProperty: function () {\n              return \"7\";\n          },\n          length: function () {\n              return \"8\";\n          },\n          unique: function () {\n              return \"9\";\n          },\n      };\n\n      const result = [];\n      for (const prop in obj) {\n          if (hasOwnProperty(obj, prop)) {\n              push(result, obj[prop]());\n          }\n      }\n      return join(result, \"\") !== \"0123456789\";\n  })();\n\n  /**\n   *\n   * @param target\n   * @param sources\n   * @param doCopy\n   * @returns {*} target\n   */\n  function extendCommon(target, sources, doCopy) {\n      let source, i, prop;\n\n      for (i = 0; i < sources.length; i++) {\n          source = sources[i];\n\n          for (prop in source) {\n              if (hasOwnProperty(source, prop)) {\n                  doCopy(target, source, prop);\n              }\n          }\n\n          // Make sure we copy (own) toString method even when in JScript with DontEnum bug\n          // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n          if (\n              hasDontEnumBug &&\n              hasOwnProperty(source, \"toString\") &&\n              source.toString !== target.toString\n          ) {\n              target.toString = source.toString;\n          }\n      }\n\n      return target;\n  }\n\n  /**\n   * Public: Extend target in place with all (own) properties, except 'name' when [[writable]] is false,\n   *         from sources in-order. Thus, last source will override properties in previous sources.\n   *\n   * @param {object} target - The Object to extend\n   * @param {object[]} sources - Objects to copy properties from.\n   * @returns {object} the extended target\n   */\n  module.exports = function extend(target, ...sources) {\n      return extendCommon(\n          target,\n          sources,\n          function copyValue(dest, source, prop) {\n              const destOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(\n                  dest,\n                  prop,\n              );\n              const sourceOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(\n                  source,\n                  prop,\n              );\n\n              if (prop === \"name\" && !destOwnPropertyDescriptor.writable) {\n                  return;\n              }\n              const descriptors = {\n                  configurable: sourceOwnPropertyDescriptor.configurable,\n                  enumerable: sourceOwnPropertyDescriptor.enumerable,\n              };\n              /*\n                  if the source has an Accessor property copy over the accessor functions (get and set)\n                  data properties has writable attribute where as accessor property don't\n                  REF: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#properties\n              */\n\n              if (hasOwnProperty(sourceOwnPropertyDescriptor, \"writable\")) {\n                  descriptors.writable = sourceOwnPropertyDescriptor.writable;\n                  descriptors.value = sourceOwnPropertyDescriptor.value;\n              } else {\n                  if (sourceOwnPropertyDescriptor.get) {\n                      descriptors.get =\n                          sourceOwnPropertyDescriptor.get.bind(dest);\n                  }\n                  if (sourceOwnPropertyDescriptor.set) {\n                      descriptors.set =\n                          sourceOwnPropertyDescriptor.set.bind(dest);\n                  }\n              }\n              Object.defineProperty(dest, prop, descriptors);\n          },\n      );\n  };\n\n  /**\n   * Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will\n   *         override properties in previous sources. Define the properties as non enumerable.\n   *\n   * @param {object} target - The Object to extend\n   * @param {object[]} sources - Objects to copy properties from.\n   * @returns {object} the extended target\n   */\n  module.exports.nonEnum = function extendNonEnum(target, ...sources) {\n      return extendCommon(\n          target,\n          sources,\n          function copyProperty(dest, source, prop) {\n              Object.defineProperty(dest, prop, {\n                  value: source[prop],\n                  enumerable: false,\n                  configurable: true,\n                  writable: true,\n              });\n          },\n      );\n  };\n\n  },{\"@sinonjs/commons\":47}],27:[function(require,module,exports){\n\n  module.exports = function toString() {\n      let i, prop, thisValue;\n      if (this.getCall && this.callCount) {\n          i = this.callCount;\n\n          while (i--) {\n              thisValue = this.getCall(i).thisValue;\n\n              // eslint-disable-next-line guard-for-in\n              for (prop in thisValue) {\n                  try {\n                      if (thisValue[prop] === this) {\n                          return prop;\n                      }\n                  } catch (e) {\n                      // no-op - accessing props can throw an error, nothing to do here\n                  }\n              }\n          }\n      }\n\n      return this.displayName || \"sinon fake\";\n  };\n\n  },{}],28:[function(require,module,exports){\n\n  /* istanbul ignore next : not testing that setTimeout works */\n  function nextTick(callback) {\n      setTimeout(callback, 0);\n  }\n\n  module.exports = function getNextTick(process, setImmediate) {\n      if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n          return process.nextTick;\n      }\n\n      if (typeof setImmediate === \"function\") {\n          return setImmediate;\n      }\n\n      return nextTick;\n  };\n\n  },{}],29:[function(require,module,exports){\n\n  /**\n   * @typedef {object} PropertyDescriptor\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#description\n   * @property {boolean} configurable defaults to false\n   * @property {boolean} enumerable   defaults to false\n   * @property {boolean} writable     defaults to false\n   * @property {*} value defaults to undefined\n   * @property {Function} get defaults to undefined\n   * @property {Function} set defaults to undefined\n   */\n\n  /*\n   * The following type def is strictly speaking illegal in JSDoc, but the expression forms a\n   * legal Typescript union type and is understood by Visual Studio and the IntelliJ\n   * family of editors. The \"TS\" flavor of JSDoc is becoming the de-facto standard these\n   * days for that reason (and the fact that JSDoc is essentially unmaintained)\n   */\n\n  /**\n   * @typedef {{isOwn: boolean} & PropertyDescriptor} SinonPropertyDescriptor\n   * a slightly enriched property descriptor\n   * @property {boolean} isOwn true if the descriptor is owned by this object, false if it comes from the prototype\n   */\n\n  /**\n   * Returns a slightly modified property descriptor that one can tell is from the object or the prototype\n   *\n   * @param {*} object\n   * @param {string} property\n   * @returns {SinonPropertyDescriptor}\n   */\n  function getPropertyDescriptor(object, property) {\n      let proto = object;\n      let descriptor;\n      const isOwn = Boolean(\n          object && Object.getOwnPropertyDescriptor(object, property),\n      );\n\n      while (\n          proto &&\n          !(descriptor = Object.getOwnPropertyDescriptor(proto, property))\n      ) {\n          proto = Object.getPrototypeOf(proto);\n      }\n\n      if (descriptor) {\n          descriptor.isOwn = isOwn;\n      }\n\n      return descriptor;\n  }\n\n  module.exports = getPropertyDescriptor;\n\n  },{}],30:[function(require,module,exports){\n\n  /**\n   * Verify if an object is a ECMAScript Module\n   *\n   * As the exports from a module is immutable we cannot alter the exports\n   * using spies or stubs. Let the consumer know this to avoid bug reports\n   * on weird error messages.\n   *\n   * @param {object} object The object to examine\n   * @returns {boolean} true when the object is a module\n   */\n  module.exports = function (object) {\n      return (\n          object &&\n          typeof Symbol !== \"undefined\" &&\n          object[Symbol.toStringTag] === \"Module\" &&\n          Object.isSealed(object)\n      );\n  };\n\n  },{}],31:[function(require,module,exports){\n\n  /**\n   * @param {*} object\n   * @param {string} property\n   * @returns {boolean} whether a prop exists in the prototype chain\n   */\n  function isNonExistentProperty(object, property) {\n      return Boolean(\n          object && typeof property !== \"undefined\" && !(property in object),\n      );\n  }\n\n  module.exports = isNonExistentProperty;\n\n  },{}],32:[function(require,module,exports){\n\n  const getPropertyDescriptor = require(\"./get-property-descriptor\");\n\n  function isPropertyConfigurable(obj, propName) {\n      const propertyDescriptor = getPropertyDescriptor(obj, propName);\n\n      return propertyDescriptor ? propertyDescriptor.configurable : true;\n  }\n\n  module.exports = isPropertyConfigurable;\n\n  },{\"./get-property-descriptor\":29}],33:[function(require,module,exports){\n\n  function isRestorable(obj) {\n      return (\n          typeof obj === \"function\" &&\n          typeof obj.restore === \"function\" &&\n          obj.restore.sinon\n      );\n  }\n\n  module.exports = isRestorable;\n\n  },{}],34:[function(require,module,exports){\n\n  const globalObject = require(\"@sinonjs/commons\").global;\n  const getNextTick = require(\"./get-next-tick\");\n\n  module.exports = getNextTick(globalObject.process, globalObject.setImmediate);\n\n  },{\"./get-next-tick\":28,\"@sinonjs/commons\":47}],35:[function(require,module,exports){\n\n  const sinonTypeSymbolProperty = Symbol(\"SinonType\");\n\n  module.exports = {\n      /**\n       * Set the type of a Sinon object to make it possible to identify it later at runtime\n       *\n       * @param {object|Function} object  object/function to set the type on\n       * @param {string} type the named type of the object/function\n       */\n      set(object, type) {\n          Object.defineProperty(object, sinonTypeSymbolProperty, {\n              value: type,\n              configurable: false,\n              enumerable: false,\n          });\n      },\n      get(object) {\n          return object && object[sinonTypeSymbolProperty];\n      },\n  };\n\n  },{}],36:[function(require,module,exports){\n\n  const array = [null, \"once\", \"twice\", \"thrice\"];\n\n  module.exports = function timesInWords(count) {\n      return array[count] || `${count || 0} times`;\n  };\n\n  },{}],37:[function(require,module,exports){\n\n  const functionName = require(\"@sinonjs/commons\").functionName;\n\n  const getPropertyDescriptor = require(\"./get-property-descriptor\");\n  const walk = require(\"./walk\");\n\n  /**\n   * A utility that allows traversing an object, applying mutating functions on the properties\n   *\n   * @param {Function} mutator called on each property\n   * @param {object} object the object we are walking over\n   * @param {Function} filter a predicate (boolean function) that will decide whether or not to apply the mutator to the current property\n   * @returns {void} nothing\n   */\n  function walkObject(mutator, object, filter) {\n      let called = false;\n      const name = functionName(mutator);\n\n      if (!object) {\n          throw new Error(\n              `Trying to ${name} object but received ${String(object)}`,\n          );\n      }\n\n      walk(object, function (prop, propOwner) {\n          // we don't want to stub things like toString(), valueOf(), etc. so we only stub if the object\n          // is not Object.prototype\n          if (\n              propOwner !== Object.prototype &&\n              prop !== \"constructor\" &&\n              typeof getPropertyDescriptor(propOwner, prop).value === \"function\"\n          ) {\n              if (filter) {\n                  if (filter(object, prop)) {\n                      called = true;\n                      mutator(object, prop);\n                  }\n              } else {\n                  called = true;\n                  mutator(object, prop);\n              }\n          }\n      });\n\n      if (!called) {\n          throw new Error(\n              `Found no methods on object to which we could apply mutations`,\n          );\n      }\n\n      return object;\n  }\n\n  module.exports = walkObject;\n\n  },{\"./get-property-descriptor\":29,\"./walk\":38,\"@sinonjs/commons\":47}],38:[function(require,module,exports){\n\n  const forEach = require(\"@sinonjs/commons\").prototypes.array.forEach;\n\n  function walkInternal(obj, iterator, context, originalObj, seen) {\n      let prop;\n      const proto = Object.getPrototypeOf(obj);\n\n      if (typeof Object.getOwnPropertyNames !== \"function\") {\n          // We explicitly want to enumerate through all of the prototype's properties\n          // in this case, therefore we deliberately leave out an own property check.\n          /* eslint-disable-next-line guard-for-in */\n          for (prop in obj) {\n              iterator.call(context, obj[prop], prop, obj);\n          }\n\n          return;\n      }\n\n      forEach(Object.getOwnPropertyNames(obj), function (k) {\n          if (seen[k] !== true) {\n              seen[k] = true;\n              const target =\n                  typeof Object.getOwnPropertyDescriptor(obj, k).get ===\n                  \"function\"\n                      ? originalObj\n                      : obj;\n              iterator.call(context, k, target);\n          }\n      });\n\n      if (proto) {\n          walkInternal(proto, iterator, context, originalObj, seen);\n      }\n  }\n\n  /* Walks the prototype chain of an object and iterates over every own property\n   * name encountered. The iterator is called in the same fashion that Array.prototype.forEach\n   * works, where it is passed the value, key, and own object as the 1st, 2nd, and 3rd positional\n   * argument, respectively. In cases where Object.getOwnPropertyNames is not available, walk will\n   * default to using a simple for..in loop.\n   *\n   * obj - The object to walk the prototype chain for.\n   * iterator - The function to be called on each pass of the walk.\n   * context - (Optional) When given, the iterator will be called with this object as the receiver.\n   */\n  module.exports = function walk(obj, iterator, context) {\n      return walkInternal(obj, iterator, context, obj, {});\n  };\n\n  },{\"@sinonjs/commons\":47}],39:[function(require,module,exports){\n\n  // eslint-disable-next-line no-empty-function\n  const noop = () => {};\n  const getPropertyDescriptor = require(\"./get-property-descriptor\");\n  const extend = require(\"./extend\");\n  const sinonType = require(\"./sinon-type\");\n  const hasOwnProperty =\n      require(\"@sinonjs/commons\").prototypes.object.hasOwnProperty;\n  const valueToString = require(\"@sinonjs/commons\").valueToString;\n  const push = require(\"@sinonjs/commons\").prototypes.array.push;\n\n  function isFunction(obj) {\n      return (\n          typeof obj === \"function\" ||\n          Boolean(obj && obj.constructor && obj.call && obj.apply)\n      );\n  }\n\n  function mirrorProperties(target, source) {\n      for (const prop in source) {\n          if (!hasOwnProperty(target, prop)) {\n              target[prop] = source[prop];\n          }\n      }\n  }\n\n  function getAccessor(object, property, method) {\n      const accessors = [\"get\", \"set\"];\n      const descriptor = getPropertyDescriptor(object, property);\n\n      for (let i = 0; i < accessors.length; i++) {\n          if (\n              descriptor[accessors[i]] &&\n              descriptor[accessors[i]].name === method.name\n          ) {\n              return accessors[i];\n          }\n      }\n      return null;\n  }\n\n  // Cheap way to detect if we have ES5 support.\n  const hasES5Support = \"keys\" in Object;\n\n  module.exports = function wrapMethod(object, property, method) {\n      if (!object) {\n          throw new TypeError(\"Should wrap property of object\");\n      }\n\n      if (typeof method !== \"function\" && typeof method !== \"object\") {\n          throw new TypeError(\n              \"Method wrapper should be a function or a property descriptor\",\n          );\n      }\n\n      function checkWrappedMethod(wrappedMethod) {\n          let error;\n\n          if (!isFunction(wrappedMethod)) {\n              error = new TypeError(\n                  `Attempted to wrap ${typeof wrappedMethod} property ${valueToString(\n                    property,\n                )} as function`,\n              );\n          } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n              error = new TypeError(\n                  `Attempted to wrap ${valueToString(\n                    property,\n                )} which is already wrapped`,\n              );\n          } else if (wrappedMethod.calledBefore) {\n              const verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n              error = new TypeError(\n                  `Attempted to wrap ${valueToString(\n                    property,\n                )} which is already ${verb}`,\n              );\n          }\n\n          if (error) {\n              if (wrappedMethod && wrappedMethod.stackTraceError) {\n                  error.stack += `\\n--------------\\n${wrappedMethod.stackTraceError.stack}`;\n              }\n              throw error;\n          }\n      }\n\n      let error, wrappedMethod, i, wrappedMethodDesc, target, accessor;\n\n      const wrappedMethods = [];\n\n      function simplePropertyAssignment() {\n          wrappedMethod = object[property];\n          checkWrappedMethod(wrappedMethod);\n          object[property] = method;\n          method.displayName = property;\n      }\n\n      // Firefox has a problem when using hasOwn.call on objects from other frames.\n      const owned = object.hasOwnProperty\n          ? object.hasOwnProperty(property) // eslint-disable-line @sinonjs/no-prototype-methods/no-prototype-methods\n          : hasOwnProperty(object, property);\n\n      if (hasES5Support) {\n          const methodDesc =\n              typeof method === \"function\" ? { value: method } : method;\n          wrappedMethodDesc = getPropertyDescriptor(object, property);\n\n          if (!wrappedMethodDesc) {\n              error = new TypeError(\n                  `Attempted to wrap ${typeof wrappedMethod} property ${property} as function`,\n              );\n          } else if (\n              wrappedMethodDesc.restore &&\n              wrappedMethodDesc.restore.sinon\n          ) {\n              error = new TypeError(\n                  `Attempted to wrap ${property} which is already wrapped`,\n              );\n          }\n          if (error) {\n              if (wrappedMethodDesc && wrappedMethodDesc.stackTraceError) {\n                  error.stack += `\\n--------------\\n${wrappedMethodDesc.stackTraceError.stack}`;\n              }\n              throw error;\n          }\n\n          const types = Object.keys(methodDesc);\n          for (i = 0; i < types.length; i++) {\n              wrappedMethod = wrappedMethodDesc[types[i]];\n              checkWrappedMethod(wrappedMethod);\n              push(wrappedMethods, wrappedMethod);\n          }\n\n          mirrorProperties(methodDesc, wrappedMethodDesc);\n          for (i = 0; i < types.length; i++) {\n              mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n          }\n\n          // you are not allowed to flip the configurable prop on an\n          // existing descriptor to anything but false (#2514)\n          if (!owned) {\n              methodDesc.configurable = true;\n          }\n\n          Object.defineProperty(object, property, methodDesc);\n\n          // catch failing assignment\n          // this is the converse of the check in `.restore` below\n          if (typeof method === \"function\" && object[property] !== method) {\n              // correct any wrongdoings caused by the defineProperty call above,\n              // such as adding new items (if object was a Storage object)\n              delete object[property];\n              simplePropertyAssignment();\n          }\n      } else {\n          simplePropertyAssignment();\n      }\n\n      extendObjectWithWrappedMethods();\n\n      function extendObjectWithWrappedMethods() {\n          for (i = 0; i < wrappedMethods.length; i++) {\n              accessor = getAccessor(object, property, wrappedMethods[i]);\n              target = accessor ? method[accessor] : method;\n              extend.nonEnum(target, {\n                  displayName: property,\n                  wrappedMethod: wrappedMethods[i],\n\n                  // Set up an Error object for a stack trace which can be used later to find what line of\n                  // code the original method was created on.\n                  stackTraceError: new Error(\"Stack Trace for original\"),\n\n                  restore: restore,\n              });\n\n              target.restore.sinon = true;\n              if (!hasES5Support) {\n                  mirrorProperties(target, wrappedMethod);\n              }\n          }\n      }\n\n      function restore() {\n          accessor = getAccessor(object, property, this.wrappedMethod);\n          let descriptor;\n          // For prototype properties try to reset by delete first.\n          // If this fails (ex: localStorage on mobile safari) then force a reset\n          // via direct assignment.\n          if (accessor) {\n              if (!owned) {\n                  try {\n                      // In some cases `delete` may throw an error\n                      delete object[property][accessor];\n                  } catch (e) {} // eslint-disable-line no-empty\n                  // For native code functions `delete` fails without throwing an error\n                  // on Chrome < 43, PhantomJS, etc.\n              } else if (hasES5Support) {\n                  descriptor = getPropertyDescriptor(object, property);\n                  descriptor[accessor] = wrappedMethodDesc[accessor];\n                  Object.defineProperty(object, property, descriptor);\n              }\n\n              if (hasES5Support) {\n                  descriptor = getPropertyDescriptor(object, property);\n                  if (descriptor && descriptor.value === target) {\n                      object[property][accessor] = this.wrappedMethod;\n                  }\n              } else {\n                  // Use strict equality comparison to check failures then force a reset\n                  // via direct assignment.\n                  if (object[property][accessor] === target) {\n                      object[property][accessor] = this.wrappedMethod;\n                  }\n              }\n          } else {\n              if (!owned) {\n                  try {\n                      delete object[property];\n                  } catch (e) {} // eslint-disable-line no-empty\n              } else if (hasES5Support) {\n                  Object.defineProperty(object, property, wrappedMethodDesc);\n              }\n\n              if (hasES5Support) {\n                  descriptor = getPropertyDescriptor(object, property);\n                  if (descriptor && descriptor.value === target) {\n                      object[property] = this.wrappedMethod;\n                  }\n              } else {\n                  if (object[property] === target) {\n                      object[property] = this.wrappedMethod;\n                  }\n              }\n          }\n          if (sinonType.get(object) === \"stub-instance\") {\n              // this is simply to avoid errors after restoring if something should\n              // traverse the object in a cleanup phase, ref #2477\n              object[property] = noop;\n          }\n      }\n\n      return method;\n  };\n\n  },{\"./extend\":26,\"./get-property-descriptor\":29,\"./sinon-type\":35,\"@sinonjs/commons\":47}],40:[function(require,module,exports){\n\n  const extend = require(\"./core/extend\");\n  const FakeTimers = require(\"@sinonjs/fake-timers\");\n  const globalObject = require(\"@sinonjs/commons\").global;\n\n  /**\n   *\n   * @param config\n   * @param globalCtx\n   *\n   * @returns {object} the clock, after installing it on the global context, if given\n   */\n  function createClock(config, globalCtx) {\n      let FakeTimersCtx = FakeTimers;\n      if (globalCtx !== null && typeof globalCtx === \"object\") {\n          FakeTimersCtx = FakeTimers.withGlobal(globalCtx);\n      }\n      const clock = FakeTimersCtx.install(config);\n      clock.restore = clock.uninstall;\n      return clock;\n  }\n\n  /**\n   *\n   * @param obj\n   * @param globalPropName\n   */\n  function addIfDefined(obj, globalPropName) {\n      const globalProp = globalObject[globalPropName];\n      if (typeof globalProp !== \"undefined\") {\n          obj[globalPropName] = globalProp;\n      }\n  }\n\n  /**\n   * @param {number|Date|object} dateOrConfig The unix epoch value to install with (default 0)\n   * @returns {object} Returns a lolex clock instance\n   */\n  exports.useFakeTimers = function (dateOrConfig) {\n      const hasArguments = typeof dateOrConfig !== \"undefined\";\n      const argumentIsDateLike =\n          (typeof dateOrConfig === \"number\" || dateOrConfig instanceof Date) &&\n          arguments.length === 1;\n      const argumentIsObject =\n          dateOrConfig !== null &&\n          typeof dateOrConfig === \"object\" &&\n          arguments.length === 1;\n\n      if (!hasArguments) {\n          return createClock({\n              now: 0,\n          });\n      }\n\n      if (argumentIsDateLike) {\n          return createClock({\n              now: dateOrConfig,\n          });\n      }\n\n      if (argumentIsObject) {\n          const config = extend.nonEnum({}, dateOrConfig);\n          const globalCtx = config.global;\n          delete config.global;\n          return createClock(config, globalCtx);\n      }\n\n      throw new TypeError(\n          \"useFakeTimers expected epoch or config object. See https://github.com/sinonjs/sinon\",\n      );\n  };\n\n  exports.clock = {\n      create: function (now) {\n          return FakeTimers.createClock(now);\n      },\n  };\n\n  const timers = {\n      setTimeout: setTimeout,\n      clearTimeout: clearTimeout,\n      setInterval: setInterval,\n      clearInterval: clearInterval,\n      Date: Date,\n  };\n  addIfDefined(timers, \"setImmediate\");\n  addIfDefined(timers, \"clearImmediate\");\n\n  exports.timers = timers;\n\n  },{\"./core/extend\":26,\"@sinonjs/commons\":47,\"@sinonjs/fake-timers\":60}],41:[function(require,module,exports){\n\n  var every = require(\"./prototypes/array\").every;\n\n  /**\n   * @private\n   */\n  function hasCallsLeft(callMap, spy) {\n      if (callMap[spy.id] === undefined) {\n          callMap[spy.id] = 0;\n      }\n\n      return callMap[spy.id] < spy.callCount;\n  }\n\n  /**\n   * @private\n   */\n  function checkAdjacentCalls(callMap, spy, index, spies) {\n      var calledBeforeNext = true;\n\n      if (index !== spies.length - 1) {\n          calledBeforeNext = spy.calledBefore(spies[index + 1]);\n      }\n\n      if (hasCallsLeft(callMap, spy) && calledBeforeNext) {\n          callMap[spy.id] += 1;\n          return true;\n      }\n\n      return false;\n  }\n\n  /**\n   * A Sinon proxy object (fake, spy, stub)\n   * @typedef {object} SinonProxy\n   * @property {Function} calledBefore - A method that determines if this proxy was called before another one\n   * @property {string} id - Some id\n   * @property {number} callCount - Number of times this proxy has been called\n   */\n\n  /**\n   * Returns true when the spies have been called in the order they were supplied in\n   * @param  {SinonProxy[] | SinonProxy} spies An array of proxies, or several proxies as arguments\n   * @returns {boolean} true when spies are called in order, false otherwise\n   */\n  function calledInOrder(spies) {\n      var callMap = {};\n      // eslint-disable-next-line no-underscore-dangle\n      var _spies = arguments.length > 1 ? arguments : spies;\n\n      return every(_spies, checkAdjacentCalls.bind(null, callMap));\n  }\n\n  module.exports = calledInOrder;\n\n  },{\"./prototypes/array\":49}],42:[function(require,module,exports){\n\n  /**\n   * Returns a display name for a value from a constructor\n   * @param  {object} value A value to examine\n   * @returns {(string|null)} A string or null\n   */\n  function className(value) {\n      const name = value.constructor && value.constructor.name;\n      return name || null;\n  }\n\n  module.exports = className;\n\n  },{}],43:[function(require,module,exports){\n\n  /**\n   * Returns a function that will invoke the supplied function and print a\n   * deprecation warning to the console each time it is called.\n   * @param  {Function} func\n   * @param  {string} msg\n   * @returns {Function}\n   */\n  exports.wrap = function (func, msg) {\n      var wrapped = function () {\n          exports.printWarning(msg);\n          return func.apply(this, arguments);\n      };\n      if (func.prototype) {\n          wrapped.prototype = func.prototype;\n      }\n      return wrapped;\n  };\n\n  /**\n   * Returns a string which can be supplied to `wrap()` to notify the user that a\n   * particular part of the sinon API has been deprecated.\n   * @param  {string} packageName\n   * @param  {string} funcName\n   * @returns {string}\n   */\n  exports.defaultMsg = function (packageName, funcName) {\n      return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;\n  };\n\n  /**\n   * Prints a warning on the console, when it exists\n   * @param  {string} msg\n   * @returns {undefined}\n   */\n  exports.printWarning = function (msg) {\n      /* istanbul ignore next */\n      if (typeof _polyfillNode_process.browser$1 === \"object\" && _polyfillNode_process.browser$1.emitWarning) {\n          // Emit Warnings in Node\n          _polyfillNode_process.browser$1.emitWarning(msg);\n      } else if (console.info) {\n          console.info(msg);\n      } else {\n          console.log(msg);\n      }\n  };\n\n  },{}],44:[function(require,module,exports){\n\n  /**\n   * Returns true when fn returns true for all members of obj.\n   * This is an every implementation that works for all iterables\n   * @param  {object}   obj\n   * @param  {Function} fn\n   * @returns {boolean}\n   */\n  module.exports = function every(obj, fn) {\n      var pass = true;\n\n      try {\n          // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n          obj.forEach(function () {\n              if (!fn.apply(this, arguments)) {\n                  // Throwing an error is the only way to break `forEach`\n                  throw new Error();\n              }\n          });\n      } catch (e) {\n          pass = false;\n      }\n\n      return pass;\n  };\n\n  },{}],45:[function(require,module,exports){\n\n  /**\n   * Returns a display name for a function\n   * @param  {Function} func\n   * @returns {string}\n   */\n  module.exports = function functionName(func) {\n      if (!func) {\n          return \"\";\n      }\n\n      try {\n          return (\n              func.displayName ||\n              func.name ||\n              // Use function decomposition as a last resort to get function\n              // name. Does not rely on function decomposition to work - if it\n              // doesn't debugging will be slightly less informative\n              // (i.e. toString will say 'spy' rather than 'myFunc').\n              (String(func).match(/function ([^\\s(]+)/) || [])[1]\n          );\n      } catch (e) {\n          // Stringify may fail and we might get an exception, as a last-last\n          // resort fall back to empty string.\n          return \"\";\n      }\n  };\n\n  },{}],46:[function(require,module,exports){\n\n  /**\n   * A reference to the global object\n   * @type {object} globalObject\n   */\n  var globalObject;\n\n  /* istanbul ignore else */\n  if (typeof _polyfillNode_process.global !== \"undefined\") {\n      // Node\n      globalObject = _polyfillNode_process.global;\n  } else if (typeof window !== \"undefined\") {\n      // Browser\n      globalObject = window;\n  } else {\n      // WebWorker\n      globalObject = self;\n  }\n\n  module.exports = globalObject;\n\n  },{}],47:[function(require,module,exports){\n\n  module.exports = {\n      global: require(\"./global\"),\n      calledInOrder: require(\"./called-in-order\"),\n      className: require(\"./class-name\"),\n      deprecated: require(\"./deprecated\"),\n      every: require(\"./every\"),\n      functionName: require(\"./function-name\"),\n      orderByFirstCall: require(\"./order-by-first-call\"),\n      prototypes: require(\"./prototypes\"),\n      typeOf: require(\"./type-of\"),\n      valueToString: require(\"./value-to-string\"),\n  };\n\n  },{\"./called-in-order\":41,\"./class-name\":42,\"./deprecated\":43,\"./every\":44,\"./function-name\":45,\"./global\":46,\"./order-by-first-call\":48,\"./prototypes\":52,\"./type-of\":58,\"./value-to-string\":59}],48:[function(require,module,exports){\n\n  var sort = require(\"./prototypes/array\").sort;\n  var slice = require(\"./prototypes/array\").slice;\n\n  /**\n   * @private\n   */\n  function comparator(a, b) {\n      // uuid, won't ever be equal\n      var aCall = a.getCall(0);\n      var bCall = b.getCall(0);\n      var aId = (aCall && aCall.callId) || -1;\n      var bId = (bCall && bCall.callId) || -1;\n\n      return aId < bId ? -1 : 1;\n  }\n\n  /**\n   * A Sinon proxy object (fake, spy, stub)\n   * @typedef {object} SinonProxy\n   * @property {Function} getCall - A method that can return the first call\n   */\n\n  /**\n   * Sorts an array of SinonProxy instances (fake, spy, stub) by their first call\n   * @param  {SinonProxy[] | SinonProxy} spies\n   * @returns {SinonProxy[]}\n   */\n  function orderByFirstCall(spies) {\n      return sort(slice(spies), comparator);\n  }\n\n  module.exports = orderByFirstCall;\n\n  },{\"./prototypes/array\":49}],49:[function(require,module,exports){\n\n  var copyPrototype = require(\"./copy-prototype-methods\");\n\n  module.exports = copyPrototype(Array.prototype);\n\n  },{\"./copy-prototype-methods\":50}],50:[function(require,module,exports){\n\n  var call = Function.call;\n  var throwsOnProto = require(\"./throws-on-proto\");\n\n  var disallowedProperties = [\n      // ignore size because it throws from Map\n      \"size\",\n      \"caller\",\n      \"callee\",\n      \"arguments\",\n  ];\n\n  // This branch is covered when tests are run with `--disable-proto=throw`,\n  // however we can test both branches at the same time, so this is ignored\n  /* istanbul ignore next */\n  if (throwsOnProto) {\n      disallowedProperties.push(\"__proto__\");\n  }\n\n  module.exports = function copyPrototypeMethods(prototype) {\n      // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n      return Object.getOwnPropertyNames(prototype).reduce(function (\n          result,\n          name\n      ) {\n          if (disallowedProperties.includes(name)) {\n              return result;\n          }\n\n          if (typeof prototype[name] !== \"function\") {\n              return result;\n          }\n\n          result[name] = call.bind(prototype[name]);\n\n          return result;\n      },\n      Object.create(null));\n  };\n\n  },{\"./throws-on-proto\":57}],51:[function(require,module,exports){\n\n  var copyPrototype = require(\"./copy-prototype-methods\");\n\n  module.exports = copyPrototype(Function.prototype);\n\n  },{\"./copy-prototype-methods\":50}],52:[function(require,module,exports){\n\n  module.exports = {\n      array: require(\"./array\"),\n      function: require(\"./function\"),\n      map: require(\"./map\"),\n      object: require(\"./object\"),\n      set: require(\"./set\"),\n      string: require(\"./string\"),\n  };\n\n  },{\"./array\":49,\"./function\":51,\"./map\":53,\"./object\":54,\"./set\":55,\"./string\":56}],53:[function(require,module,exports){\n\n  var copyPrototype = require(\"./copy-prototype-methods\");\n\n  module.exports = copyPrototype(Map.prototype);\n\n  },{\"./copy-prototype-methods\":50}],54:[function(require,module,exports){\n\n  var copyPrototype = require(\"./copy-prototype-methods\");\n\n  module.exports = copyPrototype(Object.prototype);\n\n  },{\"./copy-prototype-methods\":50}],55:[function(require,module,exports){\n\n  var copyPrototype = require(\"./copy-prototype-methods\");\n\n  module.exports = copyPrototype(Set.prototype);\n\n  },{\"./copy-prototype-methods\":50}],56:[function(require,module,exports){\n\n  var copyPrototype = require(\"./copy-prototype-methods\");\n\n  module.exports = copyPrototype(String.prototype);\n\n  },{\"./copy-prototype-methods\":50}],57:[function(require,module,exports){\n\n  /**\n   * Is true when the environment causes an error to be thrown for accessing the\n   * __proto__ property.\n   * This is necessary in order to support `node --disable-proto=throw`.\n   *\n   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\n   * @type {boolean}\n   */\n  let throwsOnProto;\n  try {\n      const object = {};\n      // eslint-disable-next-line no-proto, no-unused-expressions\n      object.__proto__;\n      throwsOnProto = false;\n  } catch (_) {\n      // This branch is covered when tests are run with `--disable-proto=throw`,\n      // however we can test both branches at the same time, so this is ignored\n      /* istanbul ignore next */\n      throwsOnProto = true;\n  }\n\n  module.exports = throwsOnProto;\n\n  },{}],58:[function(require,module,exports){\n\n  var type = require(\"type-detect\");\n\n  /**\n   * Returns the lower-case result of running type from type-detect on the value\n   * @param  {*} value\n   * @returns {string}\n   */\n  module.exports = function typeOf(value) {\n      return type(value).toLowerCase();\n  };\n\n  },{\"type-detect\":95}],59:[function(require,module,exports){\n\n  /**\n   * Returns a string representation of the value\n   * @param  {*} value\n   * @returns {string}\n   */\n  function valueToString(value) {\n      if (value && value.toString) {\n          // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n          return value.toString();\n      }\n      return String(value);\n  }\n\n  module.exports = valueToString;\n\n  },{}],60:[function(require,module,exports){\n\n  const globalObject = require(\"@sinonjs/commons\").global;\n  let timersModule, timersPromisesModule;\n  if (typeof require === \"function\" && typeof module === \"object\") {\n      try {\n          timersModule = require(\"timers\");\n      } catch (e) {\n          // ignored\n      }\n      try {\n          timersPromisesModule = require(\"timers/promises\");\n      } catch (e) {\n          // ignored\n      }\n  }\n\n  /**\n   * @typedef {object} IdleDeadline\n   * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout\n   * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period\n   */\n\n  /**\n   * Queues a function to be called during a browser's idle periods\n   *\n   * @callback RequestIdleCallback\n   * @param {function(IdleDeadline)} callback\n   * @param {{timeout: number}} options - an options object\n   * @returns {number} the id\n   */\n\n  /**\n   * @callback NextTick\n   * @param {VoidVarArgsFunc} callback - the callback to run\n   * @param {...*} args - optional arguments to call the callback with\n   * @returns {void}\n   */\n\n  /**\n   * @callback SetImmediate\n   * @param {VoidVarArgsFunc} callback - the callback to run\n   * @param {...*} args - optional arguments to call the callback with\n   * @returns {NodeImmediate}\n   */\n\n  /**\n   * @callback VoidVarArgsFunc\n   * @param {...*} callback - the callback to run\n   * @returns {void}\n   */\n\n  /**\n   * @typedef RequestAnimationFrame\n   * @property {function(number):void} requestAnimationFrame\n   * @returns {number} - the id\n   */\n\n  /**\n   * @typedef Performance\n   * @property {function(): number} now\n   */\n\n  /* eslint-disable jsdoc/require-property-description */\n  /**\n   * @typedef {object} Clock\n   * @property {number} now - the current time\n   * @property {Date} Date - the Date constructor\n   * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop\n   * @property {RequestIdleCallback} requestIdleCallback\n   * @property {function(number):void} cancelIdleCallback\n   * @property {setTimeout} setTimeout\n   * @property {clearTimeout} clearTimeout\n   * @property {NextTick} nextTick\n   * @property {queueMicrotask} queueMicrotask\n   * @property {setInterval} setInterval\n   * @property {clearInterval} clearInterval\n   * @property {SetImmediate} setImmediate\n   * @property {function(NodeImmediate):void} clearImmediate\n   * @property {function():number} countTimers\n   * @property {RequestAnimationFrame} requestAnimationFrame\n   * @property {function(number):void} cancelAnimationFrame\n   * @property {function():void} runMicrotasks\n   * @property {function(string | number): number} tick\n   * @property {function(string | number): Promise<number>} tickAsync\n   * @property {function(): number} next\n   * @property {function(): Promise<number>} nextAsync\n   * @property {function(): number} runAll\n   * @property {function(): number} runToFrame\n   * @property {function(): Promise<number>} runAllAsync\n   * @property {function(): number} runToLast\n   * @property {function(): Promise<number>} runToLastAsync\n   * @property {function(): void} reset\n   * @property {function(number | Date): void} setSystemTime\n   * @property {function(number): void} jump\n   * @property {Performance} performance\n   * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)\n   * @property {function(): void} uninstall Uninstall the clock.\n   * @property {Function[]} methods - the methods that are faked\n   * @property {boolean} [shouldClearNativeTimers] inherited from config\n   * @property {{methodName:string, original:any}[] | undefined} timersModuleMethods\n   * @property {{methodName:string, original:any}[] | undefined} timersPromisesModuleMethods\n   * @property {Map<function(): void, AbortSignal>} abortListenerMap\n   */\n  /* eslint-enable jsdoc/require-property-description */\n\n  /**\n   * Configuration object for the `install` method.\n   *\n   * @typedef {object} Config\n   * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)\n   * @property {string[]} [toFake] names of the methods that should be faked.\n   * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()\n   * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)\n   * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)\n   * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)\n   * @property {boolean} [ignoreMissingTimers] default is false, meaning asking to fake timers that are not present will throw an error\n   */\n\n  /* eslint-disable jsdoc/require-property-description */\n  /**\n   * The internal structure to describe a scheduled fake timer\n   *\n   * @typedef {object} Timer\n   * @property {Function} func\n   * @property {*[]} args\n   * @property {number} delay\n   * @property {number} callAt\n   * @property {number} createdAt\n   * @property {boolean} immediate\n   * @property {number} id\n   * @property {Error} [error]\n   */\n\n  /**\n   * A Node timer\n   *\n   * @typedef {object} NodeImmediate\n   * @property {function(): boolean} hasRef\n   * @property {function(): NodeImmediate} ref\n   * @property {function(): NodeImmediate} unref\n   */\n  /* eslint-enable jsdoc/require-property-description */\n\n  /* eslint-disable complexity */\n\n  /**\n   * Mocks available features in the specified global namespace.\n   *\n   * @param {*} _global Namespace to mock (e.g. `window`)\n   * @returns {FakeTimers}\n   */\n  function withGlobal(_global) {\n      const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint\n      const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs\n      const NOOP = function () {\n          return undefined;\n      };\n      const NOOP_ARRAY = function () {\n          return [];\n      };\n      const isPresent = {};\n      let timeoutResult,\n          addTimerReturnsObject = false;\n\n      if (_global.setTimeout) {\n          isPresent.setTimeout = true;\n          timeoutResult = _global.setTimeout(NOOP, 0);\n          addTimerReturnsObject = typeof timeoutResult === \"object\";\n      }\n      isPresent.clearTimeout = Boolean(_global.clearTimeout);\n      isPresent.setInterval = Boolean(_global.setInterval);\n      isPresent.clearInterval = Boolean(_global.clearInterval);\n      isPresent.hrtime =\n          _global.process && typeof _global.process.hrtime === \"function\";\n      isPresent.hrtimeBigint =\n          isPresent.hrtime && typeof _global.process.hrtime.bigint === \"function\";\n      isPresent.nextTick =\n          _global.process && typeof _global.process.nextTick === \"function\";\n      const utilPromisify = _global.process && require(\"util\").promisify;\n      isPresent.performance =\n          _global.performance && typeof _global.performance.now === \"function\";\n      const hasPerformancePrototype =\n          _global.Performance &&\n          (typeof _global.Performance).match(/^(function|object)$/);\n      const hasPerformanceConstructorPrototype =\n          _global.performance &&\n          _global.performance.constructor &&\n          _global.performance.constructor.prototype;\n      isPresent.queueMicrotask = _global.hasOwnProperty(\"queueMicrotask\");\n      isPresent.requestAnimationFrame =\n          _global.requestAnimationFrame &&\n          typeof _global.requestAnimationFrame === \"function\";\n      isPresent.cancelAnimationFrame =\n          _global.cancelAnimationFrame &&\n          typeof _global.cancelAnimationFrame === \"function\";\n      isPresent.requestIdleCallback =\n          _global.requestIdleCallback &&\n          typeof _global.requestIdleCallback === \"function\";\n      isPresent.cancelIdleCallbackPresent =\n          _global.cancelIdleCallback &&\n          typeof _global.cancelIdleCallback === \"function\";\n      isPresent.setImmediate =\n          _global.setImmediate && typeof _global.setImmediate === \"function\";\n      isPresent.clearImmediate =\n          _global.clearImmediate && typeof _global.clearImmediate === \"function\";\n      isPresent.Intl = _global.Intl && typeof _global.Intl === \"object\";\n\n      if (_global.clearTimeout) {\n          _global.clearTimeout(timeoutResult);\n      }\n\n      const NativeDate = _global.Date;\n      const NativeIntl = _global.Intl;\n      let uniqueTimerId = idCounterStart;\n\n      if (NativeDate === undefined) {\n          throw new Error(\n              \"The global scope doesn't have a `Date` object\" +\n                  \" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)\",\n          );\n      }\n      isPresent.Date = true;\n\n      /**\n       * The PerformanceEntry object encapsulates a single performance metric\n       * that is part of the browser's performance timeline.\n       *\n       * This is an object returned by the `mark` and `measure` methods on the Performance prototype\n       */\n      class FakePerformanceEntry {\n          constructor(name, entryType, startTime, duration) {\n              this.name = name;\n              this.entryType = entryType;\n              this.startTime = startTime;\n              this.duration = duration;\n          }\n\n          toJSON() {\n              return JSON.stringify({ ...this });\n          }\n      }\n\n      /**\n       * @param {number} num\n       * @returns {boolean}\n       */\n      function isNumberFinite(num) {\n          if (Number.isFinite) {\n              return Number.isFinite(num);\n          }\n\n          return isFinite(num);\n      }\n\n      let isNearInfiniteLimit = false;\n\n      /**\n       * @param {Clock} clock\n       * @param {number} i\n       */\n      function checkIsNearInfiniteLimit(clock, i) {\n          if (clock.loopLimit && i === clock.loopLimit - 1) {\n              isNearInfiniteLimit = true;\n          }\n      }\n\n      /**\n       *\n       */\n      function resetIsNearInfiniteLimit() {\n          isNearInfiniteLimit = false;\n      }\n\n      /**\n       * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n       * number of milliseconds. This is used to support human-readable strings passed\n       * to clock.tick()\n       *\n       * @param {string} str\n       * @returns {number}\n       */\n      function parseTime(str) {\n          if (!str) {\n              return 0;\n          }\n\n          const strings = str.split(\":\");\n          const l = strings.length;\n          let i = l;\n          let ms = 0;\n          let parsed;\n\n          if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n              throw new Error(\n                  \"tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits\",\n              );\n          }\n\n          while (i--) {\n              parsed = parseInt(strings[i], 10);\n\n              if (parsed >= 60) {\n                  throw new Error(`Invalid time ${str}`);\n              }\n\n              ms += parsed * Math.pow(60, l - i - 1);\n          }\n\n          return ms * 1000;\n      }\n\n      /**\n       * Get the decimal part of the millisecond value as nanoseconds\n       *\n       * @param {number} msFloat the number of milliseconds\n       * @returns {number} an integer number of nanoseconds in the range [0,1e6)\n       *\n       * Example: nanoRemainer(123.456789) -> 456789\n       */\n      function nanoRemainder(msFloat) {\n          const modulo = 1e6;\n          const remainder = (msFloat * 1e6) % modulo;\n          const positiveRemainder =\n              remainder < 0 ? remainder + modulo : remainder;\n\n          return Math.floor(positiveRemainder);\n      }\n\n      /**\n       * Used to grok the `now` parameter to createClock.\n       *\n       * @param {Date|number} epoch the system time\n       * @returns {number}\n       */\n      function getEpoch(epoch) {\n          if (!epoch) {\n              return 0;\n          }\n          if (typeof epoch.getTime === \"function\") {\n              return epoch.getTime();\n          }\n          if (typeof epoch === \"number\") {\n              return epoch;\n          }\n          throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n      }\n\n      /**\n       * @param {number} from\n       * @param {number} to\n       * @param {Timer} timer\n       * @returns {boolean}\n       */\n      function inRange(from, to, timer) {\n          return timer && timer.callAt >= from && timer.callAt <= to;\n      }\n\n      /**\n       * @param {Clock} clock\n       * @param {Timer} job\n       */\n      function getInfiniteLoopError(clock, job) {\n          const infiniteLoopError = new Error(\n              `Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`,\n          );\n\n          if (!job.error) {\n              return infiniteLoopError;\n          }\n\n          // pattern never matched in Node\n          const computedTargetPattern = /target\\.*[<|(|[].*?[>|\\]|)]\\s*/;\n          let clockMethodPattern = new RegExp(\n              String(Object.keys(clock).join(\"|\")),\n          );\n\n          if (addTimerReturnsObject) {\n              // node.js environment\n              clockMethodPattern = new RegExp(\n                  `\\\\s+at (Object\\\\.)?(?:${Object.keys(clock).join(\"|\")})\\\\s+`,\n              );\n          }\n\n          let matchedLineIndex = -1;\n          job.error.stack.split(\"\\n\").some(function (line, i) {\n              // If we've matched a computed target line (e.g. setTimeout) then we\n              // don't need to look any further. Return true to stop iterating.\n              const matchedComputedTarget = line.match(computedTargetPattern);\n              /* istanbul ignore if */\n              if (matchedComputedTarget) {\n                  matchedLineIndex = i;\n                  return true;\n              }\n\n              // If we've matched a clock method line, then there may still be\n              // others further down the trace. Return false to keep iterating.\n              const matchedClockMethod = line.match(clockMethodPattern);\n              if (matchedClockMethod) {\n                  matchedLineIndex = i;\n                  return false;\n              }\n\n              // If we haven't matched anything on this line, but we matched\n              // previously and set the matched line index, then we can stop.\n              // If we haven't matched previously, then we should keep iterating.\n              return matchedLineIndex >= 0;\n          });\n\n          const stack = `${infiniteLoopError}\\n${job.type || \"Microtask\"} - ${\n            job.func.name || \"anonymous\"\n        }\\n${job.error.stack\n            .split(\"\\n\")\n            .slice(matchedLineIndex + 1)\n            .join(\"\\n\")}`;\n\n          try {\n              Object.defineProperty(infiniteLoopError, \"stack\", {\n                  value: stack,\n              });\n          } catch (e) {\n              // noop\n          }\n\n          return infiniteLoopError;\n      }\n\n      //eslint-disable-next-line jsdoc/require-jsdoc\n      function createDate() {\n          class ClockDate extends NativeDate {\n              /**\n               * @param {number} year\n               * @param {number} month\n               * @param {number} date\n               * @param {number} hour\n               * @param {number} minute\n               * @param {number} second\n               * @param {number} ms\n               * @returns void\n               */\n              // eslint-disable-next-line no-unused-vars\n              constructor(year, month, date, hour, minute, second, ms) {\n                  // Defensive and verbose to avoid potential harm in passing\n                  // explicit undefined when user does not pass argument\n                  if (arguments.length === 0) {\n                      super(ClockDate.clock.now);\n                  } else {\n                      super(...arguments);\n                  }\n\n                  // ensures identity checks using the constructor prop still works\n                  // this should have no other functional effect\n                  Object.defineProperty(this, \"constructor\", {\n                      value: NativeDate,\n                      enumerable: false,\n                  });\n              }\n\n              static [Symbol.hasInstance](instance) {\n                  return instance instanceof NativeDate;\n              }\n          }\n\n          ClockDate.isFake = true;\n\n          if (NativeDate.now) {\n              ClockDate.now = function now() {\n                  return ClockDate.clock.now;\n              };\n          }\n\n          if (NativeDate.toSource) {\n              ClockDate.toSource = function toSource() {\n                  return NativeDate.toSource();\n              };\n          }\n\n          ClockDate.toString = function toString() {\n              return NativeDate.toString();\n          };\n\n          // noinspection UnnecessaryLocalVariableJS\n          /**\n           * A normal Class constructor cannot be called without `new`, but Date can, so we need\n           * to wrap it in a Proxy in order to ensure this functionality of Date is kept intact\n           *\n           * @type {ClockDate}\n           */\n          const ClockDateProxy = new Proxy(ClockDate, {\n              // handler for [[Call]] invocations (i.e. not using `new`)\n              apply() {\n                  // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.\n                  // This remains so in the 10th edition of 2019 as well.\n                  if (this instanceof ClockDate) {\n                      throw new TypeError(\n                          \"A Proxy should only capture `new` calls with the `construct` handler. This is not supposed to be possible, so check the logic.\",\n                      );\n                  }\n\n                  return new NativeDate(ClockDate.clock.now).toString();\n              },\n          });\n\n          return ClockDateProxy;\n      }\n\n      /**\n       * Mirror Intl by default on our fake implementation\n       *\n       * Most of the properties are the original native ones,\n       * but we need to take control of those that have a\n       * dependency on the current clock.\n       *\n       * @returns {object} the partly fake Intl implementation\n       */\n      function createIntl() {\n          const ClockIntl = {};\n          /*\n           * All properties of Intl are non-enumerable, so we need\n           * to do a bit of work to get them out.\n           */\n          Object.getOwnPropertyNames(NativeIntl).forEach(\n              (property) => (ClockIntl[property] = NativeIntl[property]),\n          );\n\n          ClockIntl.DateTimeFormat = function (...args) {\n              const realFormatter = new NativeIntl.DateTimeFormat(...args);\n              const formatter = {};\n\n              [\"formatRange\", \"formatRangeToParts\", \"resolvedOptions\"].forEach(\n                  (method) => {\n                      formatter[method] =\n                          realFormatter[method].bind(realFormatter);\n                  },\n              );\n\n              [\"format\", \"formatToParts\"].forEach((method) => {\n                  formatter[method] = function (date) {\n                      return realFormatter[method](date || ClockIntl.clock.now);\n                  };\n              });\n\n              return formatter;\n          };\n\n          ClockIntl.DateTimeFormat.prototype = Object.create(\n              NativeIntl.DateTimeFormat.prototype,\n          );\n\n          ClockIntl.DateTimeFormat.supportedLocalesOf =\n              NativeIntl.DateTimeFormat.supportedLocalesOf;\n\n          return ClockIntl;\n      }\n\n      //eslint-disable-next-line jsdoc/require-jsdoc\n      function enqueueJob(clock, job) {\n          // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob\n          if (!clock.jobs) {\n              clock.jobs = [];\n          }\n          clock.jobs.push(job);\n      }\n\n      //eslint-disable-next-line jsdoc/require-jsdoc\n      function runJobs(clock) {\n          // runs all microtick-deferred tasks - ecma262/#sec-runjobs\n          if (!clock.jobs) {\n              return;\n          }\n          for (let i = 0; i < clock.jobs.length; i++) {\n              const job = clock.jobs[i];\n              job.func.apply(null, job.args);\n\n              checkIsNearInfiniteLimit(clock, i);\n              if (clock.loopLimit && i > clock.loopLimit) {\n                  throw getInfiniteLoopError(clock, job);\n              }\n          }\n          resetIsNearInfiniteLimit();\n          clock.jobs = [];\n      }\n\n      /**\n       * @param {Clock} clock\n       * @param {Timer} timer\n       * @returns {number} id of the created timer\n       */\n      function addTimer(clock, timer) {\n          if (timer.func === undefined) {\n              throw new Error(\"Callback must be provided to timer calls\");\n          }\n\n          if (addTimerReturnsObject) {\n              // Node.js environment\n              if (typeof timer.func !== \"function\") {\n                  throw new TypeError(\n                      `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${\n                        timer.func\n                    } of type ${typeof timer.func}`,\n                  );\n              }\n          }\n\n          if (isNearInfiniteLimit) {\n              timer.error = new Error();\n          }\n\n          timer.type = timer.immediate ? \"Immediate\" : \"Timeout\";\n\n          if (timer.hasOwnProperty(\"delay\")) {\n              if (typeof timer.delay !== \"number\") {\n                  timer.delay = parseInt(timer.delay, 10);\n              }\n\n              if (!isNumberFinite(timer.delay)) {\n                  timer.delay = 0;\n              }\n              timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;\n              timer.delay = Math.max(0, timer.delay);\n          }\n\n          if (timer.hasOwnProperty(\"interval\")) {\n              timer.type = \"Interval\";\n              timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;\n          }\n\n          if (timer.hasOwnProperty(\"animation\")) {\n              timer.type = \"AnimationFrame\";\n              timer.animation = true;\n          }\n\n          if (timer.hasOwnProperty(\"idleCallback\")) {\n              timer.type = \"IdleCallback\";\n              timer.idleCallback = true;\n          }\n\n          if (!clock.timers) {\n              clock.timers = {};\n          }\n\n          timer.id = uniqueTimerId++;\n          timer.createdAt = clock.now;\n          timer.callAt =\n              clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n\n          clock.timers[timer.id] = timer;\n\n          if (addTimerReturnsObject) {\n              const res = {\n                  refed: true,\n                  ref: function () {\n                      this.refed = true;\n                      return res;\n                  },\n                  unref: function () {\n                      this.refed = false;\n                      return res;\n                  },\n                  hasRef: function () {\n                      return this.refed;\n                  },\n                  refresh: function () {\n                      timer.callAt =\n                          clock.now +\n                          (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n\n                      // it _might_ have been removed, but if not the assignment is perfectly fine\n                      clock.timers[timer.id] = timer;\n\n                      return res;\n                  },\n                  [Symbol.toPrimitive]: function () {\n                      return timer.id;\n                  },\n              };\n              return res;\n          }\n\n          return timer.id;\n      }\n\n      /* eslint consistent-return: \"off\" */\n      /**\n       * Timer comparitor\n       *\n       * @param {Timer} a\n       * @param {Timer} b\n       * @returns {number}\n       */\n      function compareTimers(a, b) {\n          // Sort first by absolute timing\n          if (a.callAt < b.callAt) {\n              return -1;\n          }\n          if (a.callAt > b.callAt) {\n              return 1;\n          }\n\n          // Sort next by immediate, immediate timers take precedence\n          if (a.immediate && !b.immediate) {\n              return -1;\n          }\n          if (!a.immediate && b.immediate) {\n              return 1;\n          }\n\n          // Sort next by creation time, earlier-created timers take precedence\n          if (a.createdAt < b.createdAt) {\n              return -1;\n          }\n          if (a.createdAt > b.createdAt) {\n              return 1;\n          }\n\n          // Sort next by id, lower-id timers take precedence\n          if (a.id < b.id) {\n              return -1;\n          }\n          if (a.id > b.id) {\n              return 1;\n          }\n\n          // As timer ids are unique, no fallback `0` is necessary\n      }\n\n      /**\n       * @param {Clock} clock\n       * @param {number} from\n       * @param {number} to\n       * @returns {Timer}\n       */\n      function firstTimerInRange(clock, from, to) {\n          const timers = clock.timers;\n          let timer = null;\n          let id, isInRange;\n\n          for (id in timers) {\n              if (timers.hasOwnProperty(id)) {\n                  isInRange = inRange(from, to, timers[id]);\n\n                  if (\n                      isInRange &&\n                      (!timer || compareTimers(timer, timers[id]) === 1)\n                  ) {\n                      timer = timers[id];\n                  }\n              }\n          }\n\n          return timer;\n      }\n\n      /**\n       * @param {Clock} clock\n       * @returns {Timer}\n       */\n      function firstTimer(clock) {\n          const timers = clock.timers;\n          let timer = null;\n          let id;\n\n          for (id in timers) {\n              if (timers.hasOwnProperty(id)) {\n                  if (!timer || compareTimers(timer, timers[id]) === 1) {\n                      timer = timers[id];\n                  }\n              }\n          }\n\n          return timer;\n      }\n\n      /**\n       * @param {Clock} clock\n       * @returns {Timer}\n       */\n      function lastTimer(clock) {\n          const timers = clock.timers;\n          let timer = null;\n          let id;\n\n          for (id in timers) {\n              if (timers.hasOwnProperty(id)) {\n                  if (!timer || compareTimers(timer, timers[id]) === -1) {\n                      timer = timers[id];\n                  }\n              }\n          }\n\n          return timer;\n      }\n\n      /**\n       * @param {Clock} clock\n       * @param {Timer} timer\n       */\n      function callTimer(clock, timer) {\n          if (typeof timer.interval === \"number\") {\n              clock.timers[timer.id].callAt += timer.interval;\n          } else {\n              delete clock.timers[timer.id];\n          }\n\n          if (typeof timer.func === \"function\") {\n              timer.func.apply(null, timer.args);\n          } else {\n              /* eslint no-eval: \"off\" */\n              const eval2 = eval;\n              (function () {\n                  eval2(timer.func);\n              })();\n          }\n      }\n\n      /**\n       * Gets clear handler name for a given timer type\n       *\n       * @param {string} ttype\n       */\n      function getClearHandler(ttype) {\n          if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n              return `cancel${ttype}`;\n          }\n          return `clear${ttype}`;\n      }\n\n      /**\n       * Gets schedule handler name for a given timer type\n       *\n       * @param {string} ttype\n       */\n      function getScheduleHandler(ttype) {\n          if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n              return `request${ttype}`;\n          }\n          return `set${ttype}`;\n      }\n\n      /**\n       * Creates an anonymous function to warn only once\n       */\n      function createWarnOnce() {\n          let calls = 0;\n          return function (msg) {\n              // eslint-disable-next-line\n              !calls++ && console.warn(msg);\n          };\n      }\n      const warnOnce = createWarnOnce();\n\n      /**\n       * @param {Clock} clock\n       * @param {number} timerId\n       * @param {string} ttype\n       */\n      function clearTimer(clock, timerId, ttype) {\n          if (!timerId) {\n              // null appears to be allowed in most browsers, and appears to be\n              // relied upon by some libraries, like Bootstrap carousel\n              return;\n          }\n\n          if (!clock.timers) {\n              clock.timers = {};\n          }\n\n          // in Node, the ID is stored as the primitive value for `Timeout` objects\n          // for `Immediate` objects, no ID exists, so it gets coerced to NaN\n          const id = Number(timerId);\n\n          if (Number.isNaN(id) || id < idCounterStart) {\n              const handlerName = getClearHandler(ttype);\n\n              if (clock.shouldClearNativeTimers === true) {\n                  const nativeHandler = clock[`_${handlerName}`];\n                  return typeof nativeHandler === \"function\"\n                      ? nativeHandler(timerId)\n                      : undefined;\n              }\n              warnOnce(\n                  `FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.` +\n                      \"\\nTo automatically clean-up native timers, use `shouldClearNativeTimers`.\",\n              );\n          }\n\n          if (clock.timers.hasOwnProperty(id)) {\n              // check that the ID matches a timer of the correct type\n              const timer = clock.timers[id];\n              if (\n                  timer.type === ttype ||\n                  (timer.type === \"Timeout\" && ttype === \"Interval\") ||\n                  (timer.type === \"Interval\" && ttype === \"Timeout\")\n              ) {\n                  delete clock.timers[id];\n              } else {\n                  const clear = getClearHandler(ttype);\n                  const schedule = getScheduleHandler(timer.type);\n                  throw new Error(\n                      `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`,\n                  );\n              }\n          }\n      }\n\n      /**\n       * @param {Clock} clock\n       * @param {Config} config\n       * @returns {Timer[]}\n       */\n      function uninstall(clock, config) {\n          let method, i, l;\n          const installedHrTime = \"_hrtime\";\n          const installedNextTick = \"_nextTick\";\n\n          for (i = 0, l = clock.methods.length; i < l; i++) {\n              method = clock.methods[i];\n              if (method === \"hrtime\" && _global.process) {\n                  _global.process.hrtime = clock[installedHrTime];\n              } else if (method === \"nextTick\" && _global.process) {\n                  _global.process.nextTick = clock[installedNextTick];\n              } else if (method === \"performance\") {\n                  const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n                      clock,\n                      `_${method}`,\n                  );\n                  if (\n                      originalPerfDescriptor &&\n                      originalPerfDescriptor.get &&\n                      !originalPerfDescriptor.set\n                  ) {\n                      Object.defineProperty(\n                          _global,\n                          method,\n                          originalPerfDescriptor,\n                      );\n                  } else if (originalPerfDescriptor.configurable) {\n                      _global[method] = clock[`_${method}`];\n                  }\n              } else {\n                  if (_global[method] && _global[method].hadOwnProperty) {\n                      _global[method] = clock[`_${method}`];\n                  } else {\n                      try {\n                          delete _global[method];\n                      } catch (ignore) {\n                          /* eslint no-empty: \"off\" */\n                      }\n                  }\n              }\n              if (clock.timersModuleMethods !== undefined) {\n                  for (let j = 0; j < clock.timersModuleMethods.length; j++) {\n                      const entry = clock.timersModuleMethods[j];\n                      timersModule[entry.methodName] = entry.original;\n                  }\n              }\n              if (clock.timersPromisesModuleMethods !== undefined) {\n                  for (\n                      let j = 0;\n                      j < clock.timersPromisesModuleMethods.length;\n                      j++\n                  ) {\n                      const entry = clock.timersPromisesModuleMethods[j];\n                      timersPromisesModule[entry.methodName] = entry.original;\n                  }\n              }\n          }\n\n          if (config.shouldAdvanceTime === true) {\n              _global.clearInterval(clock.attachedInterval);\n          }\n\n          // Prevent multiple executions which will completely remove these props\n          clock.methods = [];\n\n          for (const [listener, signal] of clock.abortListenerMap.entries()) {\n              signal.removeEventListener(\"abort\", listener);\n              clock.abortListenerMap.delete(listener);\n          }\n\n          // return pending timers, to enable checking what timers remained on uninstall\n          if (!clock.timers) {\n              return [];\n          }\n          return Object.keys(clock.timers).map(function mapper(key) {\n              return clock.timers[key];\n          });\n      }\n\n      /**\n       * @param {object} target the target containing the method to replace\n       * @param {string} method the keyname of the method on the target\n       * @param {Clock} clock\n       */\n      function hijackMethod(target, method, clock) {\n          clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(\n              target,\n              method,\n          );\n          clock[`_${method}`] = target[method];\n\n          if (method === \"Date\") {\n              target[method] = clock[method];\n          } else if (method === \"Intl\") {\n              target[method] = clock[method];\n          } else if (method === \"performance\") {\n              const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n                  target,\n                  method,\n              );\n              // JSDOM has a read only performance field so we have to save/copy it differently\n              if (\n                  originalPerfDescriptor &&\n                  originalPerfDescriptor.get &&\n                  !originalPerfDescriptor.set\n              ) {\n                  Object.defineProperty(\n                      clock,\n                      `_${method}`,\n                      originalPerfDescriptor,\n                  );\n\n                  const perfDescriptor = Object.getOwnPropertyDescriptor(\n                      clock,\n                      method,\n                  );\n                  Object.defineProperty(target, method, perfDescriptor);\n              } else {\n                  target[method] = clock[method];\n              }\n          } else {\n              target[method] = function () {\n                  return clock[method].apply(clock, arguments);\n              };\n\n              Object.defineProperties(\n                  target[method],\n                  Object.getOwnPropertyDescriptors(clock[method]),\n              );\n          }\n\n          target[method].clock = clock;\n      }\n\n      /**\n       * @param {Clock} clock\n       * @param {number} advanceTimeDelta\n       */\n      function doIntervalTick(clock, advanceTimeDelta) {\n          clock.tick(advanceTimeDelta);\n      }\n\n      /**\n       * @typedef {object} Timers\n       * @property {setTimeout} setTimeout\n       * @property {clearTimeout} clearTimeout\n       * @property {setInterval} setInterval\n       * @property {clearInterval} clearInterval\n       * @property {Date} Date\n       * @property {Intl} Intl\n       * @property {SetImmediate=} setImmediate\n       * @property {function(NodeImmediate): void=} clearImmediate\n       * @property {function(number[]):number[]=} hrtime\n       * @property {NextTick=} nextTick\n       * @property {Performance=} performance\n       * @property {RequestAnimationFrame=} requestAnimationFrame\n       * @property {boolean=} queueMicrotask\n       * @property {function(number): void=} cancelAnimationFrame\n       * @property {RequestIdleCallback=} requestIdleCallback\n       * @property {function(number): void=} cancelIdleCallback\n       */\n\n      /** @type {Timers} */\n      const timers = {\n          setTimeout: _global.setTimeout,\n          clearTimeout: _global.clearTimeout,\n          setInterval: _global.setInterval,\n          clearInterval: _global.clearInterval,\n          Date: _global.Date,\n      };\n\n      if (isPresent.setImmediate) {\n          timers.setImmediate = _global.setImmediate;\n      }\n\n      if (isPresent.clearImmediate) {\n          timers.clearImmediate = _global.clearImmediate;\n      }\n\n      if (isPresent.hrtime) {\n          timers.hrtime = _global.process.hrtime;\n      }\n\n      if (isPresent.nextTick) {\n          timers.nextTick = _global.process.nextTick;\n      }\n\n      if (isPresent.performance) {\n          timers.performance = _global.performance;\n      }\n\n      if (isPresent.requestAnimationFrame) {\n          timers.requestAnimationFrame = _global.requestAnimationFrame;\n      }\n\n      if (isPresent.queueMicrotask) {\n          timers.queueMicrotask = _global.queueMicrotask;\n      }\n\n      if (isPresent.cancelAnimationFrame) {\n          timers.cancelAnimationFrame = _global.cancelAnimationFrame;\n      }\n\n      if (isPresent.requestIdleCallback) {\n          timers.requestIdleCallback = _global.requestIdleCallback;\n      }\n\n      if (isPresent.cancelIdleCallback) {\n          timers.cancelIdleCallback = _global.cancelIdleCallback;\n      }\n\n      if (isPresent.Intl) {\n          timers.Intl = _global.Intl;\n      }\n\n      const originalSetTimeout = _global.setImmediate || _global.setTimeout;\n\n      /**\n       * @param {Date|number} [start] the system time - non-integer values are floored\n       * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()\n       * @returns {Clock}\n       */\n      function createClock(start, loopLimit) {\n          // eslint-disable-next-line no-param-reassign\n          start = Math.floor(getEpoch(start));\n          // eslint-disable-next-line no-param-reassign\n          loopLimit = loopLimit || 1000;\n          let nanos = 0;\n          const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]\n\n          const clock = {\n              now: start,\n              Date: createDate(),\n              loopLimit: loopLimit,\n          };\n\n          clock.Date.clock = clock;\n\n          //eslint-disable-next-line jsdoc/require-jsdoc\n          function getTimeToNextFrame() {\n              return 16 - ((clock.now - start) % 16);\n          }\n\n          //eslint-disable-next-line jsdoc/require-jsdoc\n          function hrtime(prev) {\n              const millisSinceStart = clock.now - adjustedSystemTime[0] - start;\n              const secsSinceStart = Math.floor(millisSinceStart / 1000);\n              const remainderInNanos =\n                  (millisSinceStart - secsSinceStart * 1e3) * 1e6 +\n                  nanos -\n                  adjustedSystemTime[1];\n\n              if (Array.isArray(prev)) {\n                  if (prev[1] > 1e9) {\n                      throw new TypeError(\n                          \"Number of nanoseconds can't exceed a billion\",\n                      );\n                  }\n\n                  const oldSecs = prev[0];\n                  let nanoDiff = remainderInNanos - prev[1];\n                  let secDiff = secsSinceStart - oldSecs;\n\n                  if (nanoDiff < 0) {\n                      nanoDiff += 1e9;\n                      secDiff -= 1;\n                  }\n\n                  return [secDiff, nanoDiff];\n              }\n              return [secsSinceStart, remainderInNanos];\n          }\n\n          /**\n           * A high resolution timestamp in milliseconds.\n           *\n           * @typedef {number} DOMHighResTimeStamp\n           */\n\n          /**\n           * performance.now()\n           *\n           * @returns {DOMHighResTimeStamp}\n           */\n          function fakePerformanceNow() {\n              const hrt = hrtime();\n              const millis = hrt[0] * 1000 + hrt[1] / 1e6;\n              return millis;\n          }\n\n          if (isPresent.hrtimeBigint) {\n              hrtime.bigint = function () {\n                  const parts = hrtime();\n                  return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line\n              };\n          }\n\n          if (isPresent.Intl) {\n              clock.Intl = createIntl();\n              clock.Intl.clock = clock;\n          }\n\n          clock.requestIdleCallback = function requestIdleCallback(\n              func,\n              timeout,\n          ) {\n              let timeToNextIdlePeriod = 0;\n\n              if (clock.countTimers() > 0) {\n                  timeToNextIdlePeriod = 50; // const for now\n              }\n\n              const result = addTimer(clock, {\n                  func: func,\n                  args: Array.prototype.slice.call(arguments, 2),\n                  delay:\n                      typeof timeout === \"undefined\"\n                          ? timeToNextIdlePeriod\n                          : Math.min(timeout, timeToNextIdlePeriod),\n                  idleCallback: true,\n              });\n\n              return Number(result);\n          };\n\n          clock.cancelIdleCallback = function cancelIdleCallback(timerId) {\n              return clearTimer(clock, timerId, \"IdleCallback\");\n          };\n\n          clock.setTimeout = function setTimeout(func, timeout) {\n              return addTimer(clock, {\n                  func: func,\n                  args: Array.prototype.slice.call(arguments, 2),\n                  delay: timeout,\n              });\n          };\n          if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n              clock.setTimeout[utilPromisify.custom] =\n                  function promisifiedSetTimeout(timeout, arg) {\n                      return new _global.Promise(function setTimeoutExecutor(\n                          resolve,\n                      ) {\n                          addTimer(clock, {\n                              func: resolve,\n                              args: [arg],\n                              delay: timeout,\n                          });\n                      });\n                  };\n          }\n\n          clock.clearTimeout = function clearTimeout(timerId) {\n              return clearTimer(clock, timerId, \"Timeout\");\n          };\n\n          clock.nextTick = function nextTick(func) {\n              return enqueueJob(clock, {\n                  func: func,\n                  args: Array.prototype.slice.call(arguments, 1),\n                  error: isNearInfiniteLimit ? new Error() : null,\n              });\n          };\n\n          clock.queueMicrotask = function queueMicrotask(func) {\n              return clock.nextTick(func); // explicitly drop additional arguments\n          };\n\n          clock.setInterval = function setInterval(func, timeout) {\n              // eslint-disable-next-line no-param-reassign\n              timeout = parseInt(timeout, 10);\n              return addTimer(clock, {\n                  func: func,\n                  args: Array.prototype.slice.call(arguments, 2),\n                  delay: timeout,\n                  interval: timeout,\n              });\n          };\n\n          clock.clearInterval = function clearInterval(timerId) {\n              return clearTimer(clock, timerId, \"Interval\");\n          };\n\n          if (isPresent.setImmediate) {\n              clock.setImmediate = function setImmediate(func) {\n                  return addTimer(clock, {\n                      func: func,\n                      args: Array.prototype.slice.call(arguments, 1),\n                      immediate: true,\n                  });\n              };\n\n              if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n                  clock.setImmediate[utilPromisify.custom] =\n                      function promisifiedSetImmediate(arg) {\n                          return new _global.Promise(\n                              function setImmediateExecutor(resolve) {\n                                  addTimer(clock, {\n                                      func: resolve,\n                                      args: [arg],\n                                      immediate: true,\n                                  });\n                              },\n                          );\n                      };\n              }\n\n              clock.clearImmediate = function clearImmediate(timerId) {\n                  return clearTimer(clock, timerId, \"Immediate\");\n              };\n          }\n\n          clock.countTimers = function countTimers() {\n              return (\n                  Object.keys(clock.timers || {}).length +\n                  (clock.jobs || []).length\n              );\n          };\n\n          clock.requestAnimationFrame = function requestAnimationFrame(func) {\n              const result = addTimer(clock, {\n                  func: func,\n                  delay: getTimeToNextFrame(),\n                  get args() {\n                      return [fakePerformanceNow()];\n                  },\n                  animation: true,\n              });\n\n              return Number(result);\n          };\n\n          clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {\n              return clearTimer(clock, timerId, \"AnimationFrame\");\n          };\n\n          clock.runMicrotasks = function runMicrotasks() {\n              runJobs(clock);\n          };\n\n          /**\n           * @param {number|string} tickValue milliseconds or a string parseable by parseTime\n           * @param {boolean} isAsync\n           * @param {Function} resolve\n           * @param {Function} reject\n           * @returns {number|undefined} will return the new `now` value or nothing for async\n           */\n          function doTick(tickValue, isAsync, resolve, reject) {\n              const msFloat =\n                  typeof tickValue === \"number\"\n                      ? tickValue\n                      : parseTime(tickValue);\n              const ms = Math.floor(msFloat);\n              const remainder = nanoRemainder(msFloat);\n              let nanosTotal = nanos + remainder;\n              let tickTo = clock.now + ms;\n\n              if (msFloat < 0) {\n                  throw new TypeError(\"Negative ticks are not supported\");\n              }\n\n              // adjust for positive overflow\n              if (nanosTotal >= 1e6) {\n                  tickTo += 1;\n                  nanosTotal -= 1e6;\n              }\n\n              nanos = nanosTotal;\n              let tickFrom = clock.now;\n              let previous = clock.now;\n              // ESLint fails to detect this correctly\n              /* eslint-disable prefer-const */\n              let timer,\n                  firstException,\n                  oldNow,\n                  nextPromiseTick,\n                  compensationCheck,\n                  postTimerCall;\n              /* eslint-enable prefer-const */\n\n              clock.duringTick = true;\n\n              // perform microtasks\n              oldNow = clock.now;\n              runJobs(clock);\n              if (oldNow !== clock.now) {\n                  // compensate for any setSystemTime() call during microtask callback\n                  tickFrom += clock.now - oldNow;\n                  tickTo += clock.now - oldNow;\n              }\n\n              //eslint-disable-next-line jsdoc/require-jsdoc\n              function doTickInner() {\n                  // perform each timer in the requested range\n                  timer = firstTimerInRange(clock, tickFrom, tickTo);\n                  // eslint-disable-next-line no-unmodified-loop-condition\n                  while (timer && tickFrom <= tickTo) {\n                      if (clock.timers[timer.id]) {\n                          tickFrom = timer.callAt;\n                          clock.now = timer.callAt;\n                          oldNow = clock.now;\n                          try {\n                              runJobs(clock);\n                              callTimer(clock, timer);\n                          } catch (e) {\n                              firstException = firstException || e;\n                          }\n\n                          if (isAsync) {\n                              // finish up after native setImmediate callback to allow\n                              // all native es6 promises to process their callbacks after\n                              // each timer fires.\n                              originalSetTimeout(nextPromiseTick);\n                              return;\n                          }\n\n                          compensationCheck();\n                      }\n\n                      postTimerCall();\n                  }\n\n                  // perform process.nextTick()s again\n                  oldNow = clock.now;\n                  runJobs(clock);\n                  if (oldNow !== clock.now) {\n                      // compensate for any setSystemTime() call during process.nextTick() callback\n                      tickFrom += clock.now - oldNow;\n                      tickTo += clock.now - oldNow;\n                  }\n                  clock.duringTick = false;\n\n                  // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]\n                  timer = firstTimerInRange(clock, tickFrom, tickTo);\n                  if (timer) {\n                      try {\n                          clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range\n                      } catch (e) {\n                          firstException = firstException || e;\n                      }\n                  } else {\n                      // no timers remaining in the requested range: move the clock all the way to the end\n                      clock.now = tickTo;\n\n                      // update nanos\n                      nanos = nanosTotal;\n                  }\n                  if (firstException) {\n                      throw firstException;\n                  }\n\n                  if (isAsync) {\n                      resolve(clock.now);\n                  } else {\n                      return clock.now;\n                  }\n              }\n\n              nextPromiseTick =\n                  isAsync &&\n                  function () {\n                      try {\n                          compensationCheck();\n                          postTimerCall();\n                          doTickInner();\n                      } catch (e) {\n                          reject(e);\n                      }\n                  };\n\n              compensationCheck = function () {\n                  // compensate for any setSystemTime() call during timer callback\n                  if (oldNow !== clock.now) {\n                      tickFrom += clock.now - oldNow;\n                      tickTo += clock.now - oldNow;\n                      previous += clock.now - oldNow;\n                  }\n              };\n\n              postTimerCall = function () {\n                  timer = firstTimerInRange(clock, previous, tickTo);\n                  previous = tickFrom;\n              };\n\n              return doTickInner();\n          }\n\n          /**\n           * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n           * @returns {number} will return the new `now` value\n           */\n          clock.tick = function tick(tickValue) {\n              return doTick(tickValue, false);\n          };\n\n          if (typeof _global.Promise !== \"undefined\") {\n              /**\n               * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n               * @returns {Promise}\n               */\n              clock.tickAsync = function tickAsync(tickValue) {\n                  return new _global.Promise(function (resolve, reject) {\n                      originalSetTimeout(function () {\n                          try {\n                              doTick(tickValue, true, resolve, reject);\n                          } catch (e) {\n                              reject(e);\n                          }\n                      });\n                  });\n              };\n          }\n\n          clock.next = function next() {\n              runJobs(clock);\n              const timer = firstTimer(clock);\n              if (!timer) {\n                  return clock.now;\n              }\n\n              clock.duringTick = true;\n              try {\n                  clock.now = timer.callAt;\n                  callTimer(clock, timer);\n                  runJobs(clock);\n                  return clock.now;\n              } finally {\n                  clock.duringTick = false;\n              }\n          };\n\n          if (typeof _global.Promise !== \"undefined\") {\n              clock.nextAsync = function nextAsync() {\n                  return new _global.Promise(function (resolve, reject) {\n                      originalSetTimeout(function () {\n                          try {\n                              const timer = firstTimer(clock);\n                              if (!timer) {\n                                  resolve(clock.now);\n                                  return;\n                              }\n\n                              let err;\n                              clock.duringTick = true;\n                              clock.now = timer.callAt;\n                              try {\n                                  callTimer(clock, timer);\n                              } catch (e) {\n                                  err = e;\n                              }\n                              clock.duringTick = false;\n\n                              originalSetTimeout(function () {\n                                  if (err) {\n                                      reject(err);\n                                  } else {\n                                      resolve(clock.now);\n                                  }\n                              });\n                          } catch (e) {\n                              reject(e);\n                          }\n                      });\n                  });\n              };\n          }\n\n          clock.runAll = function runAll() {\n              let numTimers, i;\n              runJobs(clock);\n              for (i = 0; i < clock.loopLimit; i++) {\n                  if (!clock.timers) {\n                      resetIsNearInfiniteLimit();\n                      return clock.now;\n                  }\n\n                  numTimers = Object.keys(clock.timers).length;\n                  if (numTimers === 0) {\n                      resetIsNearInfiniteLimit();\n                      return clock.now;\n                  }\n\n                  clock.next();\n                  checkIsNearInfiniteLimit(clock, i);\n              }\n\n              const excessJob = firstTimer(clock);\n              throw getInfiniteLoopError(clock, excessJob);\n          };\n\n          clock.runToFrame = function runToFrame() {\n              return clock.tick(getTimeToNextFrame());\n          };\n\n          if (typeof _global.Promise !== \"undefined\") {\n              clock.runAllAsync = function runAllAsync() {\n                  return new _global.Promise(function (resolve, reject) {\n                      let i = 0;\n                      /**\n                       *\n                       */\n                      function doRun() {\n                          originalSetTimeout(function () {\n                              try {\n                                  runJobs(clock);\n\n                                  let numTimers;\n                                  if (i < clock.loopLimit) {\n                                      if (!clock.timers) {\n                                          resetIsNearInfiniteLimit();\n                                          resolve(clock.now);\n                                          return;\n                                      }\n\n                                      numTimers = Object.keys(\n                                          clock.timers,\n                                      ).length;\n                                      if (numTimers === 0) {\n                                          resetIsNearInfiniteLimit();\n                                          resolve(clock.now);\n                                          return;\n                                      }\n\n                                      clock.next();\n\n                                      i++;\n\n                                      doRun();\n                                      checkIsNearInfiniteLimit(clock, i);\n                                      return;\n                                  }\n\n                                  const excessJob = firstTimer(clock);\n                                  reject(getInfiniteLoopError(clock, excessJob));\n                              } catch (e) {\n                                  reject(e);\n                              }\n                          });\n                      }\n                      doRun();\n                  });\n              };\n          }\n\n          clock.runToLast = function runToLast() {\n              const timer = lastTimer(clock);\n              if (!timer) {\n                  runJobs(clock);\n                  return clock.now;\n              }\n\n              return clock.tick(timer.callAt - clock.now);\n          };\n\n          if (typeof _global.Promise !== \"undefined\") {\n              clock.runToLastAsync = function runToLastAsync() {\n                  return new _global.Promise(function (resolve, reject) {\n                      originalSetTimeout(function () {\n                          try {\n                              const timer = lastTimer(clock);\n                              if (!timer) {\n                                  runJobs(clock);\n                                  resolve(clock.now);\n                              }\n\n                              resolve(clock.tickAsync(timer.callAt - clock.now));\n                          } catch (e) {\n                              reject(e);\n                          }\n                      });\n                  });\n              };\n          }\n\n          clock.reset = function reset() {\n              nanos = 0;\n              clock.timers = {};\n              clock.jobs = [];\n              clock.now = start;\n          };\n\n          clock.setSystemTime = function setSystemTime(systemTime) {\n              // determine time difference\n              const newNow = getEpoch(systemTime);\n              const difference = newNow - clock.now;\n              let id, timer;\n\n              adjustedSystemTime[0] = adjustedSystemTime[0] + difference;\n              adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;\n              // update 'system clock'\n              clock.now = newNow;\n              nanos = 0;\n\n              // update timers and intervals to keep them stable\n              for (id in clock.timers) {\n                  if (clock.timers.hasOwnProperty(id)) {\n                      timer = clock.timers[id];\n                      timer.createdAt += difference;\n                      timer.callAt += difference;\n                  }\n              }\n          };\n\n          /**\n           * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n           * @returns {number} will return the new `now` value\n           */\n          clock.jump = function jump(tickValue) {\n              const msFloat =\n                  typeof tickValue === \"number\"\n                      ? tickValue\n                      : parseTime(tickValue);\n              const ms = Math.floor(msFloat);\n\n              for (const timer of Object.values(clock.timers)) {\n                  if (clock.now + ms > timer.callAt) {\n                      timer.callAt = clock.now + ms;\n                  }\n              }\n              clock.tick(ms);\n          };\n\n          if (isPresent.performance) {\n              clock.performance = Object.create(null);\n              clock.performance.now = fakePerformanceNow;\n          }\n\n          if (isPresent.hrtime) {\n              clock.hrtime = hrtime;\n          }\n\n          return clock;\n      }\n\n      /* eslint-disable complexity */\n\n      /**\n       * @param {Config=} [config] Optional config\n       * @returns {Clock}\n       */\n      function install(config) {\n          if (\n              arguments.length > 1 ||\n              config instanceof Date ||\n              Array.isArray(config) ||\n              typeof config === \"number\"\n          ) {\n              throw new TypeError(\n                  `FakeTimers.install called with ${String(\n                    config,\n                )} install requires an object parameter`,\n              );\n          }\n\n          if (_global.Date.isFake === true) {\n              // Timers are already faked; this is a problem.\n              // Make the user reset timers before continuing.\n              throw new TypeError(\n                  \"Can't install fake timers twice on the same global object.\",\n              );\n          }\n\n          // eslint-disable-next-line no-param-reassign\n          config = typeof config !== \"undefined\" ? config : {};\n          config.shouldAdvanceTime = config.shouldAdvanceTime || false;\n          config.advanceTimeDelta = config.advanceTimeDelta || 20;\n          config.shouldClearNativeTimers =\n              config.shouldClearNativeTimers || false;\n\n          if (config.target) {\n              throw new TypeError(\n                  \"config.target is no longer supported. Use `withGlobal(target)` instead.\",\n              );\n          }\n\n          /**\n           * @param {string} timer/object the name of the thing that is not present\n           * @param timer\n           */\n          function handleMissingTimer(timer) {\n              if (config.ignoreMissingTimers) {\n                  return;\n              }\n\n              throw new ReferenceError(\n                  `non-existent timers and/or objects cannot be faked: '${timer}'`,\n              );\n          }\n\n          let i, l;\n          const clock = createClock(config.now, config.loopLimit);\n          clock.shouldClearNativeTimers = config.shouldClearNativeTimers;\n\n          clock.uninstall = function () {\n              return uninstall(clock, config);\n          };\n\n          clock.abortListenerMap = new Map();\n\n          clock.methods = config.toFake || [];\n\n          if (clock.methods.length === 0) {\n              clock.methods = Object.keys(timers);\n          }\n\n          if (config.shouldAdvanceTime === true) {\n              const intervalTick = doIntervalTick.bind(\n                  null,\n                  clock,\n                  config.advanceTimeDelta,\n              );\n              const intervalId = _global.setInterval(\n                  intervalTick,\n                  config.advanceTimeDelta,\n              );\n              clock.attachedInterval = intervalId;\n          }\n\n          if (clock.methods.includes(\"performance\")) {\n              const proto = (() => {\n                  if (hasPerformanceConstructorPrototype) {\n                      return _global.performance.constructor.prototype;\n                  }\n                  if (hasPerformancePrototype) {\n                      return _global.Performance.prototype;\n                  }\n              })();\n              if (proto) {\n                  Object.getOwnPropertyNames(proto).forEach(function (name) {\n                      if (name !== \"now\") {\n                          clock.performance[name] =\n                              name.indexOf(\"getEntries\") === 0\n                                  ? NOOP_ARRAY\n                                  : NOOP;\n                      }\n                  });\n                  // ensure `mark` returns a value that is valid\n                  clock.performance.mark = (name) =>\n                      new FakePerformanceEntry(name, \"mark\", 0, 0);\n                  clock.performance.measure = (name) =>\n                      new FakePerformanceEntry(name, \"measure\", 0, 100);\n              } else if ((config.toFake || []).includes(\"performance\")) {\n                  return handleMissingTimer(\"performance\");\n              }\n          }\n          if (_global === globalObject && timersModule) {\n              clock.timersModuleMethods = [];\n          }\n          if (_global === globalObject && timersPromisesModule) {\n              clock.timersPromisesModuleMethods = [];\n          }\n          for (i = 0, l = clock.methods.length; i < l; i++) {\n              const nameOfMethodToReplace = clock.methods[i];\n\n              if (!isPresent[nameOfMethodToReplace]) {\n                  handleMissingTimer(nameOfMethodToReplace);\n                  // eslint-disable-next-line\n                  continue;\n              }\n\n              if (nameOfMethodToReplace === \"hrtime\") {\n                  if (\n                      _global.process &&\n                      typeof _global.process.hrtime === \"function\"\n                  ) {\n                      hijackMethod(_global.process, nameOfMethodToReplace, clock);\n                  }\n              } else if (nameOfMethodToReplace === \"nextTick\") {\n                  if (\n                      _global.process &&\n                      typeof _global.process.nextTick === \"function\"\n                  ) {\n                      hijackMethod(_global.process, nameOfMethodToReplace, clock);\n                  }\n              } else {\n                  hijackMethod(_global, nameOfMethodToReplace, clock);\n              }\n              if (\n                  clock.timersModuleMethods !== undefined &&\n                  timersModule[nameOfMethodToReplace]\n              ) {\n                  const original = timersModule[nameOfMethodToReplace];\n                  clock.timersModuleMethods.push({\n                      methodName: nameOfMethodToReplace,\n                      original: original,\n                  });\n                  timersModule[nameOfMethodToReplace] =\n                      _global[nameOfMethodToReplace];\n              }\n              if (clock.timersPromisesModuleMethods !== undefined) {\n                  if (nameOfMethodToReplace === \"setTimeout\") {\n                      clock.timersPromisesModuleMethods.push({\n                          methodName: \"setTimeout\",\n                          original: timersPromisesModule.setTimeout,\n                      });\n\n                      timersPromisesModule.setTimeout = (\n                          delay,\n                          value,\n                          options = {},\n                      ) =>\n                          new Promise((resolve, reject) => {\n                              const abort = () => {\n                                  options.signal.removeEventListener(\n                                      \"abort\",\n                                      abort,\n                                  );\n                                  clock.abortListenerMap.delete(abort);\n\n                                  // This is safe, there is no code path that leads to this function\n                                  // being invoked before handle has been assigned.\n                                  // eslint-disable-next-line no-use-before-define\n                                  clock.clearTimeout(handle);\n                                  reject(options.signal.reason);\n                              };\n\n                              const handle = clock.setTimeout(() => {\n                                  if (options.signal) {\n                                      options.signal.removeEventListener(\n                                          \"abort\",\n                                          abort,\n                                      );\n                                      clock.abortListenerMap.delete(abort);\n                                  }\n\n                                  resolve(value);\n                              }, delay);\n\n                              if (options.signal) {\n                                  if (options.signal.aborted) {\n                                      abort();\n                                  } else {\n                                      options.signal.addEventListener(\n                                          \"abort\",\n                                          abort,\n                                      );\n                                      clock.abortListenerMap.set(\n                                          abort,\n                                          options.signal,\n                                      );\n                                  }\n                              }\n                          });\n                  } else if (nameOfMethodToReplace === \"setImmediate\") {\n                      clock.timersPromisesModuleMethods.push({\n                          methodName: \"setImmediate\",\n                          original: timersPromisesModule.setImmediate,\n                      });\n\n                      timersPromisesModule.setImmediate = (value, options = {}) =>\n                          new Promise((resolve, reject) => {\n                              const abort = () => {\n                                  options.signal.removeEventListener(\n                                      \"abort\",\n                                      abort,\n                                  );\n                                  clock.abortListenerMap.delete(abort);\n\n                                  // This is safe, there is no code path that leads to this function\n                                  // being invoked before handle has been assigned.\n                                  // eslint-disable-next-line no-use-before-define\n                                  clock.clearImmediate(handle);\n                                  reject(options.signal.reason);\n                              };\n\n                              const handle = clock.setImmediate(() => {\n                                  if (options.signal) {\n                                      options.signal.removeEventListener(\n                                          \"abort\",\n                                          abort,\n                                      );\n                                      clock.abortListenerMap.delete(abort);\n                                  }\n\n                                  resolve(value);\n                              });\n\n                              if (options.signal) {\n                                  if (options.signal.aborted) {\n                                      abort();\n                                  } else {\n                                      options.signal.addEventListener(\n                                          \"abort\",\n                                          abort,\n                                      );\n                                      clock.abortListenerMap.set(\n                                          abort,\n                                          options.signal,\n                                      );\n                                  }\n                              }\n                          });\n                  } else if (nameOfMethodToReplace === \"setInterval\") {\n                      clock.timersPromisesModuleMethods.push({\n                          methodName: \"setInterval\",\n                          original: timersPromisesModule.setInterval,\n                      });\n\n                      timersPromisesModule.setInterval = (\n                          delay,\n                          value,\n                          options = {},\n                      ) => ({\n                          [Symbol.asyncIterator]: () => {\n                              const createResolvable = () => {\n                                  let resolve, reject;\n                                  const promise = new Promise((res, rej) => {\n                                      resolve = res;\n                                      reject = rej;\n                                  });\n                                  promise.resolve = resolve;\n                                  promise.reject = reject;\n                                  return promise;\n                              };\n\n                              let done = false;\n                              let hasThrown = false;\n                              let returnCall;\n                              let nextAvailable = 0;\n                              const nextQueue = [];\n\n                              const handle = clock.setInterval(() => {\n                                  if (nextQueue.length > 0) {\n                                      nextQueue.shift().resolve();\n                                  } else {\n                                      nextAvailable++;\n                                  }\n                              }, delay);\n\n                              const abort = () => {\n                                  options.signal.removeEventListener(\n                                      \"abort\",\n                                      abort,\n                                  );\n                                  clock.abortListenerMap.delete(abort);\n\n                                  clock.clearInterval(handle);\n                                  done = true;\n                                  for (const resolvable of nextQueue) {\n                                      resolvable.resolve();\n                                  }\n                              };\n\n                              if (options.signal) {\n                                  if (options.signal.aborted) {\n                                      done = true;\n                                  } else {\n                                      options.signal.addEventListener(\n                                          \"abort\",\n                                          abort,\n                                      );\n                                      clock.abortListenerMap.set(\n                                          abort,\n                                          options.signal,\n                                      );\n                                  }\n                              }\n\n                              return {\n                                  next: async () => {\n                                      if (options.signal?.aborted && !hasThrown) {\n                                          hasThrown = true;\n                                          throw options.signal.reason;\n                                      }\n\n                                      if (done) {\n                                          return { done: true, value: undefined };\n                                      }\n\n                                      if (nextAvailable > 0) {\n                                          nextAvailable--;\n                                          return { done: false, value: value };\n                                      }\n\n                                      const resolvable = createResolvable();\n                                      nextQueue.push(resolvable);\n\n                                      await resolvable;\n\n                                      if (returnCall && nextQueue.length === 0) {\n                                          returnCall.resolve();\n                                      }\n\n                                      if (options.signal?.aborted && !hasThrown) {\n                                          hasThrown = true;\n                                          throw options.signal.reason;\n                                      }\n\n                                      if (done) {\n                                          return { done: true, value: undefined };\n                                      }\n\n                                      return { done: false, value: value };\n                                  },\n                                  return: async () => {\n                                      if (done) {\n                                          return { done: true, value: undefined };\n                                      }\n\n                                      if (nextQueue.length > 0) {\n                                          returnCall = createResolvable();\n                                          await returnCall;\n                                      }\n\n                                      clock.clearInterval(handle);\n                                      done = true;\n\n                                      if (options.signal) {\n                                          options.signal.removeEventListener(\n                                              \"abort\",\n                                              abort,\n                                          );\n                                          clock.abortListenerMap.delete(abort);\n                                      }\n\n                                      return { done: true, value: undefined };\n                                  },\n                              };\n                          },\n                      });\n                  }\n              }\n          }\n\n          return clock;\n      }\n\n      /* eslint-enable complexity */\n\n      return {\n          timers: timers,\n          createClock: createClock,\n          install: install,\n          withGlobal: withGlobal,\n      };\n  }\n\n  /**\n   * @typedef {object} FakeTimers\n   * @property {Timers} timers\n   * @property {createClock} createClock\n   * @property {Function} install\n   * @property {withGlobal} withGlobal\n   */\n\n  /* eslint-enable complexity */\n\n  /** @type {FakeTimers} */\n  const defaultImplementation = withGlobal(globalObject);\n\n  exports.timers = defaultImplementation.timers;\n  exports.createClock = defaultImplementation.createClock;\n  exports.install = defaultImplementation.install;\n  exports.withGlobal = withGlobal;\n\n  },{\"@sinonjs/commons\":47,\"timers\":undefined,\"timers/promises\":undefined,\"util\":91}],61:[function(require,module,exports){\n\n  var ARRAY_TYPES = [\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n  ];\n\n  module.exports = ARRAY_TYPES;\n\n  },{}],62:[function(require,module,exports){\n\n  var arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  var deepEqual = require(\"./deep-equal\").use(createMatcher); // eslint-disable-line no-use-before-define\n  var every = require(\"@sinonjs/commons\").every;\n  var functionName = require(\"@sinonjs/commons\").functionName;\n  var get = require(\"lodash.get\");\n  var iterableToString = require(\"./iterable-to-string\");\n  var objectProto = require(\"@sinonjs/commons\").prototypes.object;\n  var typeOf = require(\"@sinonjs/commons\").typeOf;\n  var valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  var assertMatcher = require(\"./create-matcher/assert-matcher\");\n  var assertMethodExists = require(\"./create-matcher/assert-method-exists\");\n  var assertType = require(\"./create-matcher/assert-type\");\n  var isIterable = require(\"./create-matcher/is-iterable\");\n  var isMatcher = require(\"./create-matcher/is-matcher\");\n\n  var matcherPrototype = require(\"./create-matcher/matcher-prototype\");\n\n  var arrayIndexOf = arrayProto.indexOf;\n  var some = arrayProto.some;\n\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  var objectToString = objectProto.toString;\n\n  var TYPE_MAP = require(\"./create-matcher/type-map\")(createMatcher); // eslint-disable-line no-use-before-define\n\n  /**\n   * Creates a matcher object for the passed expectation\n   *\n   * @alias module:samsam.createMatcher\n   * @param {*} expectation An expecttation\n   * @param {string} message A message for the expectation\n   * @returns {object} A matcher object\n   */\n  function createMatcher(expectation, message) {\n      var m = Object.create(matcherPrototype);\n      var type = typeOf(expectation);\n\n      if (message !== undefined && typeof message !== \"string\") {\n          throw new TypeError(\"Message should be a string\");\n      }\n\n      if (arguments.length > 2) {\n          throw new TypeError(\n              `Expected 1 or 2 arguments, received ${arguments.length}`,\n          );\n      }\n\n      if (type in TYPE_MAP) {\n          TYPE_MAP[type](m, expectation, message);\n      } else {\n          m.test = function (actual) {\n              return deepEqual(actual, expectation);\n          };\n      }\n\n      if (!m.message) {\n          m.message = `match(${valueToString(expectation)})`;\n      }\n\n      // ensure that nothing mutates the exported message value, ref https://github.com/sinonjs/sinon/issues/2502\n      Object.defineProperty(m, \"message\", {\n          configurable: false,\n          writable: false,\n          value: m.message,\n      });\n\n      return m;\n  }\n\n  createMatcher.isMatcher = isMatcher;\n\n  createMatcher.any = createMatcher(function () {\n      return true;\n  }, \"any\");\n\n  createMatcher.defined = createMatcher(function (actual) {\n      return actual !== null && actual !== undefined;\n  }, \"defined\");\n\n  createMatcher.truthy = createMatcher(function (actual) {\n      return Boolean(actual);\n  }, \"truthy\");\n\n  createMatcher.falsy = createMatcher(function (actual) {\n      return !actual;\n  }, \"falsy\");\n\n  createMatcher.same = function (expectation) {\n      return createMatcher(\n          function (actual) {\n              return expectation === actual;\n          },\n          `same(${valueToString(expectation)})`,\n      );\n  };\n\n  createMatcher.in = function (arrayOfExpectations) {\n      if (typeOf(arrayOfExpectations) !== \"array\") {\n          throw new TypeError(\"array expected\");\n      }\n\n      return createMatcher(\n          function (actual) {\n              return some(arrayOfExpectations, function (expectation) {\n                  return expectation === actual;\n              });\n          },\n          `in(${valueToString(arrayOfExpectations)})`,\n      );\n  };\n\n  createMatcher.typeOf = function (type) {\n      assertType(type, \"string\", \"type\");\n      return createMatcher(function (actual) {\n          return typeOf(actual) === type;\n      }, `typeOf(\"${type}\")`);\n  };\n\n  createMatcher.instanceOf = function (type) {\n      /* istanbul ignore if */\n      if (\n          typeof Symbol === \"undefined\" ||\n          typeof Symbol.hasInstance === \"undefined\"\n      ) {\n          assertType(type, \"function\", \"type\");\n      } else {\n          assertMethodExists(\n              type,\n              Symbol.hasInstance,\n              \"type\",\n              \"[Symbol.hasInstance]\",\n          );\n      }\n      return createMatcher(\n          function (actual) {\n              return actual instanceof type;\n          },\n          `instanceOf(${functionName(type) || objectToString(type)})`,\n      );\n  };\n\n  /**\n   * Creates a property matcher\n   *\n   * @private\n   * @param {Function} propertyTest A function to test the property against a value\n   * @param {string} messagePrefix A prefix to use for messages generated by the matcher\n   * @returns {object} A matcher\n   */\n  function createPropertyMatcher(propertyTest, messagePrefix) {\n      return function (property, value) {\n          assertType(property, \"string\", \"property\");\n          var onlyProperty = arguments.length === 1;\n          var message = `${messagePrefix}(\"${property}\"`;\n          if (!onlyProperty) {\n              message += `, ${valueToString(value)}`;\n          }\n          message += \")\";\n          return createMatcher(function (actual) {\n              if (\n                  actual === undefined ||\n                  actual === null ||\n                  !propertyTest(actual, property)\n              ) {\n                  return false;\n              }\n              return onlyProperty || deepEqual(actual[property], value);\n          }, message);\n      };\n  }\n\n  createMatcher.has = createPropertyMatcher(function (actual, property) {\n      if (typeof actual === \"object\") {\n          return property in actual;\n      }\n      return actual[property] !== undefined;\n  }, \"has\");\n\n  createMatcher.hasOwn = createPropertyMatcher(function (actual, property) {\n      return hasOwnProperty(actual, property);\n  }, \"hasOwn\");\n\n  createMatcher.hasNested = function (property, value) {\n      assertType(property, \"string\", \"property\");\n      var onlyProperty = arguments.length === 1;\n      var message = `hasNested(\"${property}\"`;\n      if (!onlyProperty) {\n          message += `, ${valueToString(value)}`;\n      }\n      message += \")\";\n      return createMatcher(function (actual) {\n          if (\n              actual === undefined ||\n              actual === null ||\n              get(actual, property) === undefined\n          ) {\n              return false;\n          }\n          return onlyProperty || deepEqual(get(actual, property), value);\n      }, message);\n  };\n\n  var jsonParseResultTypes = {\n      null: true,\n      boolean: true,\n      number: true,\n      string: true,\n      object: true,\n      array: true,\n  };\n  createMatcher.json = function (value) {\n      if (!jsonParseResultTypes[typeOf(value)]) {\n          throw new TypeError(\"Value cannot be the result of JSON.parse\");\n      }\n      var message = `json(${JSON.stringify(value, null, \"  \")})`;\n      return createMatcher(function (actual) {\n          var parsed;\n          try {\n              parsed = JSON.parse(actual);\n          } catch (e) {\n              return false;\n          }\n          return deepEqual(parsed, value);\n      }, message);\n  };\n\n  createMatcher.every = function (predicate) {\n      assertMatcher(predicate);\n\n      return createMatcher(function (actual) {\n          if (typeOf(actual) === \"object\") {\n              return every(Object.keys(actual), function (key) {\n                  return predicate.test(actual[key]);\n              });\n          }\n\n          return (\n              isIterable(actual) &&\n              every(actual, function (element) {\n                  return predicate.test(element);\n              })\n          );\n      }, `every(${predicate.message})`);\n  };\n\n  createMatcher.some = function (predicate) {\n      assertMatcher(predicate);\n\n      return createMatcher(function (actual) {\n          if (typeOf(actual) === \"object\") {\n              return !every(Object.keys(actual), function (key) {\n                  return !predicate.test(actual[key]);\n              });\n          }\n\n          return (\n              isIterable(actual) &&\n              !every(actual, function (element) {\n                  return !predicate.test(element);\n              })\n          );\n      }, `some(${predicate.message})`);\n  };\n\n  createMatcher.array = createMatcher.typeOf(\"array\");\n\n  createMatcher.array.deepEquals = function (expectation) {\n      return createMatcher(\n          function (actual) {\n              // Comparing lengths is the fastest way to spot a difference before iterating through every item\n              var sameLength = actual.length === expectation.length;\n              return (\n                  typeOf(actual) === \"array\" &&\n                  sameLength &&\n                  every(actual, function (element, index) {\n                      var expected = expectation[index];\n                      return typeOf(expected) === \"array\" &&\n                          typeOf(element) === \"array\"\n                          ? createMatcher.array.deepEquals(expected).test(element)\n                          : deepEqual(expected, element);\n                  })\n              );\n          },\n          `deepEquals([${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.array.startsWith = function (expectation) {\n      return createMatcher(\n          function (actual) {\n              return (\n                  typeOf(actual) === \"array\" &&\n                  every(expectation, function (expectedElement, index) {\n                      return actual[index] === expectedElement;\n                  })\n              );\n          },\n          `startsWith([${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.array.endsWith = function (expectation) {\n      return createMatcher(\n          function (actual) {\n              // This indicates the index in which we should start matching\n              var offset = actual.length - expectation.length;\n\n              return (\n                  typeOf(actual) === \"array\" &&\n                  every(expectation, function (expectedElement, index) {\n                      return actual[offset + index] === expectedElement;\n                  })\n              );\n          },\n          `endsWith([${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.array.contains = function (expectation) {\n      return createMatcher(\n          function (actual) {\n              return (\n                  typeOf(actual) === \"array\" &&\n                  every(expectation, function (expectedElement) {\n                      return arrayIndexOf(actual, expectedElement) !== -1;\n                  })\n              );\n          },\n          `contains([${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.map = createMatcher.typeOf(\"map\");\n\n  createMatcher.map.deepEquals = function mapDeepEquals(expectation) {\n      return createMatcher(\n          function (actual) {\n              // Comparing lengths is the fastest way to spot a difference before iterating through every item\n              var sameLength = actual.size === expectation.size;\n              return (\n                  typeOf(actual) === \"map\" &&\n                  sameLength &&\n                  every(actual, function (element, key) {\n                      return (\n                          expectation.has(key) && expectation.get(key) === element\n                      );\n                  })\n              );\n          },\n          `deepEquals(Map[${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.map.contains = function mapContains(expectation) {\n      return createMatcher(\n          function (actual) {\n              return (\n                  typeOf(actual) === \"map\" &&\n                  every(expectation, function (element, key) {\n                      return actual.has(key) && actual.get(key) === element;\n                  })\n              );\n          },\n          `contains(Map[${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.set = createMatcher.typeOf(\"set\");\n\n  createMatcher.set.deepEquals = function setDeepEquals(expectation) {\n      return createMatcher(\n          function (actual) {\n              // Comparing lengths is the fastest way to spot a difference before iterating through every item\n              var sameLength = actual.size === expectation.size;\n              return (\n                  typeOf(actual) === \"set\" &&\n                  sameLength &&\n                  every(actual, function (element) {\n                      return expectation.has(element);\n                  })\n              );\n          },\n          `deepEquals(Set[${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.set.contains = function setContains(expectation) {\n      return createMatcher(\n          function (actual) {\n              return (\n                  typeOf(actual) === \"set\" &&\n                  every(expectation, function (element) {\n                      return actual.has(element);\n                  })\n              );\n          },\n          `contains(Set[${iterableToString(expectation)}])`,\n      );\n  };\n\n  createMatcher.bool = createMatcher.typeOf(\"boolean\");\n  createMatcher.number = createMatcher.typeOf(\"number\");\n  createMatcher.string = createMatcher.typeOf(\"string\");\n  createMatcher.object = createMatcher.typeOf(\"object\");\n  createMatcher.func = createMatcher.typeOf(\"function\");\n  createMatcher.regexp = createMatcher.typeOf(\"regexp\");\n  createMatcher.date = createMatcher.typeOf(\"date\");\n  createMatcher.symbol = createMatcher.typeOf(\"symbol\");\n\n  module.exports = createMatcher;\n\n  },{\"./create-matcher/assert-matcher\":63,\"./create-matcher/assert-method-exists\":64,\"./create-matcher/assert-type\":65,\"./create-matcher/is-iterable\":66,\"./create-matcher/is-matcher\":67,\"./create-matcher/matcher-prototype\":69,\"./create-matcher/type-map\":70,\"./deep-equal\":71,\"./iterable-to-string\":85,\"@sinonjs/commons\":47,\"lodash.get\":93}],63:[function(require,module,exports){\n\n  var isMatcher = require(\"./is-matcher\");\n\n  /**\n   * Throws a TypeError when `value` is not a matcher\n   *\n   * @private\n   * @param {*} value The value to examine\n   */\n  function assertMatcher(value) {\n      if (!isMatcher(value)) {\n          throw new TypeError(\"Matcher expected\");\n      }\n  }\n\n  module.exports = assertMatcher;\n\n  },{\"./is-matcher\":67}],64:[function(require,module,exports){\n\n  /**\n   * Throws a TypeError when expected method doesn't exist\n   *\n   * @private\n   * @param {*} value A value to examine\n   * @param {string} method The name of the method to look for\n   * @param {name} name A name to use for the error message\n   * @param {string} methodPath The name of the method to use for error messages\n   * @throws {TypeError} When the method doesn't exist\n   */\n  function assertMethodExists(value, method, name, methodPath) {\n      if (value[method] === null || value[method] === undefined) {\n          throw new TypeError(`Expected ${name} to have method ${methodPath}`);\n      }\n  }\n\n  module.exports = assertMethodExists;\n\n  },{}],65:[function(require,module,exports){\n\n  var typeOf = require(\"@sinonjs/commons\").typeOf;\n\n  /**\n   * Ensures that value is of type\n   *\n   * @private\n   * @param {*} value A value to examine\n   * @param {string} type A basic JavaScript type to compare to, e.g. \"object\", \"string\"\n   * @param {string} name A string to use for the error message\n   * @throws {TypeError} If value is not of the expected type\n   * @returns {undefined}\n   */\n  function assertType(value, type, name) {\n      var actual = typeOf(value);\n      if (actual !== type) {\n          throw new TypeError(\n              `Expected type of ${name} to be ${type}, but was ${actual}`,\n          );\n      }\n  }\n\n  module.exports = assertType;\n\n  },{\"@sinonjs/commons\":47}],66:[function(require,module,exports){\n\n  var typeOf = require(\"@sinonjs/commons\").typeOf;\n\n  /**\n   * Returns `true` for iterables\n   *\n   * @private\n   * @param {*} value A value to examine\n   * @returns {boolean} Returns `true` when `value` looks like an iterable\n   */\n  function isIterable(value) {\n      return Boolean(value) && typeOf(value.forEach) === \"function\";\n  }\n\n  module.exports = isIterable;\n\n  },{\"@sinonjs/commons\":47}],67:[function(require,module,exports){\n\n  var isPrototypeOf = require(\"@sinonjs/commons\").prototypes.object.isPrototypeOf;\n\n  var matcherPrototype = require(\"./matcher-prototype\");\n\n  /**\n   * Returns `true` when `object` is a matcher\n   *\n   * @private\n   * @param {*} object A value to examine\n   * @returns {boolean} Returns `true` when `object` is a matcher\n   */\n  function isMatcher(object) {\n      return isPrototypeOf(matcherPrototype, object);\n  }\n\n  module.exports = isMatcher;\n\n  },{\"./matcher-prototype\":69,\"@sinonjs/commons\":47}],68:[function(require,module,exports){\n\n  var every = require(\"@sinonjs/commons\").prototypes.array.every;\n  var concat = require(\"@sinonjs/commons\").prototypes.array.concat;\n  var typeOf = require(\"@sinonjs/commons\").typeOf;\n\n  var deepEqualFactory = require(\"../deep-equal\").use;\n\n  var identical = require(\"../identical\");\n  var isMatcher = require(\"./is-matcher\");\n\n  var keys = Object.keys;\n  var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\n  /**\n   * Matches `actual` with `expectation`\n   *\n   * @private\n   * @param {*} actual A value to examine\n   * @param {object} expectation An object with properties to match on\n   * @param {object} matcher A matcher to use for comparison\n   * @returns {boolean} Returns true when `actual` matches all properties in `expectation`\n   */\n  function matchObject(actual, expectation, matcher) {\n      var deepEqual = deepEqualFactory(matcher);\n      if (actual === null || actual === undefined) {\n          return false;\n      }\n\n      var expectedKeys = keys(expectation);\n      /* istanbul ignore else: cannot collect coverage for engine that doesn't support Symbol */\n      if (typeOf(getOwnPropertySymbols) === \"function\") {\n          expectedKeys = concat(expectedKeys, getOwnPropertySymbols(expectation));\n      }\n\n      return every(expectedKeys, function (key) {\n          var exp = expectation[key];\n          var act = actual[key];\n\n          if (isMatcher(exp)) {\n              if (!exp.test(act)) {\n                  return false;\n              }\n          } else if (typeOf(exp) === \"object\") {\n              if (identical(exp, act)) {\n                  return true;\n              }\n              if (!matchObject(act, exp, matcher)) {\n                  return false;\n              }\n          } else if (!deepEqual(act, exp)) {\n              return false;\n          }\n\n          return true;\n      });\n  }\n\n  module.exports = matchObject;\n\n  },{\"../deep-equal\":71,\"../identical\":73,\"./is-matcher\":67,\"@sinonjs/commons\":47}],69:[function(require,module,exports){\n\n  var matcherPrototype = {\n      toString: function () {\n          return this.message;\n      },\n  };\n\n  matcherPrototype.or = function (valueOrMatcher) {\n      var createMatcher = require(\"../create-matcher\");\n      var isMatcher = createMatcher.isMatcher;\n\n      if (!arguments.length) {\n          throw new TypeError(\"Matcher expected\");\n      }\n\n      var m2 = isMatcher(valueOrMatcher)\n          ? valueOrMatcher\n          : createMatcher(valueOrMatcher);\n      var m1 = this;\n      var or = Object.create(matcherPrototype);\n      or.test = function (actual) {\n          return m1.test(actual) || m2.test(actual);\n      };\n      or.message = `${m1.message}.or(${m2.message})`;\n      return or;\n  };\n\n  matcherPrototype.and = function (valueOrMatcher) {\n      var createMatcher = require(\"../create-matcher\");\n      var isMatcher = createMatcher.isMatcher;\n\n      if (!arguments.length) {\n          throw new TypeError(\"Matcher expected\");\n      }\n\n      var m2 = isMatcher(valueOrMatcher)\n          ? valueOrMatcher\n          : createMatcher(valueOrMatcher);\n      var m1 = this;\n      var and = Object.create(matcherPrototype);\n      and.test = function (actual) {\n          return m1.test(actual) && m2.test(actual);\n      };\n      and.message = `${m1.message}.and(${m2.message})`;\n      return and;\n  };\n\n  module.exports = matcherPrototype;\n\n  },{\"../create-matcher\":62}],70:[function(require,module,exports){\n\n  var functionName = require(\"@sinonjs/commons\").functionName;\n  var join = require(\"@sinonjs/commons\").prototypes.array.join;\n  var map = require(\"@sinonjs/commons\").prototypes.array.map;\n  var stringIndexOf = require(\"@sinonjs/commons\").prototypes.string.indexOf;\n  var valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  var matchObject = require(\"./match-object\");\n\n  var createTypeMap = function (match) {\n      return {\n          function: function (m, expectation, message) {\n              m.test = expectation;\n              m.message = message || `match(${functionName(expectation)})`;\n          },\n          number: function (m, expectation) {\n              m.test = function (actual) {\n                  // we need type coercion here\n                  return expectation == actual; // eslint-disable-line eqeqeq\n              };\n          },\n          object: function (m, expectation) {\n              var array = [];\n\n              if (typeof expectation.test === \"function\") {\n                  m.test = function (actual) {\n                      return expectation.test(actual) === true;\n                  };\n                  m.message = `match(${functionName(expectation.test)})`;\n                  return m;\n              }\n\n              array = map(Object.keys(expectation), function (key) {\n                  return `${key}: ${valueToString(expectation[key])}`;\n              });\n\n              m.test = function (actual) {\n                  return matchObject(actual, expectation, match);\n              };\n              m.message = `match(${join(array, \", \")})`;\n\n              return m;\n          },\n          regexp: function (m, expectation) {\n              m.test = function (actual) {\n                  return typeof actual === \"string\" && expectation.test(actual);\n              };\n          },\n          string: function (m, expectation) {\n              m.test = function (actual) {\n                  return (\n                      typeof actual === \"string\" &&\n                      stringIndexOf(actual, expectation) !== -1\n                  );\n              };\n              m.message = `match(\"${expectation}\")`;\n          },\n      };\n  };\n\n  module.exports = createTypeMap;\n\n  },{\"./match-object\":68,\"@sinonjs/commons\":47}],71:[function(require,module,exports){\n\n  var valueToString = require(\"@sinonjs/commons\").valueToString;\n  var className = require(\"@sinonjs/commons\").className;\n  var typeOf = require(\"@sinonjs/commons\").typeOf;\n  var arrayProto = require(\"@sinonjs/commons\").prototypes.array;\n  var objectProto = require(\"@sinonjs/commons\").prototypes.object;\n  var mapForEach = require(\"@sinonjs/commons\").prototypes.map.forEach;\n\n  var getClass = require(\"./get-class\");\n  var identical = require(\"./identical\");\n  var isArguments = require(\"./is-arguments\");\n  var isArrayType = require(\"./is-array-type\");\n  var isDate = require(\"./is-date\");\n  var isElement = require(\"./is-element\");\n  var isIterable = require(\"./is-iterable\");\n  var isMap = require(\"./is-map\");\n  var isNaN = require(\"./is-nan\");\n  var isObject = require(\"./is-object\");\n  var isSet = require(\"./is-set\");\n  var isSubset = require(\"./is-subset\");\n\n  var concat = arrayProto.concat;\n  var every = arrayProto.every;\n  var push = arrayProto.push;\n\n  var getTime = Date.prototype.getTime;\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  var indexOf = arrayProto.indexOf;\n  var keys = Object.keys;\n  var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\n  /**\n   * Deep equal comparison. Two values are \"deep equal\" when:\n   *\n   *   - They are equal, according to samsam.identical\n   *   - They are both date objects representing the same time\n   *   - They are both arrays containing elements that are all deepEqual\n   *   - They are objects with the same set of properties, and each property\n   *     in ``actual`` is deepEqual to the corresponding property in ``expectation``\n   *\n   * Supports cyclic objects.\n   *\n   * @alias module:samsam.deepEqual\n   * @param {*} actual The object to examine\n   * @param {*} expectation The object actual is expected to be equal to\n   * @param {object} match A value to match on\n   * @returns {boolean} Returns true when actual and expectation are considered equal\n   */\n  function deepEqualCyclic(actual, expectation, match) {\n      // used for cyclic comparison\n      // contain already visited objects\n      var actualObjects = [];\n      var expectationObjects = [];\n      // contain pathes (position in the object structure)\n      // of the already visited objects\n      // indexes same as in objects arrays\n      var actualPaths = [];\n      var expectationPaths = [];\n      // contains combinations of already compared objects\n      // in the manner: { \"$1['ref']$2['ref']\": true }\n      var compared = {};\n\n      // does the recursion for the deep equal check\n      // eslint-disable-next-line complexity\n      return (function deepEqual(\n          actualObj,\n          expectationObj,\n          actualPath,\n          expectationPath,\n      ) {\n          // If both are matchers they must be the same instance in order to be\n          // considered equal If we didn't do that we would end up running one\n          // matcher against the other\n          if (match && match.isMatcher(expectationObj)) {\n              if (match.isMatcher(actualObj)) {\n                  return actualObj === expectationObj;\n              }\n              return expectationObj.test(actualObj);\n          }\n\n          var actualType = typeof actualObj;\n          var expectationType = typeof expectationObj;\n\n          if (\n              actualObj === expectationObj ||\n              isNaN(actualObj) ||\n              isNaN(expectationObj) ||\n              actualObj === null ||\n              expectationObj === null ||\n              actualObj === undefined ||\n              expectationObj === undefined ||\n              actualType !== \"object\" ||\n              expectationType !== \"object\"\n          ) {\n              return identical(actualObj, expectationObj);\n          }\n\n          // Elements are only equal if identical(expected, actual)\n          if (isElement(actualObj) || isElement(expectationObj)) {\n              return false;\n          }\n\n          var isActualDate = isDate(actualObj);\n          var isExpectationDate = isDate(expectationObj);\n          if (isActualDate || isExpectationDate) {\n              if (\n                  !isActualDate ||\n                  !isExpectationDate ||\n                  getTime.call(actualObj) !== getTime.call(expectationObj)\n              ) {\n                  return false;\n              }\n          }\n\n          if (actualObj instanceof RegExp && expectationObj instanceof RegExp) {\n              if (valueToString(actualObj) !== valueToString(expectationObj)) {\n                  return false;\n              }\n          }\n\n          if (actualObj instanceof Promise && expectationObj instanceof Promise) {\n              return actualObj === expectationObj;\n          }\n\n          if (actualObj instanceof Error && expectationObj instanceof Error) {\n              return actualObj === expectationObj;\n          }\n\n          var actualClass = getClass(actualObj);\n          var expectationClass = getClass(expectationObj);\n          var actualKeys = keys(actualObj);\n          var expectationKeys = keys(expectationObj);\n          var actualName = className(actualObj);\n          var expectationName = className(expectationObj);\n          var expectationSymbols =\n              typeOf(getOwnPropertySymbols) === \"function\"\n                  ? getOwnPropertySymbols(expectationObj)\n                  : /* istanbul ignore next: cannot collect coverage for engine that doesn't support Symbol */\n                    [];\n          var expectationKeysAndSymbols = concat(\n              expectationKeys,\n              expectationSymbols,\n          );\n\n          if (isArguments(actualObj) || isArguments(expectationObj)) {\n              if (actualObj.length !== expectationObj.length) {\n                  return false;\n              }\n          } else {\n              if (\n                  actualType !== expectationType ||\n                  actualClass !== expectationClass ||\n                  actualKeys.length !== expectationKeys.length ||\n                  (actualName &&\n                      expectationName &&\n                      actualName !== expectationName)\n              ) {\n                  return false;\n              }\n          }\n\n          if (isSet(actualObj) || isSet(expectationObj)) {\n              if (\n                  !isSet(actualObj) ||\n                  !isSet(expectationObj) ||\n                  actualObj.size !== expectationObj.size\n              ) {\n                  return false;\n              }\n\n              return isSubset(actualObj, expectationObj, deepEqual);\n          }\n\n          if (isMap(actualObj) || isMap(expectationObj)) {\n              if (\n                  !isMap(actualObj) ||\n                  !isMap(expectationObj) ||\n                  actualObj.size !== expectationObj.size\n              ) {\n                  return false;\n              }\n\n              var mapsDeeplyEqual = true;\n              mapForEach(actualObj, function (value, key) {\n                  mapsDeeplyEqual =\n                      mapsDeeplyEqual &&\n                      deepEqualCyclic(value, expectationObj.get(key));\n              });\n\n              return mapsDeeplyEqual;\n          }\n\n          // jQuery objects have iteration protocols\n          // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\n          // But, they don't work well with the implementation concerning iterables below,\n          // so we will detect them and use jQuery's own equality function\n          /* istanbul ignore next -- this can only be tested in the `test-headless` script */\n          if (\n              actualObj.constructor &&\n              actualObj.constructor.name === \"jQuery\" &&\n              typeof actualObj.is === \"function\"\n          ) {\n              return actualObj.is(expectationObj);\n          }\n\n          var isActualNonArrayIterable =\n              isIterable(actualObj) &&\n              !isArrayType(actualObj) &&\n              !isArguments(actualObj);\n          var isExpectationNonArrayIterable =\n              isIterable(expectationObj) &&\n              !isArrayType(expectationObj) &&\n              !isArguments(expectationObj);\n          if (isActualNonArrayIterable || isExpectationNonArrayIterable) {\n              var actualArray = Array.from(actualObj);\n              var expectationArray = Array.from(expectationObj);\n              if (actualArray.length !== expectationArray.length) {\n                  return false;\n              }\n\n              var arrayDeeplyEquals = true;\n              every(actualArray, function (key) {\n                  arrayDeeplyEquals =\n                      arrayDeeplyEquals &&\n                      deepEqualCyclic(actualArray[key], expectationArray[key]);\n              });\n\n              return arrayDeeplyEquals;\n          }\n\n          return every(expectationKeysAndSymbols, function (key) {\n              if (!hasOwnProperty(actualObj, key)) {\n                  return false;\n              }\n\n              var actualValue = actualObj[key];\n              var expectationValue = expectationObj[key];\n              var actualObject = isObject(actualValue);\n              var expectationObject = isObject(expectationValue);\n              // determines, if the objects were already visited\n              // (it's faster to check for isObject first, than to\n              // get -1 from getIndex for non objects)\n              var actualIndex = actualObject\n                  ? indexOf(actualObjects, actualValue)\n                  : -1;\n              var expectationIndex = expectationObject\n                  ? indexOf(expectationObjects, expectationValue)\n                  : -1;\n              // determines the new paths of the objects\n              // - for non cyclic objects the current path will be extended\n              //   by current property name\n              // - for cyclic objects the stored path is taken\n              var newActualPath =\n                  actualIndex !== -1\n                      ? actualPaths[actualIndex]\n                      : `${actualPath}[${JSON.stringify(key)}]`;\n              var newExpectationPath =\n                  expectationIndex !== -1\n                      ? expectationPaths[expectationIndex]\n                      : `${expectationPath}[${JSON.stringify(key)}]`;\n              var combinedPath = newActualPath + newExpectationPath;\n\n              // stop recursion if current objects are already compared\n              if (compared[combinedPath]) {\n                  return true;\n              }\n\n              // remember the current objects and their paths\n              if (actualIndex === -1 && actualObject) {\n                  push(actualObjects, actualValue);\n                  push(actualPaths, newActualPath);\n              }\n              if (expectationIndex === -1 && expectationObject) {\n                  push(expectationObjects, expectationValue);\n                  push(expectationPaths, newExpectationPath);\n              }\n\n              // remember that the current objects are already compared\n              if (actualObject && expectationObject) {\n                  compared[combinedPath] = true;\n              }\n\n              // End of cyclic logic\n\n              // neither actualValue nor expectationValue is a cycle\n              // continue with next level\n              return deepEqual(\n                  actualValue,\n                  expectationValue,\n                  newActualPath,\n                  newExpectationPath,\n              );\n          });\n      })(actual, expectation, \"$1\", \"$2\");\n  }\n\n  deepEqualCyclic.use = function (match) {\n      return function deepEqual(a, b) {\n          return deepEqualCyclic(a, b, match);\n      };\n  };\n\n  module.exports = deepEqualCyclic;\n\n  },{\"./get-class\":72,\"./identical\":73,\"./is-arguments\":74,\"./is-array-type\":75,\"./is-date\":76,\"./is-element\":77,\"./is-iterable\":78,\"./is-map\":79,\"./is-nan\":80,\"./is-object\":82,\"./is-set\":83,\"./is-subset\":84,\"@sinonjs/commons\":47}],72:[function(require,module,exports){\n\n  var toString = require(\"@sinonjs/commons\").prototypes.object.toString;\n\n  /**\n   * Returns the internal `Class` by calling `Object.prototype.toString`\n   * with the provided value as `this`. Return value is a `String`, naming the\n   * internal class, e.g. \"Array\"\n   *\n   * @private\n   * @param  {*} value - Any value\n   * @returns {string} - A string representation of the `Class` of `value`\n   */\n  function getClass(value) {\n      return toString(value).split(/[ \\]]/)[1];\n  }\n\n  module.exports = getClass;\n\n  },{\"@sinonjs/commons\":47}],73:[function(require,module,exports){\n\n  var isNaN = require(\"./is-nan\");\n  var isNegZero = require(\"./is-neg-zero\");\n\n  /**\n   * Strict equality check according to EcmaScript Harmony's `egal`.\n   *\n   * **From the Harmony wiki:**\n   * > An `egal` function simply makes available the internal `SameValue` function\n   * > from section 9.12 of the ES5 spec. If two values are egal, then they are not\n   * > observably distinguishable.\n   *\n   * `identical` returns `true` when `===` is `true`, except for `-0` and\n   * `+0`, where it returns `false`. Additionally, it returns `true` when\n   * `NaN` is compared to itself.\n   *\n   * @alias module:samsam.identical\n   * @param {*} obj1 The first value to compare\n   * @param {*} obj2 The second value to compare\n   * @returns {boolean} Returns `true` when the objects are *egal*, `false` otherwise\n   */\n  function identical(obj1, obj2) {\n      if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {\n          return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);\n      }\n\n      return false;\n  }\n\n  module.exports = identical;\n\n  },{\"./is-nan\":80,\"./is-neg-zero\":81}],74:[function(require,module,exports){\n\n  var getClass = require(\"./get-class\");\n\n  /**\n   * Returns `true` when `object` is an `arguments` object, `false` otherwise\n   *\n   * @alias module:samsam.isArguments\n   * @param  {*}  object - The object to examine\n   * @returns {boolean} `true` when `object` is an `arguments` object\n   */\n  function isArguments(object) {\n      return getClass(object) === \"Arguments\";\n  }\n\n  module.exports = isArguments;\n\n  },{\"./get-class\":72}],75:[function(require,module,exports){\n\n  var functionName = require(\"@sinonjs/commons\").functionName;\n  var indexOf = require(\"@sinonjs/commons\").prototypes.array.indexOf;\n  var map = require(\"@sinonjs/commons\").prototypes.array.map;\n  var ARRAY_TYPES = require(\"./array-types\");\n  var type = require(\"type-detect\");\n\n  /**\n   * Returns `true` when `object` is an array type, `false` otherwise\n   *\n   * @param  {*}  object - The object to examine\n   * @returns {boolean} `true` when `object` is an array type\n   * @private\n   */\n  function isArrayType(object) {\n      return indexOf(map(ARRAY_TYPES, functionName), type(object)) !== -1;\n  }\n\n  module.exports = isArrayType;\n\n  },{\"./array-types\":61,\"@sinonjs/commons\":47,\"type-detect\":88}],76:[function(require,module,exports){\n\n  /**\n   * Returns `true` when `value` is an instance of Date\n   *\n   * @private\n   * @param  {Date}  value The value to examine\n   * @returns {boolean}     `true` when `value` is an instance of Date\n   */\n  function isDate(value) {\n      return value instanceof Date;\n  }\n\n  module.exports = isDate;\n\n  },{}],77:[function(require,module,exports){\n\n  var div = typeof document !== \"undefined\" && document.createElement(\"div\");\n\n  /**\n   * Returns `true` when `object` is a DOM element node.\n   *\n   * Unlike Underscore.js/lodash, this function will return `false` if `object`\n   * is an *element-like* object, i.e. a regular object with a `nodeType`\n   * property that holds the value `1`.\n   *\n   * @alias module:samsam.isElement\n   * @param {object} object The object to examine\n   * @returns {boolean} Returns `true` for DOM element nodes\n   */\n  function isElement(object) {\n      if (!object || object.nodeType !== 1 || !div) {\n          return false;\n      }\n      try {\n          object.appendChild(div);\n          object.removeChild(div);\n      } catch (e) {\n          return false;\n      }\n      return true;\n  }\n\n  module.exports = isElement;\n\n  },{}],78:[function(require,module,exports){\n\n  /**\n   * Returns `true` when the argument is an iterable, `false` otherwise\n   *\n   * @alias module:samsam.isIterable\n   * @param  {*}  val - A value to examine\n   * @returns {boolean} Returns `true` when the argument is an iterable, `false` otherwise\n   */\n  function isIterable(val) {\n      // checks for null and undefined\n      if (typeof val !== \"object\") {\n          return false;\n      }\n      return typeof val[Symbol.iterator] === \"function\";\n  }\n\n  module.exports = isIterable;\n\n  },{}],79:[function(require,module,exports){\n\n  /**\n   * Returns `true` when `value` is a Map\n   *\n   * @param {*} value A value to examine\n   * @returns {boolean} `true` when `value` is an instance of `Map`, `false` otherwise\n   * @private\n   */\n  function isMap(value) {\n      return typeof Map !== \"undefined\" && value instanceof Map;\n  }\n\n  module.exports = isMap;\n\n  },{}],80:[function(require,module,exports){\n\n  /**\n   * Compares a `value` to `NaN`\n   *\n   * @private\n   * @param {*} value A value to examine\n   * @returns {boolean} Returns `true` when `value` is `NaN`\n   */\n  function isNaN(value) {\n      // Unlike global `isNaN`, this function avoids type coercion\n      // `typeof` check avoids IE host object issues, hat tip to\n      // lodash\n\n      // eslint-disable-next-line no-self-compare\n      return typeof value === \"number\" && value !== value;\n  }\n\n  module.exports = isNaN;\n\n  },{}],81:[function(require,module,exports){\n\n  /**\n   * Returns `true` when `value` is `-0`\n   *\n   * @alias module:samsam.isNegZero\n   * @param {*} value A value to examine\n   * @returns {boolean} Returns `true` when `value` is `-0`\n   */\n  function isNegZero(value) {\n      return value === 0 && 1 / value === -Infinity;\n  }\n\n  module.exports = isNegZero;\n\n  },{}],82:[function(require,module,exports){\n\n  /**\n   * Returns `true` when the value is a regular Object and not a specialized Object\n   *\n   * This helps speed up deepEqual cyclic checks\n   *\n   * The premise is that only Objects are stored in the visited array.\n   * So if this function returns false, we don't have to do the\n   * expensive operation of searching for the value in the the array of already\n   * visited objects\n   *\n   * @private\n   * @param  {object}   value The object to examine\n   * @returns {boolean}       `true` when the object is a non-specialised object\n   */\n  function isObject(value) {\n      return (\n          typeof value === \"object\" &&\n          value !== null &&\n          // none of these are collection objects, so we can return false\n          !(value instanceof Boolean) &&\n          !(value instanceof Date) &&\n          !(value instanceof Error) &&\n          !(value instanceof Number) &&\n          !(value instanceof RegExp) &&\n          !(value instanceof String)\n      );\n  }\n\n  module.exports = isObject;\n\n  },{}],83:[function(require,module,exports){\n\n  /**\n   * Returns `true` when the argument is an instance of Set, `false` otherwise\n   *\n   * @alias module:samsam.isSet\n   * @param  {*}  val - A value to examine\n   * @returns {boolean} Returns `true` when the argument is an instance of Set, `false` otherwise\n   */\n  function isSet(val) {\n      return (typeof Set !== \"undefined\" && val instanceof Set) || false;\n  }\n\n  module.exports = isSet;\n\n  },{}],84:[function(require,module,exports){\n\n  var forEach = require(\"@sinonjs/commons\").prototypes.set.forEach;\n\n  /**\n   * Returns `true` when `s1` is a subset of `s2`, `false` otherwise\n   *\n   * @private\n   * @param  {Array|Set}  s1      The target value\n   * @param  {Array|Set}  s2      The containing value\n   * @param  {Function}  compare A comparison function, should return `true` when\n   *                             values are considered equal\n   * @returns {boolean} Returns `true` when `s1` is a subset of `s2`, `false`` otherwise\n   */\n  function isSubset(s1, s2, compare) {\n      var allContained = true;\n      forEach(s1, function (v1) {\n          var includes = false;\n          forEach(s2, function (v2) {\n              if (compare(v2, v1)) {\n                  includes = true;\n              }\n          });\n          allContained = allContained && includes;\n      });\n\n      return allContained;\n  }\n\n  module.exports = isSubset;\n\n  },{\"@sinonjs/commons\":47}],85:[function(require,module,exports){\n\n  var slice = require(\"@sinonjs/commons\").prototypes.string.slice;\n  var typeOf = require(\"@sinonjs/commons\").typeOf;\n  var valueToString = require(\"@sinonjs/commons\").valueToString;\n\n  /**\n   * Creates a string represenation of an iterable object\n   *\n   * @private\n   * @param   {object} obj The iterable object to stringify\n   * @returns {string}     A string representation\n   */\n  function iterableToString(obj) {\n      if (typeOf(obj) === \"map\") {\n          return mapToString(obj);\n      }\n\n      return genericIterableToString(obj);\n  }\n\n  /**\n   * Creates a string representation of a Map\n   *\n   * @private\n   * @param   {Map} map    The map to stringify\n   * @returns {string}     A string representation\n   */\n  function mapToString(map) {\n      var representation = \"\";\n\n      // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n      map.forEach(function (value, key) {\n          representation += `[${stringify(key)},${stringify(value)}],`;\n      });\n\n      representation = slice(representation, 0, -1);\n      return representation;\n  }\n\n  /**\n   * Create a string represenation for an iterable\n   *\n   * @private\n   * @param   {object} iterable The iterable to stringify\n   * @returns {string}          A string representation\n   */\n  function genericIterableToString(iterable) {\n      var representation = \"\";\n\n      // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods\n      iterable.forEach(function (value) {\n          representation += `${stringify(value)},`;\n      });\n\n      representation = slice(representation, 0, -1);\n      return representation;\n  }\n\n  /**\n   * Creates a string representation of the passed `item`\n   *\n   * @private\n   * @param  {object} item The item to stringify\n   * @returns {string}      A string representation of `item`\n   */\n  function stringify(item) {\n      return typeof item === \"string\" ? `'${item}'` : valueToString(item);\n  }\n\n  module.exports = iterableToString;\n\n  },{\"@sinonjs/commons\":47}],86:[function(require,module,exports){\n\n  var valueToString = require(\"@sinonjs/commons\").valueToString;\n  var indexOf = require(\"@sinonjs/commons\").prototypes.string.indexOf;\n  var forEach = require(\"@sinonjs/commons\").prototypes.array.forEach;\n  var type = require(\"type-detect\");\n\n  var engineCanCompareMaps = typeof Array.from === \"function\";\n  var deepEqual = require(\"./deep-equal\").use(match); // eslint-disable-line no-use-before-define\n  var isArrayType = require(\"./is-array-type\");\n  var isSubset = require(\"./is-subset\");\n  var createMatcher = require(\"./create-matcher\");\n\n  /**\n   * Returns true when `array` contains all of `subset` as defined by the `compare`\n   * argument\n   *\n   * @param  {Array} array   An array to search for a subset\n   * @param  {Array} subset  The subset to find in the array\n   * @param  {Function} compare A comparison function\n   * @returns {boolean}         [description]\n   * @private\n   */\n  function arrayContains(array, subset, compare) {\n      if (subset.length === 0) {\n          return true;\n      }\n      var i, l, j, k;\n      for (i = 0, l = array.length; i < l; ++i) {\n          if (compare(array[i], subset[0])) {\n              for (j = 0, k = subset.length; j < k; ++j) {\n                  if (i + j >= l) {\n                      return false;\n                  }\n                  if (!compare(array[i + j], subset[j])) {\n                      return false;\n                  }\n              }\n              return true;\n          }\n      }\n      return false;\n  }\n\n  /* eslint-disable complexity */\n  /**\n   * Matches an object with a matcher (or value)\n   *\n   * @alias module:samsam.match\n   * @param {object} object The object candidate to match\n   * @param {object} matcherOrValue A matcher or value to match against\n   * @returns {boolean} true when `object` matches `matcherOrValue`\n   */\n  function match(object, matcherOrValue) {\n      if (matcherOrValue && typeof matcherOrValue.test === \"function\") {\n          return matcherOrValue.test(object);\n      }\n\n      switch (type(matcherOrValue)) {\n          case \"bigint\":\n          case \"boolean\":\n          case \"number\":\n          case \"symbol\":\n              return matcherOrValue === object;\n          case \"function\":\n              return matcherOrValue(object) === true;\n          case \"string\":\n              var notNull = typeof object === \"string\" || Boolean(object);\n              return (\n                  notNull &&\n                  indexOf(\n                      valueToString(object).toLowerCase(),\n                      matcherOrValue.toLowerCase(),\n                  ) >= 0\n              );\n          case \"null\":\n              return object === null;\n          case \"undefined\":\n              return typeof object === \"undefined\";\n          case \"Date\":\n              /* istanbul ignore else */\n              if (type(object) === \"Date\") {\n                  return object.getTime() === matcherOrValue.getTime();\n              }\n              /* istanbul ignore next: this is basically the rest of the function, which is covered */\n              break;\n          case \"Array\":\n          case \"Int8Array\":\n          case \"Uint8Array\":\n          case \"Uint8ClampedArray\":\n          case \"Int16Array\":\n          case \"Uint16Array\":\n          case \"Int32Array\":\n          case \"Uint32Array\":\n          case \"Float32Array\":\n          case \"Float64Array\":\n              return (\n                  isArrayType(matcherOrValue) &&\n                  arrayContains(object, matcherOrValue, match)\n              );\n          case \"Map\":\n              /* istanbul ignore next: this is covered by a test, that is only run in IE, but we collect coverage information in node*/\n              if (!engineCanCompareMaps) {\n                  throw new Error(\n                      \"The JavaScript engine does not support Array.from and cannot reliably do value comparison of Map instances\",\n                  );\n              }\n\n              return (\n                  type(object) === \"Map\" &&\n                  arrayContains(\n                      Array.from(object),\n                      Array.from(matcherOrValue),\n                      match,\n                  )\n              );\n      }\n\n      switch (type(object)) {\n          case \"null\":\n              return false;\n          case \"Set\":\n              return isSubset(matcherOrValue, object, match);\n      }\n\n      /* istanbul ignore else */\n      if (matcherOrValue && typeof matcherOrValue === \"object\") {\n          if (matcherOrValue === object) {\n              return true;\n          }\n          if (typeof object !== \"object\") {\n              return false;\n          }\n          var prop;\n          // eslint-disable-next-line guard-for-in\n          for (prop in matcherOrValue) {\n              var value = object[prop];\n              if (\n                  typeof value === \"undefined\" &&\n                  typeof object.getAttribute === \"function\"\n              ) {\n                  value = object.getAttribute(prop);\n              }\n              if (\n                  matcherOrValue[prop] === null ||\n                  typeof matcherOrValue[prop] === \"undefined\"\n              ) {\n                  if (value !== matcherOrValue[prop]) {\n                      return false;\n                  }\n              } else if (\n                  typeof value === \"undefined\" ||\n                  !deepEqual(value, matcherOrValue[prop])\n              ) {\n                  return false;\n              }\n          }\n          return true;\n      }\n\n      /* istanbul ignore next */\n      throw new Error(\"Matcher was an unknown or unsupported type\");\n  }\n  /* eslint-enable complexity */\n\n  forEach(Object.keys(createMatcher), function (key) {\n      match[key] = createMatcher[key];\n  });\n\n  module.exports = match;\n\n  },{\"./create-matcher\":62,\"./deep-equal\":71,\"./is-array-type\":75,\"./is-subset\":84,\"@sinonjs/commons\":47,\"type-detect\":88}],87:[function(require,module,exports){\n\n  /**\n   * @module samsam\n   */\n  var identical = require(\"./identical\");\n  var isArguments = require(\"./is-arguments\");\n  var isElement = require(\"./is-element\");\n  var isNegZero = require(\"./is-neg-zero\");\n  var isSet = require(\"./is-set\");\n  var isMap = require(\"./is-map\");\n  var match = require(\"./match\");\n  var deepEqualCyclic = require(\"./deep-equal\").use(match);\n  var createMatcher = require(\"./create-matcher\");\n\n  module.exports = {\n      createMatcher: createMatcher,\n      deepEqual: deepEqualCyclic,\n      identical: identical,\n      isArguments: isArguments,\n      isElement: isElement,\n      isMap: isMap,\n      isNegZero: isNegZero,\n      isSet: isSet,\n      match: match,\n  };\n\n  },{\"./create-matcher\":62,\"./deep-equal\":71,\"./identical\":73,\"./is-arguments\":74,\"./is-element\":77,\"./is-map\":79,\"./is-neg-zero\":81,\"./is-set\":83,\"./match\":86}],88:[function(require,module,exports){\n  (function (global, factory) {\n      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n      typeof define === 'function' && define.amd ? define(factory) :\n      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.typeDetect = factory());\n  })(this, (function () {\n      var promiseExists = typeof Promise === 'function';\n      var globalObject = (function (Obj) {\n          if (typeof globalThis === 'object') {\n              return globalThis;\n          }\n          Object.defineProperty(Obj, 'typeDetectGlobalObject', {\n              get: function get() {\n                  return this;\n              },\n              configurable: true,\n          });\n          var global = typeDetectGlobalObject;\n          delete Obj.typeDetectGlobalObject;\n          return global;\n      })(Object.prototype);\n      var symbolExists = typeof Symbol !== 'undefined';\n      var mapExists = typeof Map !== 'undefined';\n      var setExists = typeof Set !== 'undefined';\n      var weakMapExists = typeof WeakMap !== 'undefined';\n      var weakSetExists = typeof WeakSet !== 'undefined';\n      var dataViewExists = typeof DataView !== 'undefined';\n      var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\n      var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\n      var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\n      var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\n      var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\n      var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\n      var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\n      var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\n      var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\n      var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\n      var toStringLeftSliceLength = 8;\n      var toStringRightSliceLength = -1;\n      function typeDetect(obj) {\n          var typeofObj = typeof obj;\n          if (typeofObj !== 'object') {\n              return typeofObj;\n          }\n          if (obj === null) {\n              return 'null';\n          }\n          if (obj === globalObject) {\n              return 'global';\n          }\n          if (Array.isArray(obj) &&\n              (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {\n              return 'Array';\n          }\n          if (typeof window === 'object' && window !== null) {\n              if (typeof window.location === 'object' && obj === window.location) {\n                  return 'Location';\n              }\n              if (typeof window.document === 'object' && obj === window.document) {\n                  return 'Document';\n              }\n              if (typeof window.navigator === 'object') {\n                  if (typeof window.navigator.mimeTypes === 'object' &&\n                      obj === window.navigator.mimeTypes) {\n                      return 'MimeTypeArray';\n                  }\n                  if (typeof window.navigator.plugins === 'object' &&\n                      obj === window.navigator.plugins) {\n                      return 'PluginArray';\n                  }\n              }\n              if ((typeof window.HTMLElement === 'function' ||\n                  typeof window.HTMLElement === 'object') &&\n                  obj instanceof window.HTMLElement) {\n                  if (obj.tagName === 'BLOCKQUOTE') {\n                      return 'HTMLQuoteElement';\n                  }\n                  if (obj.tagName === 'TD') {\n                      return 'HTMLTableDataCellElement';\n                  }\n                  if (obj.tagName === 'TH') {\n                      return 'HTMLTableHeaderCellElement';\n                  }\n              }\n          }\n          var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\n          if (typeof stringTag === 'string') {\n              return stringTag;\n          }\n          var objPrototype = Object.getPrototypeOf(obj);\n          if (objPrototype === RegExp.prototype) {\n              return 'RegExp';\n          }\n          if (objPrototype === Date.prototype) {\n              return 'Date';\n          }\n          if (promiseExists && objPrototype === Promise.prototype) {\n              return 'Promise';\n          }\n          if (setExists && objPrototype === Set.prototype) {\n              return 'Set';\n          }\n          if (mapExists && objPrototype === Map.prototype) {\n              return 'Map';\n          }\n          if (weakSetExists && objPrototype === WeakSet.prototype) {\n              return 'WeakSet';\n          }\n          if (weakMapExists && objPrototype === WeakMap.prototype) {\n              return 'WeakMap';\n          }\n          if (dataViewExists && objPrototype === DataView.prototype) {\n              return 'DataView';\n          }\n          if (mapExists && objPrototype === mapIteratorPrototype) {\n              return 'Map Iterator';\n          }\n          if (setExists && objPrototype === setIteratorPrototype) {\n              return 'Set Iterator';\n          }\n          if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\n              return 'Array Iterator';\n          }\n          if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\n              return 'String Iterator';\n          }\n          if (objPrototype === null) {\n              return 'Object';\n          }\n          return Object\n              .prototype\n              .toString\n              .call(obj)\n              .slice(toStringLeftSliceLength, toStringRightSliceLength);\n      }\n\n      return typeDetect;\n\n  }));\n\n  },{}],89:[function(require,module,exports){\n  if (typeof Object.create === 'function') {\n    // implementation from standard node.js 'util' module\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    };\n  } else {\n    // old school shim for old browsers\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    };\n  }\n\n  },{}],90:[function(require,module,exports){\n  module.exports = function isBuffer(arg) {\n    return arg && typeof arg === 'object'\n      && typeof arg.copy === 'function'\n      && typeof arg.fill === 'function'\n      && typeof arg.readUInt8 === 'function';\n  };\n  },{}],91:[function(require,module,exports){\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  var formatRegExp = /%[sdj%]/g;\n  exports.format = function(f) {\n    if (!isString(f)) {\n      var objects = [];\n      for (var i = 0; i < arguments.length; i++) {\n        objects.push(inspect(arguments[i]));\n      }\n      return objects.join(' ');\n    }\n\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function(x) {\n      if (x === '%%') return '%';\n      if (i >= len) return x;\n      switch (x) {\n        case '%s': return String(args[i++]);\n        case '%d': return Number(args[i++]);\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n        default:\n          return x;\n      }\n    });\n    for (var x = args[i]; i < len; x = args[++i]) {\n      if (isNull(x) || !isObject(x)) {\n        str += ' ' + x;\n      } else {\n        str += ' ' + inspect(x);\n      }\n    }\n    return str;\n  };\n\n\n  // Mark that a method should not be used.\n  // Returns a modified function which warns once by default.\n  // If --no-deprecation is set, then it is a no-op.\n  exports.deprecate = function(fn, msg) {\n    // Allow for deprecating things in the process of starting up.\n    if (isUndefined(_polyfillNode_process.global.process)) {\n      return function() {\n        return exports.deprecate(fn, msg).apply(this, arguments);\n      };\n    }\n\n    if (_polyfillNode_process.browser$1.noDeprecation === true) {\n      return fn;\n    }\n\n    var warned = false;\n    function deprecated() {\n      if (!warned) {\n        if (_polyfillNode_process.browser$1.throwDeprecation) {\n          throw new Error(msg);\n        } else if (_polyfillNode_process.browser$1.traceDeprecation) {\n          console.trace(msg);\n        } else {\n          console.error(msg);\n        }\n        warned = true;\n      }\n      return fn.apply(this, arguments);\n    }\n\n    return deprecated;\n  };\n\n\n  var debugs = {};\n  var debugEnviron;\n  exports.debuglog = function(set) {\n    if (isUndefined(debugEnviron))\n      debugEnviron = _polyfillNode_process.browser$1.env.NODE_DEBUG || '';\n    set = set.toUpperCase();\n    if (!debugs[set]) {\n      if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n        var pid = _polyfillNode_process.browser$1.pid;\n        debugs[set] = function() {\n          var msg = exports.format.apply(exports, arguments);\n          console.error('%s %d: %s', set, pid, msg);\n        };\n      } else {\n        debugs[set] = function() {};\n      }\n    }\n    return debugs[set];\n  };\n\n\n  /**\n   * Echos the value of a value. Trys to print the value out\n   * in the best way possible given the different types.\n   *\n   * @param {Object} obj The object to print out.\n   * @param {Object} opts Optional options object that alters the output.\n   */\n  /* legacy: obj, showHidden, depth, colors*/\n  function inspect(obj, opts) {\n    // default options\n    var ctx = {\n      seen: [],\n      stylize: stylizeNoColor\n    };\n    // legacy...\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n      // legacy...\n      ctx.showHidden = opts;\n    } else if (opts) {\n      // got an \"options\" object\n      exports._extend(ctx, opts);\n    }\n    // set default options\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n  }\n  exports.inspect = inspect;\n\n\n  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n  inspect.colors = {\n    'bold' : [1, 22],\n    'italic' : [3, 23],\n    'underline' : [4, 24],\n    'inverse' : [7, 27],\n    'white' : [37, 39],\n    'grey' : [90, 39],\n    'black' : [30, 39],\n    'blue' : [34, 39],\n    'cyan' : [36, 39],\n    'green' : [32, 39],\n    'magenta' : [35, 39],\n    'red' : [31, 39],\n    'yellow' : [33, 39]\n  };\n\n  // Don't use 'blue' not visible on cmd.exe\n  inspect.styles = {\n    'special': 'cyan',\n    'number': 'yellow',\n    'boolean': 'yellow',\n    'undefined': 'grey',\n    'null': 'bold',\n    'string': 'green',\n    'date': 'magenta',\n    // \"name\": intentionally not styling\n    'regexp': 'red'\n  };\n\n\n  function stylizeWithColor(str, styleType) {\n    var style = inspect.styles[styleType];\n\n    if (style) {\n      return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n             '\\u001b[' + inspect.colors[style][1] + 'm';\n    } else {\n      return str;\n    }\n  }\n\n\n  function stylizeNoColor(str, styleType) {\n    return str;\n  }\n\n\n  function arrayToHash(array) {\n    var hash = {};\n\n    array.forEach(function(val, idx) {\n      hash[val] = true;\n    });\n\n    return hash;\n  }\n\n\n  function formatValue(ctx, value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (ctx.customInspect &&\n        value &&\n        isFunction(value.inspect) &&\n        // Filter out the util module, it's inspect function is special\n        value.inspect !== exports.inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      var ret = value.inspect(recurseTimes, ctx);\n      if (!isString(ret)) {\n        ret = formatValue(ctx, ret, recurseTimes);\n      }\n      return ret;\n    }\n\n    // Primitive types cannot have properties\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n      return primitive;\n    }\n\n    // Look up the keys of the object.\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    if (ctx.showHidden) {\n      keys = Object.getOwnPropertyNames(value);\n    }\n\n    // IE doesn't make error fields non-enumerable\n    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n    if (isError(value)\n        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n      return formatError(value);\n    }\n\n    // Some type of object without properties can be shortcutted.\n    if (keys.length === 0) {\n      if (isFunction(value)) {\n        var name = value.name ? ': ' + value.name : '';\n        return ctx.stylize('[Function' + name + ']', 'special');\n      }\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      }\n      if (isDate(value)) {\n        return ctx.stylize(Date.prototype.toString.call(value), 'date');\n      }\n      if (isError(value)) {\n        return formatError(value);\n      }\n    }\n\n    var base = '', array = false, braces = ['{', '}'];\n\n    // Make Array say that they are Array\n    if (isArray(value)) {\n      array = true;\n      braces = ['[', ']'];\n    }\n\n    // Make functions say that they are functions\n    if (isFunction(value)) {\n      var n = value.name ? ': ' + value.name : '';\n      base = ' [Function' + n + ']';\n    }\n\n    // Make RegExps say that they are RegExps\n    if (isRegExp(value)) {\n      base = ' ' + RegExp.prototype.toString.call(value);\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + Date.prototype.toUTCString.call(value);\n    }\n\n    // Make error with message first say the error\n    if (isError(value)) {\n      base = ' ' + formatError(value);\n    }\n\n    if (keys.length === 0 && (!array || value.length == 0)) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      } else {\n        return ctx.stylize('[Object]', 'special');\n      }\n    }\n\n    ctx.seen.push(value);\n\n    var output;\n    if (array) {\n      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n      output = keys.map(function(key) {\n        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n      });\n    }\n\n    ctx.seen.pop();\n\n    return reduceToSingleString(output, base, braces);\n  }\n\n\n  function formatPrimitive(ctx, value) {\n    if (isUndefined(value))\n      return ctx.stylize('undefined', 'undefined');\n    if (isString(value)) {\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n    }\n    if (isNumber(value))\n      return ctx.stylize('' + value, 'number');\n    if (isBoolean(value))\n      return ctx.stylize('' + value, 'boolean');\n    // For some reason typeof null is \"object\", so special case here.\n    if (isNull(value))\n      return ctx.stylize('null', 'null');\n  }\n\n\n  function formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n  }\n\n\n  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n      if (hasOwnProperty(value, String(i))) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n            String(i), true));\n      } else {\n        output.push('');\n      }\n    }\n    keys.forEach(function(key) {\n      if (!key.match(/^\\d+$/)) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n            key, true));\n      }\n    });\n    return output;\n  }\n\n\n  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n    if (desc.get) {\n      if (desc.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (desc.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n      name = '[' + key + ']';\n    }\n    if (!str) {\n      if (ctx.seen.indexOf(desc.value) < 0) {\n        if (isNull(recurseTimes)) {\n          str = formatValue(ctx, desc.value, null);\n        } else {\n          str = formatValue(ctx, desc.value, recurseTimes - 1);\n        }\n        if (str.indexOf('\\n') > -1) {\n          if (array) {\n            str = str.split('\\n').map(function(line) {\n              return '  ' + line;\n            }).join('\\n').substr(2);\n          } else {\n            str = '\\n' + str.split('\\n').map(function(line) {\n              return '   ' + line;\n            }).join('\\n');\n          }\n        }\n      } else {\n        str = ctx.stylize('[Circular]', 'special');\n      }\n    }\n    if (isUndefined(name)) {\n      if (array && key.match(/^\\d+$/)) {\n        return str;\n      }\n      name = JSON.stringify('' + key);\n      if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n        name = name.substr(1, name.length - 2);\n        name = ctx.stylize(name, 'name');\n      } else {\n        name = name.replace(/'/g, \"\\\\'\")\n                   .replace(/\\\\\"/g, '\"')\n                   .replace(/(^\"|\"$)/g, \"'\");\n        name = ctx.stylize(name, 'string');\n      }\n    }\n\n    return name + ': ' + str;\n  }\n\n\n  function reduceToSingleString(output, base, braces) {\n    var length = output.reduce(function(prev, cur) {\n      if (cur.indexOf('\\n') >= 0) ;\n      return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n    }, 0);\n\n    if (length > 60) {\n      return braces[0] +\n             (base === '' ? '' : base + '\\n ') +\n             ' ' +\n             output.join(',\\n  ') +\n             ' ' +\n             braces[1];\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n  }\n\n\n  // NOTE: These type checking functions intentionally don't use `instanceof`\n  // because it is fragile and can be easily faked with `Object.create()`.\n  function isArray(ar) {\n    return Array.isArray(ar);\n  }\n  exports.isArray = isArray;\n\n  function isBoolean(arg) {\n    return typeof arg === 'boolean';\n  }\n  exports.isBoolean = isBoolean;\n\n  function isNull(arg) {\n    return arg === null;\n  }\n  exports.isNull = isNull;\n\n  function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n  exports.isNullOrUndefined = isNullOrUndefined;\n\n  function isNumber(arg) {\n    return typeof arg === 'number';\n  }\n  exports.isNumber = isNumber;\n\n  function isString(arg) {\n    return typeof arg === 'string';\n  }\n  exports.isString = isString;\n\n  function isSymbol(arg) {\n    return typeof arg === 'symbol';\n  }\n  exports.isSymbol = isSymbol;\n\n  function isUndefined(arg) {\n    return arg === void 0;\n  }\n  exports.isUndefined = isUndefined;\n\n  function isRegExp(re) {\n    return isObject(re) && objectToString(re) === '[object RegExp]';\n  }\n  exports.isRegExp = isRegExp;\n\n  function isObject(arg) {\n    return typeof arg === 'object' && arg !== null;\n  }\n  exports.isObject = isObject;\n\n  function isDate(d) {\n    return isObject(d) && objectToString(d) === '[object Date]';\n  }\n  exports.isDate = isDate;\n\n  function isError(e) {\n    return isObject(e) &&\n        (objectToString(e) === '[object Error]' || e instanceof Error);\n  }\n  exports.isError = isError;\n\n  function isFunction(arg) {\n    return typeof arg === 'function';\n  }\n  exports.isFunction = isFunction;\n\n  function isPrimitive(arg) {\n    return arg === null ||\n           typeof arg === 'boolean' ||\n           typeof arg === 'number' ||\n           typeof arg === 'string' ||\n           typeof arg === 'symbol' ||  // ES6 symbol\n           typeof arg === 'undefined';\n  }\n  exports.isPrimitive = isPrimitive;\n\n  exports.isBuffer = require('./support/isBuffer');\n\n  function objectToString(o) {\n    return Object.prototype.toString.call(o);\n  }\n\n\n  function pad(n) {\n    return n < 10 ? '0' + n.toString(10) : n.toString(10);\n  }\n\n\n  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n                'Oct', 'Nov', 'Dec'];\n\n  // 26 Feb 16:19:34\n  function timestamp() {\n    var d = new Date();\n    var time = [pad(d.getHours()),\n                pad(d.getMinutes()),\n                pad(d.getSeconds())].join(':');\n    return [d.getDate(), months[d.getMonth()], time].join(' ');\n  }\n\n\n  // log is just a thin wrapper to console.log that prepends a timestamp\n  exports.log = function() {\n    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n  };\n\n\n  /**\n   * Inherit the prototype methods from one constructor into another.\n   *\n   * The Function.prototype.inherits from lang.js rewritten as a standalone\n   * function (not on Function.prototype). NOTE: If this file is to be loaded\n   * during bootstrapping this function needs to be rewritten using some native\n   * functions as prototype setup using normal JavaScript does not work as\n   * expected during bootstrapping (see mirror.js in r114903).\n   *\n   * @param {function} ctor Constructor function which needs to inherit the\n   *     prototype.\n   * @param {function} superCtor Constructor function to inherit prototype from.\n   */\n  exports.inherits = require('inherits');\n\n  exports._extend = function(origin, add) {\n    // Don't do anything if add isn't an object\n    if (!add || !isObject(add)) return origin;\n\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n  };\n\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  },{\"./support/isBuffer\":90,\"inherits\":89}],92:[function(require,module,exports){\n  /*!\n\n   diff v7.0.0\n\n  BSD 3-Clause License\n\n  Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n  1. Redistributions of source code must retain the above copyright notice, this\n     list of conditions and the following disclaimer.\n\n  2. Redistributions in binary form must reproduce the above copyright notice,\n     this list of conditions and the following disclaimer in the documentation\n     and/or other materials provided with the distribution.\n\n  3. Neither the name of the copyright holder nor the names of its\n     contributors may be used to endorse or promote products derived from\n     this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  @license\n  */\n  (function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Diff = {}));\n  })(this, (function (exports) {\n    function Diff() {}\n    Diff.prototype = {\n      diff: function diff(oldString, newString) {\n        var _options$timeout;\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var callback = options.callback;\n        if (typeof options === 'function') {\n          callback = options;\n          options = {};\n        }\n        var self = this;\n        function done(value) {\n          value = self.postProcess(value, options);\n          if (callback) {\n            setTimeout(function () {\n              callback(value);\n            }, 0);\n            return true;\n          } else {\n            return value;\n          }\n        }\n\n        // Allow subclasses to massage the input prior to running\n        oldString = this.castInput(oldString, options);\n        newString = this.castInput(newString, options);\n        oldString = this.removeEmpty(this.tokenize(oldString, options));\n        newString = this.removeEmpty(this.tokenize(newString, options));\n        var newLen = newString.length,\n          oldLen = oldString.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        if (options.maxEditLength != null) {\n          maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n        var abortAfterTimestamp = Date.now() + maxExecutionTime;\n        var bestPath = [{\n          oldPos: -1,\n          lastComponent: undefined\n        }];\n\n        // Seed editLength = 0, i.e. the content starts with the same values\n        var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // Identity per the equality and tokenizer\n          return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));\n        }\n\n        // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        var minDiagonalToConsider = -Infinity,\n          maxDiagonalToConsider = Infinity;\n\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        function execEditLength() {\n          for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n            var basePath = void 0;\n            var removePath = bestPath[diagonalPath - 1],\n              addPath = bestPath[diagonalPath + 1];\n            if (removePath) {\n              // No one else is going to attempt to use this value, clear it\n              bestPath[diagonalPath - 1] = undefined;\n            }\n            var canAdd = false;\n            if (addPath) {\n              // what newPos will be after we do an insertion:\n              var addPathNewPos = addPath.oldPos - diagonalPath;\n              canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n            }\n            var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n            if (!canAdd && !canRemove) {\n              // If this path is a terminal then prune\n              bestPath[diagonalPath] = undefined;\n              continue;\n            }\n\n            // Select the diagonal that we want to branch from. We select the prior\n            // path whose position in the old string is the farthest from the origin\n            // and does not pass the bounds of the diff graph\n            if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {\n              basePath = self.addToPath(addPath, true, false, 0, options);\n            } else {\n              basePath = self.addToPath(removePath, false, true, 1, options);\n            }\n            newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options);\n            if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n              // If we have hit the end of both strings, then we are done\n              return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n            } else {\n              bestPath[diagonalPath] = basePath;\n              if (basePath.oldPos + 1 >= oldLen) {\n                maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n              }\n              if (newPos + 1 >= newLen) {\n                minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n              }\n            }\n          }\n          editLength++;\n        }\n\n        // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n          (function exec() {\n            setTimeout(function () {\n              if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                return callback();\n              }\n              if (!execEditLength()) {\n                exec();\n              }\n            }, 0);\n          })();\n        } else {\n          while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n            var ret = execEditLength();\n            if (ret) {\n              return ret;\n            }\n          }\n        }\n      },\n      addToPath: function addToPath(path, added, removed, oldPosInc, options) {\n        var last = path.lastComponent;\n        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n          return {\n            oldPos: path.oldPos + oldPosInc,\n            lastComponent: {\n              count: last.count + 1,\n              added: added,\n              removed: removed,\n              previousComponent: last.previousComponent\n            }\n          };\n        } else {\n          return {\n            oldPos: path.oldPos + oldPosInc,\n            lastComponent: {\n              count: 1,\n              added: added,\n              removed: removed,\n              previousComponent: last\n            }\n          };\n        }\n      },\n      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath, options) {\n        var newLen = newString.length,\n          oldLen = oldString.length,\n          oldPos = basePath.oldPos,\n          newPos = oldPos - diagonalPath,\n          commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {\n          newPos++;\n          oldPos++;\n          commonCount++;\n          if (options.oneChangePerToken) {\n            basePath.lastComponent = {\n              count: 1,\n              previousComponent: basePath.lastComponent,\n              added: false,\n              removed: false\n            };\n          }\n        }\n        if (commonCount && !options.oneChangePerToken) {\n          basePath.lastComponent = {\n            count: commonCount,\n            previousComponent: basePath.lastComponent,\n            added: false,\n            removed: false\n          };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n      },\n      equals: function equals(left, right, options) {\n        if (options.comparator) {\n          return options.comparator(left, right);\n        } else {\n          return left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n        }\n      },\n      removeEmpty: function removeEmpty(array) {\n        var ret = [];\n        for (var i = 0; i < array.length; i++) {\n          if (array[i]) {\n            ret.push(array[i]);\n          }\n        }\n        return ret;\n      },\n      castInput: function castInput(value) {\n        return value;\n      },\n      tokenize: function tokenize(value) {\n        return Array.from(value);\n      },\n      join: function join(chars) {\n        return chars.join('');\n      },\n      postProcess: function postProcess(changeObjects) {\n        return changeObjects;\n      }\n    };\n    function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n      // First we convert our linked list of components in reverse order to an\n      // array in the right order:\n      var components = [];\n      var nextComponent;\n      while (lastComponent) {\n        components.push(lastComponent);\n        nextComponent = lastComponent.previousComponent;\n        delete lastComponent.previousComponent;\n        lastComponent = nextComponent;\n      }\n      components.reverse();\n      var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n      for (; componentPos < componentLen; componentPos++) {\n        var component = components[componentPos];\n        if (!component.removed) {\n          if (!component.added && useLongestToken) {\n            var value = newString.slice(newPos, newPos + component.count);\n            value = value.map(function (value, i) {\n              var oldValue = oldString[oldPos + i];\n              return oldValue.length > value.length ? oldValue : value;\n            });\n            component.value = diff.join(value);\n          } else {\n            component.value = diff.join(newString.slice(newPos, newPos + component.count));\n          }\n          newPos += component.count;\n\n          // Common case\n          if (!component.added) {\n            oldPos += component.count;\n          }\n        } else {\n          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n          oldPos += component.count;\n        }\n      }\n      return components;\n    }\n\n    var characterDiff = new Diff();\n    function diffChars(oldStr, newStr, options) {\n      return characterDiff.diff(oldStr, newStr, options);\n    }\n\n    function longestCommonPrefix(str1, str2) {\n      var i;\n      for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[i] != str2[i]) {\n          return str1.slice(0, i);\n        }\n      }\n      return str1.slice(0, i);\n    }\n    function longestCommonSuffix(str1, str2) {\n      var i;\n\n      // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n      // where we return the empty string since str1.slice(-0) will return the\n      // entire string.\n      if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n        return '';\n      }\n      for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n          return str1.slice(-i);\n        }\n      }\n      return str1.slice(-i);\n    }\n    function replacePrefix(string, oldPrefix, newPrefix) {\n      if (string.slice(0, oldPrefix.length) != oldPrefix) {\n        throw Error(\"string \".concat(JSON.stringify(string), \" doesn't start with prefix \").concat(JSON.stringify(oldPrefix), \"; this is a bug\"));\n      }\n      return newPrefix + string.slice(oldPrefix.length);\n    }\n    function replaceSuffix(string, oldSuffix, newSuffix) {\n      if (!oldSuffix) {\n        return string + newSuffix;\n      }\n      if (string.slice(-oldSuffix.length) != oldSuffix) {\n        throw Error(\"string \".concat(JSON.stringify(string), \" doesn't end with suffix \").concat(JSON.stringify(oldSuffix), \"; this is a bug\"));\n      }\n      return string.slice(0, -oldSuffix.length) + newSuffix;\n    }\n    function removePrefix(string, oldPrefix) {\n      return replacePrefix(string, oldPrefix, '');\n    }\n    function removeSuffix(string, oldSuffix) {\n      return replaceSuffix(string, oldSuffix, '');\n    }\n    function maximumOverlap(string1, string2) {\n      return string2.slice(0, overlapCount(string1, string2));\n    }\n\n    // Nicked from https://stackoverflow.com/a/60422853/1709587\n    function overlapCount(a, b) {\n      // Deal with cases where the strings differ in length\n      var startA = 0;\n      if (a.length > b.length) {\n        startA = a.length - b.length;\n      }\n      var endB = b.length;\n      if (a.length < b.length) {\n        endB = a.length;\n      }\n      // Create a back-reference for each index\n      //   that should be followed in case of a mismatch.\n      //   We only need B to make these references:\n      var map = Array(endB);\n      var k = 0; // Index that lags behind j\n      map[0] = 0;\n      for (var j = 1; j < endB; j++) {\n        if (b[j] == b[k]) {\n          map[j] = map[k]; // skip over the same character (optional optimisation)\n        } else {\n          map[j] = k;\n        }\n        while (k > 0 && b[j] != b[k]) {\n          k = map[k];\n        }\n        if (b[j] == b[k]) {\n          k++;\n        }\n      }\n      // Phase 2: use these references while iterating over A\n      k = 0;\n      for (var i = startA; i < a.length; i++) {\n        while (k > 0 && a[i] != b[k]) {\n          k = map[k];\n        }\n        if (a[i] == b[k]) {\n          k++;\n        }\n      }\n      return k;\n    }\n\n    /**\n     * Returns true if the string consistently uses Windows line endings.\n     */\n    function hasOnlyWinLineEndings(string) {\n      return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n    }\n\n    /**\n     * Returns true if the string consistently uses Unix line endings.\n     */\n    function hasOnlyUnixLineEndings(string) {\n      return !string.includes('\\r\\n') && string.includes('\\n');\n    }\n\n    // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n    //\n    // Ranges and exceptions:\n    // Latin-1 Supplement, 008000FF\n    //  - U+00D7   Multiplication sign\n    //  - U+00F7   Division sign\n    // Latin Extended-A, 0100017F\n    // Latin Extended-B, 0180024F\n    // IPA Extensions, 025002AF\n    // Spacing Modifier Letters, 02B002FF\n    //  - U+02C7   &#711;  Caron\n    //  - U+02D8   &#728;  Breve\n    //  - U+02D9   &#729;  Dot Above\n    //  - U+02DA   &#730;  Ring Above\n    //  - U+02DB   &#731;  Ogonek\n    //  - U+02DC   &#732;  Small Tilde\n    //  - U+02DD   &#733;  Double Acute Accent\n    // Latin Extended Additional, 1E001EFF\n    var extendedWordChars = \"a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}\";\n\n    // Each token is one of the following:\n    // - A punctuation mark plus the surrounding whitespace\n    // - A word plus the surrounding whitespace\n    // - Pure whitespace (but only in the special case where this the entire text\n    //   is just whitespace)\n    //\n    // We have to include surrounding whitespace in the tokens because the two\n    // alternative approaches produce horribly broken results:\n    // * If we just discard the whitespace, we can't fully reproduce the original\n    //   text from the sequence of tokens and any attempt to render the diff will\n    //   get the whitespace wrong.\n    // * If we have separate tokens for whitespace, then in a typical text every\n    //   second token will be a single space character. But this often results in\n    //   the optimal diff between two texts being a perverse one that preserves\n    //   the spaces between words but deletes and reinserts actual common words.\n    //   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n    //   for an example.\n    //\n    // Keeping the surrounding whitespace of course has implications for .equals\n    // and .join, not just .tokenize.\n\n    // This regex does NOT fully implement the tokenization rules described above.\n    // Instead, it gives runs of whitespace their own \"token\". The tokenize method\n    // then handles stitching whitespace tokens onto adjacent word or punctuation\n    // tokens.\n    var tokenizeIncludingWhitespace = new RegExp(\"[\".concat(extendedWordChars, \"]+|\\\\s+|[^\").concat(extendedWordChars, \"]\"), 'ug');\n    var wordDiff = new Diff();\n    wordDiff.equals = function (left, right, options) {\n      if (options.ignoreCase) {\n        left = left.toLowerCase();\n        right = right.toLowerCase();\n      }\n      return left.trim() === right.trim();\n    };\n    wordDiff.tokenize = function (value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var parts;\n      if (options.intlSegmenter) {\n        if (options.intlSegmenter.resolvedOptions().granularity != 'word') {\n          throw new Error('The segmenter passed must have a granularity of \"word\"');\n        }\n        parts = Array.from(options.intlSegmenter.segment(value), function (segment) {\n          return segment.segment;\n        });\n      } else {\n        parts = value.match(tokenizeIncludingWhitespace) || [];\n      }\n      var tokens = [];\n      var prevPart = null;\n      parts.forEach(function (part) {\n        if (/\\s/.test(part)) {\n          if (prevPart == null) {\n            tokens.push(part);\n          } else {\n            tokens.push(tokens.pop() + part);\n          }\n        } else if (/\\s/.test(prevPart)) {\n          if (tokens[tokens.length - 1] == prevPart) {\n            tokens.push(tokens.pop() + part);\n          } else {\n            tokens.push(prevPart + part);\n          }\n        } else {\n          tokens.push(part);\n        }\n        prevPart = part;\n      });\n      return tokens;\n    };\n    wordDiff.join = function (tokens) {\n      // Tokens being joined here will always have appeared consecutively in the\n      // same text, so we can simply strip off the leading whitespace from all the\n      // tokens except the first (and except any whitespace-only tokens - but such\n      // a token will always be the first and only token anyway) and then join them\n      // and the whitespace around words and punctuation will end up correct.\n      return tokens.map(function (token, i) {\n        if (i == 0) {\n          return token;\n        } else {\n          return token.replace(/^\\s+/, '');\n        }\n      }).join('');\n    };\n    wordDiff.postProcess = function (changes, options) {\n      if (!changes || options.oneChangePerToken) {\n        return changes;\n      }\n      var lastKeep = null;\n      // Change objects representing any insertion or deletion since the last\n      // \"keep\" change object. There can be at most one of each.\n      var insertion = null;\n      var deletion = null;\n      changes.forEach(function (change) {\n        if (change.added) {\n          insertion = change;\n        } else if (change.removed) {\n          deletion = change;\n        } else {\n          if (insertion || deletion) {\n            // May be false at start of text\n            dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n          }\n          lastKeep = change;\n          insertion = null;\n          deletion = null;\n        }\n      });\n      if (insertion || deletion) {\n        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n      }\n      return changes;\n    };\n    function diffWords(oldStr, newStr, options) {\n      // This option has never been documented and never will be (it's clearer to\n      // just call `diffWordsWithSpace` directly if you need that behavior), but\n      // has existed in jsdiff for a long time, so we retain support for it here\n      // for the sake of backwards compatibility.\n      if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n        return diffWordsWithSpace(oldStr, newStr, options);\n      }\n      return wordDiff.diff(oldStr, newStr, options);\n    }\n    function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n      // Before returning, we tidy up the leading and trailing whitespace of the\n      // change objects to eliminate cases where trailing whitespace in one object\n      // is repeated as leading whitespace in the next.\n      // Below are examples of the outcomes we want here to explain the code.\n      // I=insert, K=keep, D=delete\n      // 1. diffing 'foo bar baz' vs 'foo baz'\n      //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n      //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n      //\n      // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n      //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n      //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n      //\n      // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n      //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n      //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n      //\n      // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n      //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n      //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n      //    but don't actually manage this currently (the pre-cleanup change\n      //    objects don't contain enough information to make it possible).\n      //\n      // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n      //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n      //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n      //\n      // Our handling is unavoidably imperfect in the case where there's a single\n      // indel between keeps and the whitespace has changed. For instance, consider\n      // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n      // object to represent the insertion of the space character (which isn't even\n      // a token), we have no way to avoid losing information about the texts'\n      // original whitespace in the result we return. Still, we do our best to\n      // output something that will look sensible if we e.g. print it with\n      // insertions in green and deletions in red.\n\n      // Between two \"keep\" change objects (or before the first or after the last\n      // change object), we can have either:\n      // * A \"delete\" followed by an \"insert\"\n      // * Just an \"insert\"\n      // * Just a \"delete\"\n      // We handle the three cases separately.\n      if (deletion && insertion) {\n        var oldWsPrefix = deletion.value.match(/^\\s*/)[0];\n        var oldWsSuffix = deletion.value.match(/\\s*$/)[0];\n        var newWsPrefix = insertion.value.match(/^\\s*/)[0];\n        var newWsSuffix = insertion.value.match(/\\s*$/)[0];\n        if (startKeep) {\n          var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n          startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n          deletion.value = removePrefix(deletion.value, commonWsPrefix);\n          insertion.value = removePrefix(insertion.value, commonWsPrefix);\n        }\n        if (endKeep) {\n          var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n          endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n          deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n          insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n        }\n      } else if (insertion) {\n        // The whitespaces all reflect what was in the new text rather than\n        // the old, so we essentially have no information about whitespace\n        // insertion or deletion. We just want to dedupe the whitespace.\n        // We do that by having each change object keep its trailing\n        // whitespace and deleting duplicate leading whitespace where\n        // present.\n        if (startKeep) {\n          insertion.value = insertion.value.replace(/^\\s*/, '');\n        }\n        if (endKeep) {\n          endKeep.value = endKeep.value.replace(/^\\s*/, '');\n        }\n        // otherwise we've got a deletion and no insertion\n      } else if (startKeep && endKeep) {\n        var newWsFull = endKeep.value.match(/^\\s*/)[0],\n          delWsStart = deletion.value.match(/^\\s*/)[0],\n          delWsEnd = deletion.value.match(/\\s*$/)[0];\n\n        // Any whitespace that comes straight after startKeep in both the old and\n        // new texts, assign to startKeep and remove from the deletion.\n        var newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n        deletion.value = removePrefix(deletion.value, newWsStart);\n\n        // Any whitespace that comes straight before endKeep in both the old and\n        // new texts, and hasn't already been assigned to startKeep, assign to\n        // endKeep and remove from the deletion.\n        var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n        deletion.value = removeSuffix(deletion.value, newWsEnd);\n        endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n\n        // If there's any whitespace from the new text that HASN'T already been\n        // assigned, assign it to the start:\n        startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n      } else if (endKeep) {\n        // We are at the start of the text. Preserve all the whitespace on\n        // endKeep, and just remove whitespace from the end of deletion to the\n        // extent that it overlaps with the start of endKeep.\n        var endKeepWsPrefix = endKeep.value.match(/^\\s*/)[0];\n        var deletionWsSuffix = deletion.value.match(/\\s*$/)[0];\n        var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n        deletion.value = removeSuffix(deletion.value, overlap);\n      } else if (startKeep) {\n        // We are at the END of the text. Preserve all the whitespace on\n        // startKeep, and just remove whitespace from the start of deletion to\n        // the extent that it overlaps with the end of startKeep.\n        var startKeepWsSuffix = startKeep.value.match(/\\s*$/)[0];\n        var deletionWsPrefix = deletion.value.match(/^\\s*/)[0];\n        var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n        deletion.value = removePrefix(deletion.value, _overlap);\n      }\n    }\n    var wordWithSpaceDiff = new Diff();\n    wordWithSpaceDiff.tokenize = function (value) {\n      // Slightly different to the tokenizeIncludingWhitespace regex used above in\n      // that this one treats each individual newline as a distinct tokens, rather\n      // than merging them into other surrounding whitespace. This was requested\n      // in https://github.com/kpdecker/jsdiff/issues/180 &\n      //    https://github.com/kpdecker/jsdiff/issues/211\n      var regex = new RegExp(\"(\\\\r?\\\\n)|[\".concat(extendedWordChars, \"]+|[^\\\\S\\\\n\\\\r]+|[^\").concat(extendedWordChars, \"]\"), 'ug');\n      return value.match(regex) || [];\n    };\n    function diffWordsWithSpace(oldStr, newStr, options) {\n      return wordWithSpaceDiff.diff(oldStr, newStr, options);\n    }\n\n    function generateOptions(options, defaults) {\n      if (typeof options === 'function') {\n        defaults.callback = options;\n      } else if (options) {\n        for (var name in options) {\n          /* istanbul ignore else */\n          if (options.hasOwnProperty(name)) {\n            defaults[name] = options[name];\n          }\n        }\n      }\n      return defaults;\n    }\n\n    var lineDiff = new Diff();\n    lineDiff.tokenize = function (value, options) {\n      if (options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, '\\n');\n      }\n      var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n      // Ignore the final empty token that occurs if the string ends with a new line\n      if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n      }\n\n      // Merge the content and line separators into single tokens\n      for (var i = 0; i < linesAndNewlines.length; i++) {\n        var line = linesAndNewlines[i];\n        if (i % 2 && !options.newlineIsToken) {\n          retLines[retLines.length - 1] += line;\n        } else {\n          retLines.push(line);\n        }\n      }\n      return retLines;\n    };\n    lineDiff.equals = function (left, right, options) {\n      // If we're ignoring whitespace, we need to normalise lines by stripping\n      // whitespace before checking equality. (This has an annoying interaction\n      // with newlineIsToken that requires special handling: if newlines get their\n      // own token, then we DON'T want to trim the *newline* tokens down to empty\n      // strings, since this would cause us to treat whitespace-only line content\n      // as equal to a separator between lines, which would be weird and\n      // inconsistent with the documented behavior of the options.)\n      if (options.ignoreWhitespace) {\n        if (!options.newlineIsToken || !left.includes('\\n')) {\n          left = left.trim();\n        }\n        if (!options.newlineIsToken || !right.includes('\\n')) {\n          right = right.trim();\n        }\n      } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n        if (left.endsWith('\\n')) {\n          left = left.slice(0, -1);\n        }\n        if (right.endsWith('\\n')) {\n          right = right.slice(0, -1);\n        }\n      }\n      return Diff.prototype.equals.call(this, left, right, options);\n    };\n    function diffLines(oldStr, newStr, callback) {\n      return lineDiff.diff(oldStr, newStr, callback);\n    }\n\n    // Kept for backwards compatibility. This is a rather arbitrary wrapper method\n    // that just calls `diffLines` with `ignoreWhitespace: true`. It's confusing to\n    // have two ways to do exactly the same thing in the API, so we no longer\n    // document this one (library users should explicitly use `diffLines` with\n    // `ignoreWhitespace: true` instead) but we keep it around to maintain\n    // compatibility with code that used old versions.\n    function diffTrimmedLines(oldStr, newStr, callback) {\n      var options = generateOptions(callback, {\n        ignoreWhitespace: true\n      });\n      return lineDiff.diff(oldStr, newStr, options);\n    }\n\n    var sentenceDiff = new Diff();\n    sentenceDiff.tokenize = function (value) {\n      return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n    };\n    function diffSentences(oldStr, newStr, callback) {\n      return sentenceDiff.diff(oldStr, newStr, callback);\n    }\n\n    var cssDiff = new Diff();\n    cssDiff.tokenize = function (value) {\n      return value.split(/([{}:;,]|\\s+)/);\n    };\n    function diffCss(oldStr, newStr, callback) {\n      return cssDiff.diff(oldStr, newStr, callback);\n    }\n\n    function ownKeys(e, r) {\n      var t = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function (r) {\n          return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n      }\n      return t;\n    }\n    function _objectSpread2(e) {\n      for (var r = 1; r < arguments.length; r++) {\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n          _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n      }\n      return e;\n    }\n    function _toPrimitive(t, r) {\n      if (\"object\" != typeof t || !t) return t;\n      var e = t[Symbol.toPrimitive];\n      if (void 0 !== e) {\n        var i = e.call(t, r);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (\"string\" === r ? String : Number)(t);\n    }\n    function _toPropertyKey(t) {\n      var i = _toPrimitive(t, \"string\");\n      return \"symbol\" == typeof i ? i : i + \"\";\n    }\n    function _typeof(o) {\n      \"@babel/helpers - typeof\";\n\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n        return typeof o;\n      } : function (o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n      }, _typeof(o);\n    }\n    function _defineProperty(obj, key, value) {\n      key = _toPropertyKey(key);\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _toConsumableArray(arr) {\n      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n    }\n    function _arrayWithoutHoles(arr) {\n      if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n    }\n    function _iterableToArray(iter) {\n      if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o) return;\n      if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor) n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\") return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length) len = arr.length;\n      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n      return arr2;\n    }\n    function _nonIterableSpread() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var jsonDiff = new Diff();\n    // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n    // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n    jsonDiff.useLongestToken = true;\n    jsonDiff.tokenize = lineDiff.tokenize;\n    jsonDiff.castInput = function (value, options) {\n      var undefinedReplacement = options.undefinedReplacement,\n        _options$stringifyRep = options.stringifyReplacer,\n        stringifyReplacer = _options$stringifyRep === void 0 ? function (k, v) {\n          return typeof v === 'undefined' ? undefinedReplacement : v;\n        } : _options$stringifyRep;\n      return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n    };\n    jsonDiff.equals = function (left, right, options) {\n      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'), options);\n    };\n    function diffJson(oldObj, newObj, options) {\n      return jsonDiff.diff(oldObj, newObj, options);\n    }\n\n    // This function handles the presence of circular references by bailing out when encountering an\n    // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n    function canonicalize(obj, stack, replacementStack, replacer, key) {\n      stack = stack || [];\n      replacementStack = replacementStack || [];\n      if (replacer) {\n        obj = replacer(key, obj);\n      }\n      var i;\n      for (i = 0; i < stack.length; i += 1) {\n        if (stack[i] === obj) {\n          return replacementStack[i];\n        }\n      }\n      var canonicalizedObj;\n      if ('[object Array]' === Object.prototype.toString.call(obj)) {\n        stack.push(obj);\n        canonicalizedObj = new Array(obj.length);\n        replacementStack.push(canonicalizedObj);\n        for (i = 0; i < obj.length; i += 1) {\n          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n        }\n        stack.pop();\n        replacementStack.pop();\n        return canonicalizedObj;\n      }\n      if (obj && obj.toJSON) {\n        obj = obj.toJSON();\n      }\n      if (_typeof(obj) === 'object' && obj !== null) {\n        stack.push(obj);\n        canonicalizedObj = {};\n        replacementStack.push(canonicalizedObj);\n        var sortedKeys = [],\n          _key;\n        for (_key in obj) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(obj, _key)) {\n            sortedKeys.push(_key);\n          }\n        }\n        sortedKeys.sort();\n        for (i = 0; i < sortedKeys.length; i += 1) {\n          _key = sortedKeys[i];\n          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n        }\n        stack.pop();\n        replacementStack.pop();\n      } else {\n        canonicalizedObj = obj;\n      }\n      return canonicalizedObj;\n    }\n\n    var arrayDiff = new Diff();\n    arrayDiff.tokenize = function (value) {\n      return value.slice();\n    };\n    arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n      return value;\n    };\n    function diffArrays(oldArr, newArr, callback) {\n      return arrayDiff.diff(oldArr, newArr, callback);\n    }\n\n    function unixToWin(patch) {\n      if (Array.isArray(patch)) {\n        return patch.map(unixToWin);\n      }\n      return _objectSpread2(_objectSpread2({}, patch), {}, {\n        hunks: patch.hunks.map(function (hunk) {\n          return _objectSpread2(_objectSpread2({}, hunk), {}, {\n            lines: hunk.lines.map(function (line, i) {\n              var _hunk$lines;\n              return line.startsWith('\\\\') || line.endsWith('\\r') || (_hunk$lines = hunk.lines[i + 1]) !== null && _hunk$lines !== void 0 && _hunk$lines.startsWith('\\\\') ? line : line + '\\r';\n            })\n          });\n        })\n      });\n    }\n    function winToUnix(patch) {\n      if (Array.isArray(patch)) {\n        return patch.map(winToUnix);\n      }\n      return _objectSpread2(_objectSpread2({}, patch), {}, {\n        hunks: patch.hunks.map(function (hunk) {\n          return _objectSpread2(_objectSpread2({}, hunk), {}, {\n            lines: hunk.lines.map(function (line) {\n              return line.endsWith('\\r') ? line.substring(0, line.length - 1) : line;\n            })\n          });\n        })\n      });\n    }\n\n    /**\n     * Returns true if the patch consistently uses Unix line endings (or only involves one line and has\n     * no line endings).\n     */\n    function isUnix(patch) {\n      if (!Array.isArray(patch)) {\n        patch = [patch];\n      }\n      return !patch.some(function (index) {\n        return index.hunks.some(function (hunk) {\n          return hunk.lines.some(function (line) {\n            return !line.startsWith('\\\\') && line.endsWith('\\r');\n          });\n        });\n      });\n    }\n\n    /**\n     * Returns true if the patch uses Windows line endings and only Windows line endings.\n     */\n    function isWin(patch) {\n      if (!Array.isArray(patch)) {\n        patch = [patch];\n      }\n      return patch.some(function (index) {\n        return index.hunks.some(function (hunk) {\n          return hunk.lines.some(function (line) {\n            return line.endsWith('\\r');\n          });\n        });\n      }) && patch.every(function (index) {\n        return index.hunks.every(function (hunk) {\n          return hunk.lines.every(function (line, i) {\n            var _hunk$lines2;\n            return line.startsWith('\\\\') || line.endsWith('\\r') || ((_hunk$lines2 = hunk.lines[i + 1]) === null || _hunk$lines2 === void 0 ? void 0 : _hunk$lines2.startsWith('\\\\'));\n          });\n        });\n      });\n    }\n\n    function parsePatch(uniDiff) {\n      var diffstr = uniDiff.split(/\\n/),\n        list = [],\n        i = 0;\n      function parseIndex() {\n        var index = {};\n        list.push(index);\n\n        // Parse diff metadata\n        while (i < diffstr.length) {\n          var line = diffstr[i];\n\n          // File header found, end parsing diff metadata\n          if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n            break;\n          }\n\n          // Diff index\n          var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n          if (header) {\n            index.index = header[1];\n          }\n          i++;\n        }\n\n        // Parse file headers if they are defined. Unified diff requires them, but\n        // there's no technical issues to have an isolated hunk without file header\n        parseFileHeader(index);\n        parseFileHeader(index);\n\n        // Parse hunks\n        index.hunks = [];\n        while (i < diffstr.length) {\n          var _line = diffstr[i];\n          if (/^(Index:\\s|diff\\s|\\-\\-\\-\\s|\\+\\+\\+\\s|===================================================================)/.test(_line)) {\n            break;\n          } else if (/^@@/.test(_line)) {\n            index.hunks.push(parseHunk());\n          } else if (_line) {\n            throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n          } else {\n            i++;\n          }\n        }\n      }\n\n      // Parses the --- and +++ headers, if none are found, no lines\n      // are consumed.\n      function parseFileHeader(index) {\n        var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)\\r?$/.exec(diffstr[i]);\n        if (fileHeader) {\n          var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n          var data = fileHeader[2].split('\\t', 2);\n          var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n          if (/^\".*\"$/.test(fileName)) {\n            fileName = fileName.substr(1, fileName.length - 2);\n          }\n          index[keyPrefix + 'FileName'] = fileName;\n          index[keyPrefix + 'Header'] = (data[1] || '').trim();\n          i++;\n        }\n      }\n\n      // Parses a hunk\n      // This assumes that we are at the start of a hunk.\n      function parseHunk() {\n        var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n        var hunk = {\n          oldStart: +chunkHeader[1],\n          oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n          newStart: +chunkHeader[3],\n          newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n          lines: []\n        };\n\n        // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n          hunk.oldStart += 1;\n        }\n        if (hunk.newLines === 0) {\n          hunk.newStart += 1;\n        }\n        var addCount = 0,\n          removeCount = 0;\n        for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || (_diffstr$i = diffstr[i]) !== null && _diffstr$i !== void 0 && _diffstr$i.startsWith('\\\\')); i++) {\n          var _diffstr$i;\n          var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n          if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n            hunk.lines.push(diffstr[i]);\n            if (operation === '+') {\n              addCount++;\n            } else if (operation === '-') {\n              removeCount++;\n            } else if (operation === ' ') {\n              addCount++;\n              removeCount++;\n            }\n          } else {\n            throw new Error(\"Hunk at line \".concat(chunkHeaderIndex + 1, \" contained invalid line \").concat(diffstr[i]));\n          }\n        }\n\n        // Handle the empty block count case\n        if (!addCount && hunk.newLines === 1) {\n          hunk.newLines = 0;\n        }\n        if (!removeCount && hunk.oldLines === 1) {\n          hunk.oldLines = 0;\n        }\n\n        // Perform sanity checking\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n        return hunk;\n      }\n      while (i < diffstr.length) {\n        parseIndex();\n      }\n      return list;\n    }\n\n    // Iterator that traverses in the range of [min, max], stepping\n    // by distance from a given start position. I.e. for [0, 4], with\n    // start of 2, this will iterate 2, 3, 1, 4, 0.\n    function distanceIterator (start, minLine, maxLine) {\n      var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n      return function iterator() {\n        if (wantForward && !forwardExhausted) {\n          if (backwardExhausted) {\n            localOffset++;\n          } else {\n            wantForward = false;\n          }\n\n          // Check if trying to fit beyond text length, and if not, check it fits\n          // after offset location (or desired location on first iteration)\n          if (start + localOffset <= maxLine) {\n            return start + localOffset;\n          }\n          forwardExhausted = true;\n        }\n        if (!backwardExhausted) {\n          if (!forwardExhausted) {\n            wantForward = true;\n          }\n\n          // Check if trying to fit before text beginning, and if not, check it fits\n          // before offset location\n          if (minLine <= start - localOffset) {\n            return start - localOffset++;\n          }\n          backwardExhausted = true;\n          return iterator();\n        }\n\n        // We tried to fit hunk before text beginning and beyond text length, then\n        // hunk can't fit on the text. Return undefined\n      };\n    }\n\n    function applyPatch(source, uniDiff) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (typeof uniDiff === 'string') {\n        uniDiff = parsePatch(uniDiff);\n      }\n      if (Array.isArray(uniDiff)) {\n        if (uniDiff.length > 1) {\n          throw new Error('applyPatch only works with a single input.');\n        }\n        uniDiff = uniDiff[0];\n      }\n      if (options.autoConvertLineEndings || options.autoConvertLineEndings == null) {\n        if (hasOnlyWinLineEndings(source) && isUnix(uniDiff)) {\n          uniDiff = unixToWin(uniDiff);\n        } else if (hasOnlyUnixLineEndings(source) && isWin(uniDiff)) {\n          uniDiff = winToUnix(uniDiff);\n        }\n      }\n\n      // Apply the diff to the input\n      var lines = source.split('\\n'),\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n          return line === patchContent;\n        },\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0;\n      if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {\n        throw new Error('fuzzFactor must be a non-negative integer');\n      }\n\n      // Special case for empty patch.\n      if (!hunks.length) {\n        return source;\n      }\n\n      // Before anything else, handle EOFNL insertion/removal. If the patch tells us to make a change\n      // to the EOFNL that is redundant/impossible - i.e. to remove a newline that's not there, or add a\n      // newline that already exists - then we either return false and fail to apply the patch (if\n      // fuzzFactor is 0) or simply ignore the problem and do nothing (if fuzzFactor is >0).\n      // If we do need to remove/add a newline at EOF, this will always be in the final hunk:\n      var prevLine = '',\n        removeEOFNL = false,\n        addEOFNL = false;\n      for (var i = 0; i < hunks[hunks.length - 1].lines.length; i++) {\n        var line = hunks[hunks.length - 1].lines[i];\n        if (line[0] == '\\\\') {\n          if (prevLine[0] == '+') {\n            removeEOFNL = true;\n          } else if (prevLine[0] == '-') {\n            addEOFNL = true;\n          }\n        }\n        prevLine = line;\n      }\n      if (removeEOFNL) {\n        if (addEOFNL) {\n          // This means the final line gets changed but doesn't have a trailing newline in either the\n          // original or patched version. In that case, we do nothing if fuzzFactor > 0, and if\n          // fuzzFactor is 0, we simply validate that the source file has no trailing newline.\n          if (!fuzzFactor && lines[lines.length - 1] == '') {\n            return false;\n          }\n        } else if (lines[lines.length - 1] == '') {\n          lines.pop();\n        } else if (!fuzzFactor) {\n          return false;\n        }\n      } else if (addEOFNL) {\n        if (lines[lines.length - 1] != '') {\n          lines.push('');\n        } else if (!fuzzFactor) {\n          return false;\n        }\n      }\n\n      /**\n       * Checks if the hunk can be made to fit at the provided location with at most `maxErrors`\n       * insertions, substitutions, or deletions, while ensuring also that:\n       * - lines deleted in the hunk match exactly, and\n       * - wherever an insertion operation or block of insertion operations appears in the hunk, the\n       *   immediately preceding and following lines of context match exactly\n       *\n       * `toPos` should be set such that lines[toPos] is meant to match hunkLines[0].\n       *\n       * If the hunk can be applied, returns an object with properties `oldLineLastI` and\n       * `replacementLines`. Otherwise, returns null.\n       */\n      function applyHunk(hunkLines, toPos, maxErrors) {\n        var hunkLinesI = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var lastContextLineMatched = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n        var patchedLines = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n        var patchedLinesLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n        var nConsecutiveOldContextLines = 0;\n        var nextContextLineMustMatch = false;\n        for (; hunkLinesI < hunkLines.length; hunkLinesI++) {\n          var hunkLine = hunkLines[hunkLinesI],\n            operation = hunkLine.length > 0 ? hunkLine[0] : ' ',\n            content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;\n          if (operation === '-') {\n            if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n              toPos++;\n              nConsecutiveOldContextLines = 0;\n            } else {\n              if (!maxErrors || lines[toPos] == null) {\n                return null;\n              }\n              patchedLines[patchedLinesLength] = lines[toPos];\n              return applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);\n            }\n          }\n          if (operation === '+') {\n            if (!lastContextLineMatched) {\n              return null;\n            }\n            patchedLines[patchedLinesLength] = content;\n            patchedLinesLength++;\n            nConsecutiveOldContextLines = 0;\n            nextContextLineMustMatch = true;\n          }\n          if (operation === ' ') {\n            nConsecutiveOldContextLines++;\n            patchedLines[patchedLinesLength] = lines[toPos];\n            if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n              patchedLinesLength++;\n              lastContextLineMatched = true;\n              nextContextLineMustMatch = false;\n              toPos++;\n            } else {\n              if (nextContextLineMustMatch || !maxErrors) {\n                return null;\n              }\n\n              // Consider 3 possibilities in sequence:\n              // 1. lines contains a *substitution* not included in the patch context, or\n              // 2. lines contains an *insertion* not included in the patch context, or\n              // 3. lines contains a *deletion* not included in the patch context\n              // The first two options are of course only possible if the line from lines is non-null -\n              // i.e. only option 3 is possible if we've overrun the end of the old file.\n              return lines[toPos] && (applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);\n            }\n          }\n        }\n\n        // Before returning, trim any unmodified context lines off the end of patchedLines and reduce\n        // toPos (and thus oldLineLastI) accordingly. This allows later hunks to be applied to a region\n        // that starts in this hunk's trailing context.\n        patchedLinesLength -= nConsecutiveOldContextLines;\n        toPos -= nConsecutiveOldContextLines;\n        patchedLines.length = patchedLinesLength;\n        return {\n          patchedLines: patchedLines,\n          oldLineLastI: toPos - 1\n        };\n      }\n      var resultLines = [];\n\n      // Search best fit offsets for each hunk based on the previous ones\n      var prevHunkOffset = 0;\n      for (var _i = 0; _i < hunks.length; _i++) {\n        var hunk = hunks[_i];\n        var hunkResult = void 0;\n        var maxLine = lines.length - hunk.oldLines + fuzzFactor;\n        var toPos = void 0;\n        for (var maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {\n          toPos = hunk.oldStart + prevHunkOffset - 1;\n          var iterator = distanceIterator(toPos, minLine, maxLine);\n          for (; toPos !== undefined; toPos = iterator()) {\n            hunkResult = applyHunk(hunk.lines, toPos, maxErrors);\n            if (hunkResult) {\n              break;\n            }\n          }\n          if (hunkResult) {\n            break;\n          }\n        }\n        if (!hunkResult) {\n          return false;\n        }\n\n        // Copy everything from the end of where we applied the last hunk to the start of this hunk\n        for (var _i2 = minLine; _i2 < toPos; _i2++) {\n          resultLines.push(lines[_i2]);\n        }\n\n        // Add the lines produced by applying the hunk:\n        for (var _i3 = 0; _i3 < hunkResult.patchedLines.length; _i3++) {\n          var _line = hunkResult.patchedLines[_i3];\n          resultLines.push(_line);\n        }\n\n        // Set lower text limit to end of the current hunk, so next ones don't try\n        // to fit over already patched text\n        minLine = hunkResult.oldLineLastI + 1;\n\n        // Note the offset between where the patch said the hunk should've applied and where we\n        // applied it, so we can adjust future hunks accordingly:\n        prevHunkOffset = toPos + 1 - hunk.oldStart;\n      }\n\n      // Copy over the rest of the lines from the old text\n      for (var _i4 = minLine; _i4 < lines.length; _i4++) {\n        resultLines.push(lines[_i4]);\n      }\n      return resultLines.join('\\n');\n    }\n\n    // Wrapper that supports multiple file patches via callbacks.\n    function applyPatches(uniDiff, options) {\n      if (typeof uniDiff === 'string') {\n        uniDiff = parsePatch(uniDiff);\n      }\n      var currentIndex = 0;\n      function processIndex() {\n        var index = uniDiff[currentIndex++];\n        if (!index) {\n          return options.complete();\n        }\n        options.loadFile(index, function (err, data) {\n          if (err) {\n            return options.complete(err);\n          }\n          var updatedContent = applyPatch(data, index, options);\n          options.patched(index, updatedContent, function (err) {\n            if (err) {\n              return options.complete(err);\n            }\n            processIndex();\n          });\n        });\n      }\n      processIndex();\n    }\n\n    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n      if (!options) {\n        options = {};\n      }\n      if (typeof options === 'function') {\n        options = {\n          callback: options\n        };\n      }\n      if (typeof options.context === 'undefined') {\n        options.context = 4;\n      }\n      if (options.newlineIsToken) {\n        throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n      }\n      if (!options.callback) {\n        return diffLinesResultToPatch(diffLines(oldStr, newStr, options));\n      } else {\n        var _options = options,\n          _callback = _options.callback;\n        diffLines(oldStr, newStr, _objectSpread2(_objectSpread2({}, options), {}, {\n          callback: function callback(diff) {\n            var patch = diffLinesResultToPatch(diff);\n            _callback(patch);\n          }\n        }));\n      }\n      function diffLinesResultToPatch(diff) {\n        // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n        //         of lines containing trailing newline characters. We'll tidy up later...\n\n        if (!diff) {\n          return;\n        }\n        diff.push({\n          value: '',\n          lines: []\n        }); // Append an empty value to make cleanup easier\n\n        function contextLines(lines) {\n          return lines.map(function (entry) {\n            return ' ' + entry;\n          });\n        }\n        var hunks = [];\n        var oldRangeStart = 0,\n          newRangeStart = 0,\n          curRange = [],\n          oldLine = 1,\n          newLine = 1;\n        var _loop = function _loop() {\n          var current = diff[i],\n            lines = current.lines || splitLines(current.value);\n          current.lines = lines;\n          if (current.added || current.removed) {\n            var _curRange;\n            // If we have previous context, start with that\n            if (!oldRangeStart) {\n              var prev = diff[i - 1];\n              oldRangeStart = oldLine;\n              newRangeStart = newLine;\n              if (prev) {\n                curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n                oldRangeStart -= curRange.length;\n                newRangeStart -= curRange.length;\n              }\n            }\n\n            // Output our changes\n            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n              return (current.added ? '+' : '-') + entry;\n            })));\n\n            // Track the updated file position\n            if (current.added) {\n              newLine += lines.length;\n            } else {\n              oldLine += lines.length;\n            }\n          } else {\n            // Identical context lines. Track line changes\n            if (oldRangeStart) {\n              // Close out any changes that have been output (or join overlapping)\n              if (lines.length <= options.context * 2 && i < diff.length - 2) {\n                var _curRange2;\n                // Overlapping\n                (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n              } else {\n                var _curRange3;\n                // end the range and output\n                var contextSize = Math.min(lines.length, options.context);\n                (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n                var _hunk = {\n                  oldStart: oldRangeStart,\n                  oldLines: oldLine - oldRangeStart + contextSize,\n                  newStart: newRangeStart,\n                  newLines: newLine - newRangeStart + contextSize,\n                  lines: curRange\n                };\n                hunks.push(_hunk);\n                oldRangeStart = 0;\n                newRangeStart = 0;\n                curRange = [];\n              }\n            }\n            oldLine += lines.length;\n            newLine += lines.length;\n          }\n        };\n        for (var i = 0; i < diff.length; i++) {\n          _loop();\n        }\n\n        // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n        //         \"\\ No newline at end of file\".\n        for (var _i = 0, _hunks = hunks; _i < _hunks.length; _i++) {\n          var hunk = _hunks[_i];\n          for (var _i2 = 0; _i2 < hunk.lines.length; _i2++) {\n            if (hunk.lines[_i2].endsWith('\\n')) {\n              hunk.lines[_i2] = hunk.lines[_i2].slice(0, -1);\n            } else {\n              hunk.lines.splice(_i2 + 1, 0, '\\\\ No newline at end of file');\n              _i2++; // Skip the line we just added, then continue iterating\n            }\n          }\n        }\n        return {\n          oldFileName: oldFileName,\n          newFileName: newFileName,\n          oldHeader: oldHeader,\n          newHeader: newHeader,\n          hunks: hunks\n        };\n      }\n    }\n    function formatPatch(diff) {\n      if (Array.isArray(diff)) {\n        return diff.map(formatPatch).join('\\n');\n      }\n      var ret = [];\n      if (diff.oldFileName == diff.newFileName) {\n        ret.push('Index: ' + diff.oldFileName);\n      }\n      ret.push('===================================================================');\n      ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n      ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n      for (var i = 0; i < diff.hunks.length; i++) {\n        var hunk = diff.hunks[i];\n        // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n          hunk.oldStart -= 1;\n        }\n        if (hunk.newLines === 0) {\n          hunk.newStart -= 1;\n        }\n        ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n        ret.push.apply(ret, hunk.lines);\n      }\n      return ret.join('\\n') + '\\n';\n    }\n    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n      var _options2;\n      if (typeof options === 'function') {\n        options = {\n          callback: options\n        };\n      }\n      if (!((_options2 = options) !== null && _options2 !== void 0 && _options2.callback)) {\n        var patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n        if (!patchObj) {\n          return;\n        }\n        return formatPatch(patchObj);\n      } else {\n        var _options3 = options,\n          _callback2 = _options3.callback;\n        structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, _objectSpread2(_objectSpread2({}, options), {}, {\n          callback: function callback(patchObj) {\n            if (!patchObj) {\n              _callback2();\n            } else {\n              _callback2(formatPatch(patchObj));\n            }\n          }\n        }));\n      }\n    }\n    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n    }\n\n    /**\n     * Split `text` into an array of lines, including the trailing newline character (where present)\n     */\n    function splitLines(text) {\n      var hasTrailingNl = text.endsWith('\\n');\n      var result = text.split('\\n').map(function (line) {\n        return line + '\\n';\n      });\n      if (hasTrailingNl) {\n        result.pop();\n      } else {\n        result.push(result.pop().slice(0, -1));\n      }\n      return result;\n    }\n\n    function arrayEqual(a, b) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      return arrayStartsWith(a, b);\n    }\n    function arrayStartsWith(array, start) {\n      if (start.length > array.length) {\n        return false;\n      }\n      for (var i = 0; i < start.length; i++) {\n        if (start[i] !== array[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function calcLineCount(hunk) {\n      var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n      if (oldLines !== undefined) {\n        hunk.oldLines = oldLines;\n      } else {\n        delete hunk.oldLines;\n      }\n      if (newLines !== undefined) {\n        hunk.newLines = newLines;\n      } else {\n        delete hunk.newLines;\n      }\n    }\n    function merge(mine, theirs, base) {\n      mine = loadPatch(mine, base);\n      theirs = loadPatch(theirs, base);\n      var ret = {};\n\n      // For index we just let it pass through as it doesn't have any necessary meaning.\n      // Leaving sanity checks on this to the API consumer that may know more about the\n      // meaning in their own context.\n      if (mine.index || theirs.index) {\n        ret.index = mine.index || theirs.index;\n      }\n      if (mine.newFileName || theirs.newFileName) {\n        if (!fileNameChanged(mine)) {\n          // No header or no change in ours, use theirs (and ours if theirs does not exist)\n          ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n          ret.newFileName = theirs.newFileName || mine.newFileName;\n          ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n          ret.newHeader = theirs.newHeader || mine.newHeader;\n        } else if (!fileNameChanged(theirs)) {\n          // No header or no change in theirs, use ours\n          ret.oldFileName = mine.oldFileName;\n          ret.newFileName = mine.newFileName;\n          ret.oldHeader = mine.oldHeader;\n          ret.newHeader = mine.newHeader;\n        } else {\n          // Both changed... figure it out\n          ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n          ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n          ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n          ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n        }\n      }\n      ret.hunks = [];\n      var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n      while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n        var mineCurrent = mine.hunks[mineIndex] || {\n            oldStart: Infinity\n          },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n            oldStart: Infinity\n          };\n        if (hunkBefore(mineCurrent, theirsCurrent)) {\n          // This patch does not overlap with any of the others, yay.\n          ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n          mineIndex++;\n          theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n        } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n          // This patch does not overlap with any of the others, yay.\n          ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n          theirsIndex++;\n          mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n        } else {\n          // Overlap, merge as best we can\n          var mergedHunk = {\n            oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n            oldLines: 0,\n            newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n            newLines: 0,\n            lines: []\n          };\n          mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n          theirsIndex++;\n          mineIndex++;\n          ret.hunks.push(mergedHunk);\n        }\n      }\n      return ret;\n    }\n    function loadPatch(param, base) {\n      if (typeof param === 'string') {\n        if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n          return parsePatch(param)[0];\n        }\n        if (!base) {\n          throw new Error('Must provide a base reference or pass in a patch');\n        }\n        return structuredPatch(undefined, undefined, base, param);\n      }\n      return param;\n    }\n    function fileNameChanged(patch) {\n      return patch.newFileName && patch.newFileName !== patch.oldFileName;\n    }\n    function selectField(index, mine, theirs) {\n      if (mine === theirs) {\n        return mine;\n      } else {\n        index.conflict = true;\n        return {\n          mine: mine,\n          theirs: theirs\n        };\n      }\n    }\n    function hunkBefore(test, check) {\n      return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n    }\n    function cloneHunk(hunk, offset) {\n      return {\n        oldStart: hunk.oldStart,\n        oldLines: hunk.oldLines,\n        newStart: hunk.newStart + offset,\n        newLines: hunk.newLines,\n        lines: hunk.lines\n      };\n    }\n    function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n      // This will generally result in a conflicted hunk, but there are cases where the context\n      // is the only overlap where we can successfully merge the content here.\n      var mine = {\n          offset: mineOffset,\n          lines: mineLines,\n          index: 0\n        },\n        their = {\n          offset: theirOffset,\n          lines: theirLines,\n          index: 0\n        };\n\n      // Handle any leading content\n      insertLeading(hunk, mine, their);\n      insertLeading(hunk, their, mine);\n\n      // Now in the overlap content. Scan through and select the best changes from each.\n      while (mine.index < mine.lines.length && their.index < their.lines.length) {\n        var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n        if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n          // Both modified ...\n          mutualChange(hunk, mine, their);\n        } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n          var _hunk$lines;\n          // Mine inserted\n          (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n        } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n          var _hunk$lines2;\n          // Theirs inserted\n          (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n        } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n          // Mine removed or edited\n          removal(hunk, mine, their);\n        } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n          // Their removed or edited\n          removal(hunk, their, mine, true);\n        } else if (mineCurrent === theirCurrent) {\n          // Context identity\n          hunk.lines.push(mineCurrent);\n          mine.index++;\n          their.index++;\n        } else {\n          // Context mismatch\n          conflict(hunk, collectChange(mine), collectChange(their));\n        }\n      }\n\n      // Now push anything that may be remaining\n      insertTrailing(hunk, mine);\n      insertTrailing(hunk, their);\n      calcLineCount(hunk);\n    }\n    function mutualChange(hunk, mine, their) {\n      var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n      if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n        // Special case for remove changes that are supersets of one another\n        if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n          var _hunk$lines3;\n          (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n          return;\n        } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n          var _hunk$lines4;\n          (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n          return;\n        }\n      } else if (arrayEqual(myChanges, theirChanges)) {\n        var _hunk$lines5;\n        (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n        return;\n      }\n      conflict(hunk, myChanges, theirChanges);\n    }\n    function removal(hunk, mine, their, swap) {\n      var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n      if (theirChanges.merged) {\n        var _hunk$lines6;\n        (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n      } else {\n        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n      }\n    }\n    function conflict(hunk, mine, their) {\n      hunk.conflict = true;\n      hunk.lines.push({\n        conflict: true,\n        mine: mine,\n        theirs: their\n      });\n    }\n    function insertLeading(hunk, insert, their) {\n      while (insert.offset < their.offset && insert.index < insert.lines.length) {\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n        insert.offset++;\n      }\n    }\n    function insertTrailing(hunk, insert) {\n      while (insert.index < insert.lines.length) {\n        var line = insert.lines[insert.index++];\n        hunk.lines.push(line);\n      }\n    }\n    function collectChange(state) {\n      var ret = [],\n        operation = state.lines[state.index][0];\n      while (state.index < state.lines.length) {\n        var line = state.lines[state.index];\n\n        // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n        if (operation === '-' && line[0] === '+') {\n          operation = '+';\n        }\n        if (operation === line[0]) {\n          ret.push(line);\n          state.index++;\n        } else {\n          break;\n        }\n      }\n      return ret;\n    }\n    function collectContext(state, matchChanges) {\n      var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n      while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n        var change = state.lines[state.index],\n          match = matchChanges[matchIndex];\n\n        // Once we've hit our add, then we are done\n        if (match[0] === '+') {\n          break;\n        }\n        contextChanges = contextChanges || change[0] !== ' ';\n        merged.push(match);\n        matchIndex++;\n\n        // Consume any additions in the other block as a conflict to attempt\n        // to pull in the remaining context after this\n        if (change[0] === '+') {\n          conflicted = true;\n          while (change[0] === '+') {\n            changes.push(change);\n            change = state.lines[++state.index];\n          }\n        }\n        if (match.substr(1) === change.substr(1)) {\n          changes.push(change);\n          state.index++;\n        } else {\n          conflicted = true;\n        }\n      }\n      if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n        conflicted = true;\n      }\n      if (conflicted) {\n        return changes;\n      }\n      while (matchIndex < matchChanges.length) {\n        merged.push(matchChanges[matchIndex++]);\n      }\n      return {\n        merged: merged,\n        changes: changes\n      };\n    }\n    function allRemoves(changes) {\n      return changes.reduce(function (prev, change) {\n        return prev && change[0] === '-';\n      }, true);\n    }\n    function skipRemoveSuperset(state, removeChanges, delta) {\n      for (var i = 0; i < delta; i++) {\n        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n        if (state.lines[state.index + i] !== ' ' + changeContent) {\n          return false;\n        }\n      }\n      state.index += delta;\n      return true;\n    }\n    function calcOldNewLineCount(lines) {\n      var oldLines = 0;\n      var newLines = 0;\n      lines.forEach(function (line) {\n        if (typeof line !== 'string') {\n          var myCount = calcOldNewLineCount(line.mine);\n          var theirCount = calcOldNewLineCount(line.theirs);\n          if (oldLines !== undefined) {\n            if (myCount.oldLines === theirCount.oldLines) {\n              oldLines += myCount.oldLines;\n            } else {\n              oldLines = undefined;\n            }\n          }\n          if (newLines !== undefined) {\n            if (myCount.newLines === theirCount.newLines) {\n              newLines += myCount.newLines;\n            } else {\n              newLines = undefined;\n            }\n          }\n        } else {\n          if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n            newLines++;\n          }\n          if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n            oldLines++;\n          }\n        }\n      });\n      return {\n        oldLines: oldLines,\n        newLines: newLines\n      };\n    }\n\n    function reversePatch(structuredPatch) {\n      if (Array.isArray(structuredPatch)) {\n        return structuredPatch.map(reversePatch).reverse();\n      }\n      return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n        oldFileName: structuredPatch.newFileName,\n        oldHeader: structuredPatch.newHeader,\n        newFileName: structuredPatch.oldFileName,\n        newHeader: structuredPatch.oldHeader,\n        hunks: structuredPatch.hunks.map(function (hunk) {\n          return {\n            oldLines: hunk.newLines,\n            oldStart: hunk.newStart,\n            newLines: hunk.oldLines,\n            newStart: hunk.oldStart,\n            lines: hunk.lines.map(function (l) {\n              if (l.startsWith('-')) {\n                return \"+\".concat(l.slice(1));\n              }\n              if (l.startsWith('+')) {\n                return \"-\".concat(l.slice(1));\n              }\n              return l;\n            })\n          };\n        })\n      });\n    }\n\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    function convertChangesToDMP(changes) {\n      var ret = [],\n        change,\n        operation;\n      for (var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        if (change.added) {\n          operation = 1;\n        } else if (change.removed) {\n          operation = -1;\n        } else {\n          operation = 0;\n        }\n        ret.push([operation, change.value]);\n      }\n      return ret;\n    }\n\n    function convertChangesToXML(changes) {\n      var ret = [];\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push('<ins>');\n        } else if (change.removed) {\n          ret.push('<del>');\n        }\n        ret.push(escapeHTML(change.value));\n        if (change.added) {\n          ret.push('</ins>');\n        } else if (change.removed) {\n          ret.push('</del>');\n        }\n      }\n      return ret.join('');\n    }\n    function escapeHTML(s) {\n      var n = s;\n      n = n.replace(/&/g, '&amp;');\n      n = n.replace(/</g, '&lt;');\n      n = n.replace(/>/g, '&gt;');\n      n = n.replace(/\"/g, '&quot;');\n      return n;\n    }\n\n    exports.Diff = Diff;\n    exports.applyPatch = applyPatch;\n    exports.applyPatches = applyPatches;\n    exports.canonicalize = canonicalize;\n    exports.convertChangesToDMP = convertChangesToDMP;\n    exports.convertChangesToXML = convertChangesToXML;\n    exports.createPatch = createPatch;\n    exports.createTwoFilesPatch = createTwoFilesPatch;\n    exports.diffArrays = diffArrays;\n    exports.diffChars = diffChars;\n    exports.diffCss = diffCss;\n    exports.diffJson = diffJson;\n    exports.diffLines = diffLines;\n    exports.diffSentences = diffSentences;\n    exports.diffTrimmedLines = diffTrimmedLines;\n    exports.diffWords = diffWords;\n    exports.diffWordsWithSpace = diffWordsWithSpace;\n    exports.formatPatch = formatPatch;\n    exports.merge = merge;\n    exports.parsePatch = parsePatch;\n    exports.reversePatch = reversePatch;\n    exports.structuredPatch = structuredPatch;\n\n  }));\n\n  },{}],93:[function(require,module,exports){\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** `Object#toString` result references. */\n  var funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      symbolTag = '[object Symbol]';\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      reLeadingDot = /^\\./,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof _polyfillNode_process.global == 'object' && _polyfillNode_process.global && _polyfillNode_process.global.Object === Object && _polyfillNode_process.global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `value` is a host object in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n   */\n  function isHostObject(value) {\n    // Many host objects are `Object` objects that can coerce to strings\n    // despite having improperly defined `toString` methods.\n    var result = false;\n    if (value != null && typeof value.toString != 'function') {\n      try {\n        result = !!(value + '');\n      } catch (e) {}\n    }\n    return result;\n  }\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype,\n      funcProto = Function.prototype,\n      objectProto = Object.prototype;\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root['__core-js_shared__'];\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function() {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? ('Symbol(src)_1.' + uid) : '';\n  }());\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp('^' +\n    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n  );\n\n  /** Built-in value references. */\n  var Symbol = root.Symbol,\n      splice = arrayProto.splice;\n\n  /* Built-in method references that are verified to be native. */\n  var Map = getNative(root, 'Map'),\n      nativeCreate = getNative(Object, 'create');\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  }\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    return this.has(key) && delete this.__data__[key];\n  }\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__;\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n  }\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n  }\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__;\n    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n    return this;\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = [];\n  }\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    return true;\n  }\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.__data__ = {\n      'hash': new Hash,\n      'map': new (Map || ListCache),\n      'string': new Hash\n    };\n  }\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    return getMapData(this, key)['delete'](key);\n  }\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    getMapData(this, key).set(key, value);\n    return this;\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n    return (index && index == length) ? object : undefined;\n  }\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;\n  }\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value) {\n    return isArray(value) ? value : stringToPath(value);\n  }\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key)\n      ? data[typeof key == 'string' ? 'string' : 'hash']\n      : data.map;\n  }\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n    var type = typeof value;\n    if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n        value == null || isSymbol(value)) {\n      return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n      (object != null && value in Object(object));\n  }\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value;\n    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n      ? (value !== '__proto__')\n      : (value === null);\n  }\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && (maskSrcKey in func);\n  }\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = memoize(function(string) {\n    string = toString(string);\n\n    var result = [];\n    if (reLeadingDot.test(string)) {\n      result.push('');\n    }\n    string.replace(rePropName, function(match, number, quote, string) {\n      result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n    });\n    return result;\n  });\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;\n  }\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to process.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n      try {\n        return (func + '');\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result);\n      return result;\n    };\n    memoized.cache = new (memoize.Cache || MapCache);\n    return memoized;\n  }\n\n  // Assign cache to `_.memoize`.\n  memoize.Cache = MapCache;\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other);\n  }\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray;\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 8-9 which returns 'object' for typed array and other constructors.\n    var tag = isObject(value) ? objectToString.call(value) : '';\n    return tag == funcTag || tag == genTag;\n  }\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value;\n    return !!value && (type == 'object' || type == 'function');\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike(value) && objectToString.call(value) == symbolTag);\n  }\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n\n  module.exports = get;\n\n  },{}],94:[function(require,module,exports){\n  module.exports = {\n  \tstdout: false,\n  \tstderr: false\n  };\n\n  },{}],95:[function(require,module,exports){\n  (function (global, factory) {\n  \ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  \ttypeof define === 'function' && define.amd ? define(factory) :\n  \t(global.typeDetect = factory());\n  }(this, (function () {\n  /* !\n   * type-detect\n   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n   * MIT Licensed\n   */\n  var promiseExists = typeof Promise === 'function';\n\n  /* eslint-disable no-undef */\n  var globalObject = typeof self === 'object' ? self : _polyfillNode_process.global; // eslint-disable-line id-blacklist\n\n  var symbolExists = typeof Symbol !== 'undefined';\n  var mapExists = typeof Map !== 'undefined';\n  var setExists = typeof Set !== 'undefined';\n  var weakMapExists = typeof WeakMap !== 'undefined';\n  var weakSetExists = typeof WeakSet !== 'undefined';\n  var dataViewExists = typeof DataView !== 'undefined';\n  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\n  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\n  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\n  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\n  var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\n  var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\n  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\n  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\n  var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\n  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\n  var toStringLeftSliceLength = 8;\n  var toStringRightSliceLength = -1;\n  /**\n   * ### typeOf (obj)\n   *\n   * Uses `Object.prototype.toString` to determine the type of an object,\n   * normalising behaviour across engine versions & well optimised.\n   *\n   * @param {Mixed} object\n   * @return {String} object type\n   * @api public\n   */\n  function typeDetect(obj) {\n    /* ! Speed optimisation\n     * Pre:\n     *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)\n     *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)\n     *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)\n     *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)\n     *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)\n     * Post:\n     *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)\n     *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)\n     *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)\n     *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)\n     *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)\n     */\n    var typeofObj = typeof obj;\n    if (typeofObj !== 'object') {\n      return typeofObj;\n    }\n\n    /* ! Speed optimisation\n     * Pre:\n     *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)\n     * Post:\n     *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)\n     */\n    if (obj === null) {\n      return 'null';\n    }\n\n    /* ! Spec Conformance\n     * Test: `Object.prototype.toString.call(window)``\n     *  - Node === \"[object global]\"\n     *  - Chrome === \"[object global]\"\n     *  - Firefox === \"[object Window]\"\n     *  - PhantomJS === \"[object Window]\"\n     *  - Safari === \"[object Window]\"\n     *  - IE 11 === \"[object Window]\"\n     *  - IE Edge === \"[object Window]\"\n     * Test: `Object.prototype.toString.call(this)``\n     *  - Chrome Worker === \"[object global]\"\n     *  - Firefox Worker === \"[object DedicatedWorkerGlobalScope]\"\n     *  - Safari Worker === \"[object DedicatedWorkerGlobalScope]\"\n     *  - IE 11 Worker === \"[object WorkerGlobalScope]\"\n     *  - IE Edge Worker === \"[object WorkerGlobalScope]\"\n     */\n    if (obj === globalObject) {\n      return 'global';\n    }\n\n    /* ! Speed optimisation\n     * Pre:\n     *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)\n     * Post:\n     *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)\n     */\n    if (\n      Array.isArray(obj) &&\n      (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))\n    ) {\n      return 'Array';\n    }\n\n    // Not caching existence of `window` and related properties due to potential\n    // for `window` to be unset before tests in quasi-browser environments.\n    if (typeof window === 'object' && window !== null) {\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/multipage/browsers.html#location)\n       * WhatWG HTML$7.7.3 - The `Location` interface\n       * Test: `Object.prototype.toString.call(window.location)``\n       *  - IE <=11 === \"[object Object]\"\n       *  - IE Edge <=13 === \"[object Object]\"\n       */\n      if (typeof window.location === 'object' && obj === window.location) {\n        return 'Location';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/#document)\n       * WhatWG HTML$3.1.1 - The `Document` object\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\n       *       which suggests that browsers should use HTMLTableCellElement for\n       *       both TD and TH elements. WhatWG separates these.\n       *       WhatWG HTML states:\n       *         > For historical reasons, Window objects must also have a\n       *         > writable, configurable, non-enumerable property named\n       *         > HTMLDocument whose value is the Document interface object.\n       * Test: `Object.prototype.toString.call(document)``\n       *  - Chrome === \"[object HTMLDocument]\"\n       *  - Firefox === \"[object HTMLDocument]\"\n       *  - Safari === \"[object HTMLDocument]\"\n       *  - IE <=10 === \"[object Document]\"\n       *  - IE 11 === \"[object HTMLDocument]\"\n       *  - IE Edge <=13 === \"[object HTMLDocument]\"\n       */\n      if (typeof window.document === 'object' && obj === window.document) {\n        return 'Document';\n      }\n\n      if (typeof window.navigator === 'object') {\n        /* ! Spec Conformance\n         * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\n         * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\n         * Test: `Object.prototype.toString.call(navigator.mimeTypes)``\n         *  - IE <=10 === \"[object MSMimeTypesCollection]\"\n         */\n        if (typeof window.navigator.mimeTypes === 'object' &&\n            obj === window.navigator.mimeTypes) {\n          return 'MimeTypeArray';\n        }\n\n        /* ! Spec Conformance\n         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n         * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\n         * Test: `Object.prototype.toString.call(navigator.plugins)``\n         *  - IE <=10 === \"[object MSPluginsCollection]\"\n         */\n        if (typeof window.navigator.plugins === 'object' &&\n            obj === window.navigator.plugins) {\n          return 'PluginArray';\n        }\n      }\n\n      if ((typeof window.HTMLElement === 'function' ||\n          typeof window.HTMLElement === 'object') &&\n          obj instanceof window.HTMLElement) {\n        /* ! Spec Conformance\n        * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n        * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\n        * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``\n        *  - IE <=10 === \"[object HTMLBlockElement]\"\n        */\n        if (obj.tagName === 'BLOCKQUOTE') {\n          return 'HTMLQuoteElement';\n        }\n\n        /* ! Spec Conformance\n         * (https://html.spec.whatwg.org/#htmltabledatacellelement)\n         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\n         * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n         *       which suggests that browsers should use HTMLTableCellElement for\n         *       both TD and TH elements. WhatWG separates these.\n         * Test: Object.prototype.toString.call(document.createElement('td'))\n         *  - Chrome === \"[object HTMLTableCellElement]\"\n         *  - Firefox === \"[object HTMLTableCellElement]\"\n         *  - Safari === \"[object HTMLTableCellElement]\"\n         */\n        if (obj.tagName === 'TD') {\n          return 'HTMLTableDataCellElement';\n        }\n\n        /* ! Spec Conformance\n         * (https://html.spec.whatwg.org/#htmltableheadercellelement)\n         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\n         * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n         *       which suggests that browsers should use HTMLTableCellElement for\n         *       both TD and TH elements. WhatWG separates these.\n         * Test: Object.prototype.toString.call(document.createElement('th'))\n         *  - Chrome === \"[object HTMLTableCellElement]\"\n         *  - Firefox === \"[object HTMLTableCellElement]\"\n         *  - Safari === \"[object HTMLTableCellElement]\"\n         */\n        if (obj.tagName === 'TH') {\n          return 'HTMLTableHeaderCellElement';\n        }\n      }\n    }\n\n    /* ! Speed optimisation\n    * Pre:\n    *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)\n    *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)\n    *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)\n    *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)\n    *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)\n    *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)\n    *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)\n    *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)\n    *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)\n    * Post:\n    *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)\n    *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)\n    *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)\n    *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)\n    *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)\n    *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)\n    *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)\n    *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)\n    *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)\n    */\n    var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\n    if (typeof stringTag === 'string') {\n      return stringTag;\n    }\n\n    var objPrototype = Object.getPrototypeOf(obj);\n    /* ! Speed optimisation\n    * Pre:\n    *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)\n    *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)\n    * Post:\n    *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)\n    *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)\n    */\n    if (objPrototype === RegExp.prototype) {\n      return 'RegExp';\n    }\n\n    /* ! Speed optimisation\n    * Pre:\n    *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)\n    * Post:\n    *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)\n    */\n    if (objPrototype === Date.prototype) {\n      return 'Date';\n    }\n\n    /* ! Spec Conformance\n     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\n     * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \"Promise\":\n     * Test: `Object.prototype.toString.call(Promise.resolve())``\n     *  - Chrome <=47 === \"[object Object]\"\n     *  - Edge <=20 === \"[object Object]\"\n     *  - Firefox 29-Latest === \"[object Promise]\"\n     *  - Safari 7.1-Latest === \"[object Promise]\"\n     */\n    if (promiseExists && objPrototype === Promise.prototype) {\n      return 'Promise';\n    }\n\n    /* ! Speed optimisation\n    * Pre:\n    *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)\n    * Post:\n    *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)\n    */\n    if (setExists && objPrototype === Set.prototype) {\n      return 'Set';\n    }\n\n    /* ! Speed optimisation\n    * Pre:\n    *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)\n    * Post:\n    *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)\n    */\n    if (mapExists && objPrototype === Map.prototype) {\n      return 'Map';\n    }\n\n    /* ! Speed optimisation\n    * Pre:\n    *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)\n    * Post:\n    *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)\n    */\n    if (weakSetExists && objPrototype === WeakSet.prototype) {\n      return 'WeakSet';\n    }\n\n    /* ! Speed optimisation\n    * Pre:\n    *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)\n    * Post:\n    *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)\n    */\n    if (weakMapExists && objPrototype === WeakMap.prototype) {\n      return 'WeakMap';\n    }\n\n    /* ! Spec Conformance\n     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\n     * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \"DataView\":\n     * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\n     *  - Edge <=13 === \"[object Object]\"\n     */\n    if (dataViewExists && objPrototype === DataView.prototype) {\n      return 'DataView';\n    }\n\n    /* ! Spec Conformance\n     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\n     * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \"Map Iterator\":\n     * Test: `Object.prototype.toString.call(new Map().entries())``\n     *  - Edge <=13 === \"[object Object]\"\n     */\n    if (mapExists && objPrototype === mapIteratorPrototype) {\n      return 'Map Iterator';\n    }\n\n    /* ! Spec Conformance\n     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\n     * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \"Set Iterator\":\n     * Test: `Object.prototype.toString.call(new Set().entries())``\n     *  - Edge <=13 === \"[object Object]\"\n     */\n    if (setExists && objPrototype === setIteratorPrototype) {\n      return 'Set Iterator';\n    }\n\n    /* ! Spec Conformance\n     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\n     * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \"Array Iterator\":\n     * Test: `Object.prototype.toString.call([][Symbol.iterator]())``\n     *  - Edge <=13 === \"[object Object]\"\n     */\n    if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\n      return 'Array Iterator';\n    }\n\n    /* ! Spec Conformance\n     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\n     * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \"String Iterator\":\n     * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``\n     *  - Edge <=13 === \"[object Object]\"\n     */\n    if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\n      return 'String Iterator';\n    }\n\n    /* ! Speed optimisation\n    * Pre:\n    *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)\n    * Post:\n    *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)\n    */\n    if (objPrototype === null) {\n      return 'Object';\n    }\n\n    return Object\n      .prototype\n      .toString\n      .call(obj)\n      .slice(toStringLeftSliceLength, toStringRightSliceLength);\n  }\n\n  return typeDetect;\n\n  })));\n\n  },{}]},{},[2]);\n\n  var defExp = sinon;\n  const _leakThreshold = sinon.leakThreshold;\n  const _assert = sinon.assert;\n  const _getFakes = sinon.getFakes;\n  const _createStubInstance = sinon.createStubInstance;\n  const _inject = sinon.inject;\n  const _mock = sinon.mock;\n  const _reset = sinon.reset;\n  const _resetBehavior = sinon.resetBehavior;\n  const _resetHistory = sinon.resetHistory;\n  const _restore = sinon.restore;\n  const _restoreContext = sinon.restoreContext;\n  const _replace = sinon.replace;\n  const _define = sinon.define;\n  const _replaceGetter = sinon.replaceGetter;\n  const _replaceSetter = sinon.replaceSetter;\n  const _spy = sinon.spy;\n  const _stub = sinon.stub;\n  const _fake = sinon.fake;\n  const _useFakeTimers = sinon.useFakeTimers;\n  const _verify = sinon.verify;\n  const _verifyAndRestore = sinon.verifyAndRestore;\n  const _createSandbox = sinon.createSandbox;\n  const _match = sinon.match;\n  const _restoreObject = sinon.restoreObject;\n  const _expectation = sinon.expectation;\n  const _timers = sinon.timers;\n  const _addBehavior = sinon.addBehavior;\n  const _promise = sinon.promise;\n\n  var namedExports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    addBehavior: _addBehavior,\n    assert: _assert,\n    createSandbox: _createSandbox,\n    createStubInstance: _createStubInstance,\n    default: defExp,\n    define: _define,\n    expectation: _expectation,\n    fake: _fake,\n    getFakes: _getFakes,\n    inject: _inject,\n    leakThreshold: _leakThreshold,\n    match: _match,\n    mock: _mock,\n    promise: _promise,\n    replace: _replace,\n    replaceGetter: _replaceGetter,\n    replaceSetter: _replaceSetter,\n    reset: _reset,\n    resetBehavior: _resetBehavior,\n    resetHistory: _resetHistory,\n    restore: _restore,\n    restoreContext: _restoreContext,\n    restoreObject: _restoreObject,\n    spy: _spy,\n    stub: _stub,\n    timers: _timers,\n    useFakeTimers: _useFakeTimers,\n    verify: _verify,\n    verifyAndRestore: _verifyAndRestore\n  });\n\n  const defaultExports = Object.isFrozen(defExp) ? Object.assign({}, defExp?.default || defExp || { __emptyModule: true }) : defExp;\n  Object.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n  Object.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n  var sinonEsm = Object.isFrozen(defExp) ? Object.freeze(defaultExports) : defaultExports;\n\n  return sinonEsm;\n\n}));\n",
      "relatedPaths": [
        "/Users/i573017/SAPDevelop/Private/Repositories/com.testing.unit/node_modules/sinon/pkg/sinon-esm.js"
      ],
      "imports": [
        "node.process.js"
      ],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "qunit",
      "path": "/Users/i573017/SAPDevelop/Private/Repositories/com.testing.unit/node_modules/qunit/qunit/qunit.js",
      "lastModified": 1753218426783,
      "type": "module",
      "originalName": "qunit",
      "code": "sap.ui.define(['./node.process'], (function (_polyfillNode_process) { 'use strict';\n\n\tfunction _mergeNamespaces(n, m) {\n\t\tm.forEach(function (e) {\n\t\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn Object.freeze(n);\n\t}\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction getDefaultExportFromCjs (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tvar qunit$1 = {exports: {}};\n\n\tvar hasRequiredQunit;\n\n\tfunction requireQunit () {\n\t\tif (hasRequiredQunit) return qunit$1.exports;\n\t\thasRequiredQunit = 1;\n\t\t(function (module, exports) {\n\t\t\t(function () {\n\n\t\t\t  function _arrayLikeToArray(r, a) {\n\t\t\t    (null == a || a > r.length) && (a = r.length);\n\t\t\t    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n\t\t\t    return n;\n\t\t\t  }\n\t\t\t  function _arrayWithHoles(r) {\n\t\t\t    if (Array.isArray(r)) return r;\n\t\t\t  }\n\t\t\t  function _arrayWithoutHoles(r) {\n\t\t\t    if (Array.isArray(r)) return _arrayLikeToArray(r);\n\t\t\t  }\n\t\t\t  function _classCallCheck(a, n) {\n\t\t\t    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n\t\t\t  }\n\t\t\t  function _defineProperties(e, r) {\n\t\t\t    for (var t = 0; t < r.length; t++) {\n\t\t\t      var o = r[t];\n\t\t\t      o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function _createClass(e, r, t) {\n\t\t\t    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n\t\t\t      writable: false\n\t\t\t    }), e;\n\t\t\t  }\n\t\t\t  function _iterableToArray(r) {\n\t\t\t    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n\t\t\t  }\n\t\t\t  function _iterableToArrayLimit(r, l) {\n\t\t\t    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n\t\t\t    if (null != t) {\n\t\t\t      var e,\n\t\t\t        n,\n\t\t\t        i,\n\t\t\t        u,\n\t\t\t        a = [],\n\t\t\t        f = true,\n\t\t\t        o = false;\n\t\t\t      try {\n\t\t\t        if (i = (t = t.call(r)).next, 0 === l) {\n\t\t\t          if (Object(t) !== t) return;\n\t\t\t          f = !1;\n\t\t\t        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n\t\t\t      } catch (r) {\n\t\t\t        o = true, n = r;\n\t\t\t      } finally {\n\t\t\t        try {\n\t\t\t          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n\t\t\t        } finally {\n\t\t\t          if (o) throw n;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return a;\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function _nonIterableRest() {\n\t\t\t    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n\t\t\t  }\n\t\t\t  function _nonIterableSpread() {\n\t\t\t    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n\t\t\t  }\n\t\t\t  function _slicedToArray(r, e) {\n\t\t\t    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n\t\t\t  }\n\t\t\t  function _toConsumableArray(r) {\n\t\t\t    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n\t\t\t  }\n\t\t\t  function _toPrimitive(t, r) {\n\t\t\t    if (\"object\" != typeof t || !t) return t;\n\t\t\t    var e = t[Symbol.toPrimitive];\n\t\t\t    if (void 0 !== e) {\n\t\t\t      var i = e.call(t, r);\n\t\t\t      if (\"object\" != typeof i) return i;\n\t\t\t      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t\t\t    }\n\t\t\t    return (String )(t);\n\t\t\t  }\n\t\t\t  function _toPropertyKey(t) {\n\t\t\t    var i = _toPrimitive(t, \"string\");\n\t\t\t    return \"symbol\" == typeof i ? i : i + \"\";\n\t\t\t  }\n\t\t\t  function _typeof(o) {\n\t\t\t    \"@babel/helpers - typeof\";\n\n\t\t\t    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n\t\t\t      return typeof o;\n\t\t\t    } : function (o) {\n\t\t\t      return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n\t\t\t    }, _typeof(o);\n\t\t\t  }\n\t\t\t  function _unsupportedIterableToArray(r, a) {\n\t\t\t    if (r) {\n\t\t\t      if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n\t\t\t      var t = {}.toString.call(r).slice(8, -1);\n\t\t\t      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  // We don't use global-this-polyfill [1], because it modifies\n\t\t\t  // the globals scope by default. QUnit must not affect the host context\n\t\t\t  // as developers may test their project may be such a polyfill, and/or\n\t\t\t  // they may intentionally test their project with and without certain\n\t\t\t  // polyfills and we must not affect that. It also uses an obscure\n\t\t\t  // mechanism that seems to sometimes causes a runtime error in older\n\t\t\t  // browsers (specifically Safari and IE versions that support\n\t\t\t  // Object.defineProperty but then report _T_ as undefined).\n\t\t\t  // [1] https://github.com/ungap/global-this/blob/v0.4.4/esm/index.js\n\t\t\t  //\n\t\t\t  // Another way is `Function('return this')()`, but doing so relies\n\t\t\t  // on eval which will cause a CSP error on some servers.\n\t\t\t  //\n\t\t\t  // Instead, simply check the four options that already exist\n\t\t\t  // in all supported environments.\n\t\t\t  function getGlobalThis() {\n\t\t\t    if (typeof globalThis !== 'undefined') {\n\t\t\t      // For SpiderMonkey, modern browsers, and recent Node.js\n\t\t\t      // eslint-disable-next-line no-undef\n\t\t\t      return globalThis;\n\t\t\t    }\n\t\t\t    if (typeof self !== 'undefined') {\n\t\t\t      // For web workers\n\t\t\t      // eslint-disable-next-line no-undef\n\t\t\t      return self;\n\t\t\t    }\n\t\t\t    if (typeof window$1 !== 'undefined') {\n\t\t\t      // For document context in browsers\n\t\t\t      return window$1;\n\t\t\t    }\n\t\t\t    if (typeof commonjsGlobal !== 'undefined') {\n\t\t\t      // For Node.js\n\t\t\t      // eslint-disable-next-line no-undef\n\t\t\t      return commonjsGlobal;\n\t\t\t    }\n\t\t\t    throw new Error('Unable to locate global object');\n\t\t\t  }\n\n\t\t\t  // This avoids a simple `export const` assignment as that would lead Rollup\n\t\t\t  // to change getGlobalThis and use the same (generated) variable name there.\n\t\t\t  var g = getGlobalThis();\n\n\t\t\t  // These optional globals are undefined in one or more environments:\n\t\t\t  // modern browser, old browser, Node.js, SpiderMonkey.\n\t\t\t  // Calling code must check these for truthy-ness before use.\n\t\t\t  var console$1 = g.console;\n\t\t\t  var setTimeout$1 = g.setTimeout;\n\t\t\t  var clearTimeout = g.clearTimeout;\n\t\t\t  var process$1 = g.process;\n\t\t\t  var window$1 = g.window;\n\t\t\t  var document = window$1 && window$1.document;\n\t\t\t  var navigator = window$1 && window$1.navigator;\n\t\t\t  var localSessionStorage = function () {\n\t\t\t    var x = 'qunit-test-string';\n\t\t\t    try {\n\t\t\t      g.sessionStorage.setItem(x, x);\n\t\t\t      g.sessionStorage.removeItem(x);\n\t\t\t      return g.sessionStorage;\n\t\t\t    } catch (e) {\n\t\t\t      return undefined;\n\t\t\t    }\n\t\t\t  }();\n\n\t\t\t  // Basic fallback for ES6 Map\n\t\t\t  // Support: IE 9-10, Safari 7, PhantomJS; Map is undefined\n\t\t\t  // Support: iOS 8; `new Map(iterable)` is not supported\n\t\t\t  //\n\t\t\t  // Fallback for ES7 Map#keys\n\t\t\t  // Support: IE 11; Map#keys is undefined\n\t\t\t  var StringMap = typeof g.Map === 'function' && typeof g.Map.prototype.keys === 'function' && typeof g.Symbol === 'function' && _typeof(g.Symbol.iterator) === 'symbol' ? g.Map : function StringMap(input) {\n\t\t\t    var _this = this;\n\t\t\t    var store = Object.create(null);\n\t\t\t    var hasOwn = Object.prototype.hasOwnProperty;\n\t\t\t    this.has = function (strKey) {\n\t\t\t      return hasOwn.call(store, strKey);\n\t\t\t    };\n\t\t\t    this.get = function (strKey) {\n\t\t\t      return store[strKey];\n\t\t\t    };\n\t\t\t    this.set = function (strKey, val) {\n\t\t\t      if (!hasOwn.call(store, strKey)) {\n\t\t\t        this.size++;\n\t\t\t      }\n\t\t\t      store[strKey] = val;\n\t\t\t      return this;\n\t\t\t    };\n\t\t\t    this.delete = function (strKey) {\n\t\t\t      if (hasOwn.call(store, strKey)) {\n\t\t\t        delete store[strKey];\n\t\t\t        this.size--;\n\t\t\t      }\n\t\t\t    };\n\t\t\t    this.forEach = function (callback) {\n\t\t\t      for (var strKey in store) {\n\t\t\t        callback(store[strKey], strKey);\n\t\t\t      }\n\t\t\t    };\n\t\t\t    this.keys = function () {\n\t\t\t      return Object.keys(store);\n\t\t\t    };\n\t\t\t    this.clear = function () {\n\t\t\t      store = Object.create(null);\n\t\t\t      this.size = 0;\n\t\t\t    };\n\t\t\t    this.size = 0;\n\t\t\t    if (input) {\n\t\t\t      input.forEach(function (val, strKey) {\n\t\t\t        _this.set(strKey, val);\n\t\t\t      });\n\t\t\t    }\n\t\t\t  };\n\n\t\t\t  // Basic fallback for ES6 Set\n\t\t\t  // Support: IE 11, `new Set(iterable)` parameter not yet implemented\n\t\t\t  // Test for Set#values() which came after Set(iterable).\n\t\t\t  var StringSet = typeof g.Set === 'function' && typeof g.Set.prototype.values === 'function' ? g.Set : function (input) {\n\t\t\t    var set = Object.create(null);\n\t\t\t    if (Array.isArray(input)) {\n\t\t\t      input.forEach(function (item) {\n\t\t\t        set[item] = true;\n\t\t\t      });\n\t\t\t    }\n\t\t\t    return {\n\t\t\t      add: function add(value) {\n\t\t\t        set[value] = true;\n\t\t\t      },\n\t\t\t      has: function has(value) {\n\t\t\t        return value in set;\n\t\t\t      },\n\t\t\t      get size() {\n\t\t\t        return Object.keys(set).length;\n\t\t\t      }\n\t\t\t    };\n\t\t\t  };\n\n\t\t\t  var toString = Object.prototype.toString;\n\t\t\t  var hasOwn$1 = Object.prototype.hasOwnProperty;\n\t\t\t  var performance = {\n\t\t\t    // eslint-disable-next-line compat/compat -- Checked\n\t\t\t    now: window$1 && window$1.performance && window$1.performance.now ? window$1.performance.now.bind(window$1.performance) : Date.now\n\t\t\t  };\n\n\t\t\t  // Returns a new Array with the elements that are in a but not in b\n\t\t\t  function diff$1(a, b) {\n\t\t\t    return a.filter(function (a) {\n\t\t\t      return b.indexOf(a) === -1;\n\t\t\t    });\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Determines whether an element exists in a given array or not.\n\t\t\t   *\n\t\t\t   * @method inArray\n\t\t\t   * @param {any} elem\n\t\t\t   * @param {Array} array\n\t\t\t   * @return {boolean}\n\t\t\t   */\n\t\t\t  var inArray = Array.prototype.includes ? function (elem, array) {\n\t\t\t    return array.includes(elem);\n\t\t\t  } : function (elem, array) {\n\t\t\t    return array.indexOf(elem) !== -1;\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Recursively clone an object into a plain array or object, taking only the\n\t\t\t   * own enumerable properties.\n\t\t\t   *\n\t\t\t   * @param {any} obj\n\t\t\t   * @param {bool} [allowArray=true]\n\t\t\t   * @return {Object|Array}\n\t\t\t   */\n\t\t\t  function objectValues(obj) {\n\t\t\t    var allowArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\t\t    var vals = allowArray && is('array', obj) ? [] : {};\n\t\t\t    for (var key in obj) {\n\t\t\t      if (hasOwn$1.call(obj, key)) {\n\t\t\t        var val = obj[key];\n\t\t\t        vals[key] = val === Object(val) ? objectValues(val, allowArray) : val;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return vals;\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Recursively clone an object into a plain object, taking only the\n\t\t\t   * subset of own enumerable properties that exist a given model.\n\t\t\t   *\n\t\t\t   * @param {any} obj\n\t\t\t   * @param {any} model\n\t\t\t   * @return {Object}\n\t\t\t   */\n\t\t\t  function objectValuesSubset(obj, model) {\n\t\t\t    // Return primitive values unchanged to avoid false positives or confusing\n\t\t\t    // results from assert.propContains().\n\t\t\t    // E.g. an actual null or false wrongly equaling an empty object,\n\t\t\t    // or an actual string being reported as object not matching a partial object.\n\t\t\t    if (obj !== Object(obj)) {\n\t\t\t      return obj;\n\t\t\t    }\n\n\t\t\t    // Unlike objectValues(), subset arrays to a plain objects as well.\n\t\t\t    // This enables subsetting [20, 30] with {1: 30}.\n\t\t\t    var subset = {};\n\t\t\t    for (var key in model) {\n\t\t\t      if (hasOwn$1.call(model, key) && hasOwn$1.call(obj, key)) {\n\t\t\t        subset[key] = objectValuesSubset(obj[key], model[key]);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return subset;\n\t\t\t  }\n\t\t\t  function extend(a, b, undefOnly) {\n\t\t\t    for (var prop in b) {\n\t\t\t      if (hasOwn$1.call(b, prop)) {\n\t\t\t        if (b[prop] === undefined) {\n\t\t\t          delete a[prop];\n\t\t\t        } else if (!(undefOnly && typeof a[prop] !== 'undefined')) {\n\t\t\t          a[prop] = b[prop];\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return a;\n\t\t\t  }\n\t\t\t  function objectType(obj) {\n\t\t\t    if (typeof obj === 'undefined') {\n\t\t\t      return 'undefined';\n\t\t\t    }\n\n\t\t\t    // Consider: typeof null === object\n\t\t\t    if (obj === null) {\n\t\t\t      return 'null';\n\t\t\t    }\n\t\t\t    var match = toString.call(obj).match(/^\\[object\\s(.*)\\]$/);\n\t\t\t    var type = match && match[1];\n\t\t\t    switch (type) {\n\t\t\t      case 'Number':\n\t\t\t        if (isNaN(obj)) {\n\t\t\t          return 'nan';\n\t\t\t        }\n\t\t\t        return 'number';\n\t\t\t      case 'String':\n\t\t\t      case 'Boolean':\n\t\t\t      case 'Array':\n\t\t\t      case 'Set':\n\t\t\t      case 'Map':\n\t\t\t      case 'Date':\n\t\t\t      case 'RegExp':\n\t\t\t      case 'Function':\n\t\t\t      case 'Symbol':\n\t\t\t        return type.toLowerCase();\n\t\t\t      default:\n\t\t\t        return _typeof(obj);\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  // Safe object type checking\n\t\t\t  function is(type, obj) {\n\t\t\t    return objectType(obj) === type;\n\t\t\t  }\n\n\t\t\t  // Based on Java's String.hashCode, a simple but not\n\t\t\t  // rigorously collision resistant hashing function\n\t\t\t  function generateHash(module, testName) {\n\t\t\t    var str = module + '\\x1C' + testName;\n\t\t\t    var hash = 0;\n\t\t\t    for (var i = 0; i < str.length; i++) {\n\t\t\t      hash = (hash << 5) - hash + str.charCodeAt(i);\n\t\t\t      hash |= 0;\n\t\t\t    }\n\n\t\t\t    // Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t\t\t    // strictly necessary but increases user understanding that the id is a SHA-like hash\n\t\t\t    var hex = (0x100000000 + hash).toString(16);\n\t\t\t    if (hex.length < 8) {\n\t\t\t      hex = '0000000' + hex;\n\t\t\t    }\n\t\t\t    return hex.slice(-8);\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Converts an error into a simple string for comparisons.\n\t\t\t   *\n\t\t\t   * @param {Error|any} error\n\t\t\t   * @return {string}\n\t\t\t   */\n\t\t\t  function errorString(error) {\n\t\t\t    // Use String() instead of toString() to handle non-object values like undefined or null.\n\t\t\t    var resultErrorString = String(error);\n\n\t\t\t    // If the error wasn't a subclass of Error but something like\n\t\t\t    // an object literal with name and message properties...\n\t\t\t    if (resultErrorString.slice(0, 7) === '[object') {\n\t\t\t      // Based on https://es5.github.io/#x15.11.4.4\n\t\t\t      return (error.name || 'Error') + (error.message ? \": \".concat(error.message) : '');\n\t\t\t    } else {\n\t\t\t      return resultErrorString;\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function escapeText(str) {\n\t\t\t    if (!str) {\n\t\t\t      return '';\n\t\t\t    }\n\n\t\t\t    // Both single quotes and double quotes (for attributes)\n\t\t\t    return ('' + str).replace(/['\"<>&]/g, function (s) {\n\t\t\t      switch (s) {\n\t\t\t        case \"'\":\n\t\t\t          return '&#039;';\n\t\t\t        case '\"':\n\t\t\t          return '&quot;';\n\t\t\t        case '<':\n\t\t\t          return '&lt;';\n\t\t\t        case '>':\n\t\t\t          return '&gt;';\n\t\t\t        case '&':\n\t\t\t          return '&amp;';\n\t\t\t      }\n\t\t\t    });\n\t\t\t  }\n\n\t\t\t  var BOXABLE_TYPES = new StringSet(['boolean', 'number', 'string']);\n\n\t\t\t  // Memory for previously seen containers (object, array, map, set).\n\t\t\t  // Used for recursion detection, and to avoid repeated comparison.\n\t\t\t  //\n\t\t\t  // Elements are { a: val, b: val }.\n\t\t\t  var memory = [];\n\t\t\t  function useStrictEquality(a, b) {\n\t\t\t    return a === b;\n\t\t\t  }\n\t\t\t  function useObjectValueEquality(a, b) {\n\t\t\t    return a === b || a.valueOf() === b.valueOf();\n\t\t\t  }\n\t\t\t  function compareConstructors(a, b) {\n\t\t\t    // Comparing constructors is more strict than using `instanceof`\n\t\t\t    return getConstructor(a) === getConstructor(b);\n\t\t\t  }\n\t\t\t  function getConstructor(obj) {\n\t\t\t    var proto = Object.getPrototypeOf(obj);\n\n\t\t\t    // If the obj prototype descends from a null constructor, treat it\n\t\t\t    // as a null prototype.\n\t\t\t    // Ref https://github.com/qunitjs/qunit/issues/851\n\t\t\t    //\n\t\t\t    // Allow objects with no prototype, from Object.create(null), to be equivalent to\n\t\t\t    // plain objects that have Object as their constructor.\n\t\t\t    return !proto || proto.constructor === null ? Object : obj.constructor;\n\t\t\t  }\n\t\t\t  function getRegExpFlags(regexp) {\n\t\t\t    return 'flags' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];\n\t\t\t  }\n\n\t\t\t  // Specialised comparisons after entryTypeCallbacks.object, based on `objectType()`\n\t\t\t  var objTypeCallbacks = {\n\t\t\t    undefined: useStrictEquality,\n\t\t\t    null: useStrictEquality,\n\t\t\t    // Handle boxed boolean\n\t\t\t    boolean: useObjectValueEquality,\n\t\t\t    number: function number(a, b) {\n\t\t\t      // Handle NaN and boxed number\n\t\t\t      return a === b || a.valueOf() === b.valueOf() || isNaN(a.valueOf()) && isNaN(b.valueOf());\n\t\t\t    },\n\t\t\t    // Handle boxed string\n\t\t\t    string: useObjectValueEquality,\n\t\t\t    symbol: useStrictEquality,\n\t\t\t    date: useObjectValueEquality,\n\t\t\t    nan: function nan() {\n\t\t\t      return true;\n\t\t\t    },\n\t\t\t    regexp: function regexp(a, b) {\n\t\t\t      return a.source === b.source &&\n\t\t\t      // Include flags in the comparison\n\t\t\t      getRegExpFlags(a) === getRegExpFlags(b);\n\t\t\t    },\n\t\t\t    // identical reference only\n\t\t\t    function: useStrictEquality,\n\t\t\t    array: function array(a, b) {\n\t\t\t      if (a.length !== b.length) {\n\t\t\t        // Safe and faster\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      for (var i = 0; i < a.length; i++) {\n\t\t\t        if (!typeEquiv(a[i], b[i])) {\n\t\t\t          return false;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return true;\n\t\t\t    },\n\t\t\t    // Define sets a and b to be equivalent if for each element aVal in a, there\n\t\t\t    // is some element bVal in b such that aVal and bVal are equivalent. Element\n\t\t\t    // repetitions are not counted, so these are equivalent:\n\t\t\t    // a = new Set( [ X={}, Y=[], Y ] );\n\t\t\t    // b = new Set( [ Y, X, X ] );\n\t\t\t    set: function set(a, b) {\n\t\t\t      if (a.size !== b.size) {\n\t\t\t        // This optimization has certain quirks because of the lack of\n\t\t\t        // repetition counting. For instance, adding the same\n\t\t\t        // (reference-identical) element to two equivalent sets can\n\t\t\t        // make them non-equivalent.\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      var outerEq = true;\n\t\t\t      a.forEach(function (aVal) {\n\t\t\t        // Short-circuit if the result is already known. (Using for...of\n\t\t\t        // with a break clause would be cleaner here, but it would cause\n\t\t\t        // a syntax error on older JavaScript implementations even if\n\t\t\t        // Set is unused)\n\t\t\t        if (!outerEq) {\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        var innerEq = false;\n\t\t\t        b.forEach(function (bVal) {\n\t\t\t          // Likewise, short-circuit if the result is already known\n\t\t\t          if (innerEq) {\n\t\t\t            return;\n\t\t\t          }\n\n\t\t\t          // Swap out the global memory, as nested typeEquiv() would clobber it\n\t\t\t          var originalMemory = memory;\n\t\t\t          memory = [];\n\t\t\t          if (typeEquiv(bVal, aVal)) {\n\t\t\t            innerEq = true;\n\t\t\t          }\n\t\t\t          // Restore\n\t\t\t          memory = originalMemory;\n\t\t\t        });\n\t\t\t        if (!innerEq) {\n\t\t\t          outerEq = false;\n\t\t\t        }\n\t\t\t      });\n\t\t\t      return outerEq;\n\t\t\t    },\n\t\t\t    // Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)\n\t\t\t    // in a, there is some key-value pair (bKey, bVal) in b such that\n\t\t\t    // [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not\n\t\t\t    // counted, so these are equivalent:\n\t\t\t    // a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );\n\t\t\t    // b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );\n\t\t\t    map: function map(a, b) {\n\t\t\t      if (a.size !== b.size) {\n\t\t\t        // This optimization has certain quirks because of the lack of\n\t\t\t        // repetition counting. For instance, adding the same\n\t\t\t        // (reference-identical) key-value pair to two equivalent maps\n\t\t\t        // can make them non-equivalent.\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      var outerEq = true;\n\t\t\t      a.forEach(function (aVal, aKey) {\n\t\t\t        // Short-circuit if the result is already known. (Using for...of\n\t\t\t        // with a break clause would be cleaner here, but it would cause\n\t\t\t        // a syntax error on older JavaScript implementations even if\n\t\t\t        // Map is unused)\n\t\t\t        if (!outerEq) {\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        var innerEq = false;\n\t\t\t        b.forEach(function (bVal, bKey) {\n\t\t\t          // Likewise, short-circuit if the result is already known\n\t\t\t          if (innerEq) {\n\t\t\t            return;\n\t\t\t          }\n\n\t\t\t          // Swap out the global memory, as nested typeEquiv() would clobber it\n\t\t\t          var originalMemory = memory;\n\t\t\t          memory = [];\n\t\t\t          if (objTypeCallbacks.array([bVal, bKey], [aVal, aKey])) {\n\t\t\t            innerEq = true;\n\t\t\t          }\n\t\t\t          // Restore\n\t\t\t          memory = originalMemory;\n\t\t\t        });\n\t\t\t        if (!innerEq) {\n\t\t\t          outerEq = false;\n\t\t\t        }\n\t\t\t      });\n\t\t\t      return outerEq;\n\t\t\t    }\n\t\t\t  };\n\n\t\t\t  // Entry points from typeEquiv, based on `typeof`\n\t\t\t  var entryTypeCallbacks = {\n\t\t\t    undefined: useStrictEquality,\n\t\t\t    null: useStrictEquality,\n\t\t\t    boolean: useStrictEquality,\n\t\t\t    number: function number(a, b) {\n\t\t\t      // Handle NaN\n\t\t\t      return a === b || isNaN(a) && isNaN(b);\n\t\t\t    },\n\t\t\t    string: useStrictEquality,\n\t\t\t    symbol: useStrictEquality,\n\t\t\t    function: useStrictEquality,\n\t\t\t    object: function object(a, b) {\n\t\t\t      // Handle memory (skip recursion)\n\t\t\t      if (memory.some(function (pair) {\n\t\t\t        return pair.a === a && pair.b === b;\n\t\t\t      })) {\n\t\t\t        return true;\n\t\t\t      }\n\t\t\t      memory.push({\n\t\t\t        a: a,\n\t\t\t        b: b\n\t\t\t      });\n\t\t\t      var aObjType = objectType(a);\n\t\t\t      var bObjType = objectType(b);\n\t\t\t      if (aObjType !== 'object' || bObjType !== 'object') {\n\t\t\t        // Handle literal `null`\n\t\t\t        // Handle: Array, Map/Set, Date, Regxp/Function, boxed primitives\n\t\t\t        return aObjType === bObjType && objTypeCallbacks[aObjType](a, b);\n\t\t\t      }\n\n\t\t\t      // NOTE: Literal null must not make it here as it would throw\n\t\t\t      if (compareConstructors(a, b) === false) {\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      var aProperties = [];\n\t\t\t      var bProperties = [];\n\n\t\t\t      // Be strict and go deep, no filtering with hasOwnProperty.\n\t\t\t      for (var i in a) {\n\t\t\t        // Collect a's properties\n\t\t\t        aProperties.push(i);\n\n\t\t\t        // Skip OOP methods that look the same\n\t\t\t        if (a.constructor !== Object && typeof a.constructor !== 'undefined' && typeof a[i] === 'function' && typeof b[i] === 'function' && a[i].toString() === b[i].toString()) {\n\t\t\t          continue;\n\t\t\t        }\n\t\t\t        if (!typeEquiv(a[i], b[i])) {\n\t\t\t          return false;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      for (var _i in b) {\n\t\t\t        // Collect b's properties\n\t\t\t        bProperties.push(_i);\n\t\t\t      }\n\t\t\t      return objTypeCallbacks.array(aProperties.sort(), bProperties.sort());\n\t\t\t    }\n\t\t\t  };\n\t\t\t  function typeEquiv(a, b) {\n\t\t\t    // Optimization: Only perform type-specific comparison when pairs are not strictly equal.\n\t\t\t    if (a === b) {\n\t\t\t      return true;\n\t\t\t    }\n\t\t\t    var aType = _typeof(a);\n\t\t\t    var bType = _typeof(b);\n\t\t\t    if (aType !== bType) {\n\t\t\t      // Support comparing primitive to boxed primitives\n\t\t\t      // Try again after possibly unwrapping one\n\t\t\t      return (aType === 'object' && BOXABLE_TYPES.has(objectType(a)) ? a.valueOf() : a) === (bType === 'object' && BOXABLE_TYPES.has(objectType(b)) ? b.valueOf() : b);\n\t\t\t    }\n\t\t\t    return entryTypeCallbacks[aType](a, b);\n\t\t\t  }\n\t\t\t  function innerEquiv(a, b) {\n\t\t\t    var res = typeEquiv(a, b);\n\t\t\t    // Release any retained objects and reset recursion detection for next call\n\t\t\t    memory = [];\n\t\t\t    return res;\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Test any two types of JavaScript values for equality.\n\t\t\t   *\n\t\t\t   * @author Philippe Rath <prathe@gmail.com>\n\t\t\t   * @author David Chan <david@troi.org>\n\t\t\t   */\n\t\t\t  function equiv(a, b) {\n\t\t\t    if (arguments.length === 2) {\n\t\t\t      return a === b || innerEquiv(a, b);\n\t\t\t    }\n\n\t\t\t    // Given 0 or 1 arguments, just return true (nothing to compare).\n\t\t\t    // Given (A,B,C,D) compare C,D then B,C then A,B.\n\t\t\t    var i = arguments.length - 1;\n\t\t\t    while (i > 0) {\n\t\t\t      if (!innerEquiv(arguments[i - 1], arguments[i])) {\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      i--;\n\t\t\t    }\n\t\t\t    return true;\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Config object: Maintain internal state\n\t\t\t   * Later exposed as QUnit.config\n\t\t\t   * `config` initialized at top of scope\n\t\t\t   */\n\t\t\t  var config = {\n\t\t\t    // HTML Reporter: Modify document.title when suite is done\n\t\t\t    altertitle: true,\n\t\t\t    // TODO: Move here from /src/core.js in QUnit 3.\n\t\t\t    // autostart: true,\n\n\t\t\t    // HTML Reporter: collapse every test except the first failing test\n\t\t\t    // If false, all failing tests will be expanded\n\t\t\t    collapse: true,\n\t\t\t    countStepsAsOne: false,\n\t\t\t    // TODO: Make explicit in QUnit 3.\n\t\t\t    // current: undefined,\n\n\t\t\t    // whether or not to fail when there are zero tests\n\t\t\t    // defaults to `true`\n\t\t\t    failOnZeroTests: true,\n\t\t\t    // Select by pattern or case-insensitive substring match against \"moduleName: testName\"\n\t\t\t    filter: undefined,\n\t\t\t    // TODO: Make explicit in QUnit 3.\n\t\t\t    // fixture: undefined,\n\n\t\t\t    // Depth up-to which object will be dumped\n\t\t\t    maxDepth: 5,\n\t\t\t    // Select case-insensitive match of the module name\n\t\t\t    module: undefined,\n\t\t\t    // HTML Reporter: Select module/test by array of internal IDs\n\t\t\t    moduleId: undefined,\n\t\t\t    // By default, run previously failed tests first\n\t\t\t    // very useful in combination with \"Hide passed tests\" checked\n\t\t\t    reorder: true,\n\t\t\t    reporters: {},\n\t\t\t    // When enabled, all tests must call expect()\n\t\t\t    requireExpects: false,\n\t\t\t    // By default, scroll to top of the page when suite is done\n\t\t\t    scrolltop: true,\n\t\t\t    // TODO: Make explicit in QUnit 3.\n\t\t\t    // seed: undefined,\n\n\t\t\t    // The storage module to use for reordering tests\n\t\t\t    storage: localSessionStorage,\n\t\t\t    testId: undefined,\n\t\t\t    // The updateRate controls how often QUnit will yield the main thread\n\t\t\t    // between tests. This is mainly for the benefit of the HTML Reporter,\n\t\t\t    // so that the browser can visually paint DOM changes with test results.\n\t\t\t    // This also helps avoid causing browsers to prompt a warning about\n\t\t\t    // long-running scripts.\n\t\t\t    // TODO: Move here from /src/core.js in QUnit 3.\n\t\t\t    // updateRate: 1000,\n\n\t\t\t    // HTML Reporter: List of URL parameters that are given visual controls\n\t\t\t    urlConfig: [],\n\t\t\t    // Internal: The first unnamed module\n\t\t\t    //\n\t\t\t    // By being defined as the intial value for currentModule, it is the\n\t\t\t    // receptacle and implied parent for any global tests. It is as if we\n\t\t\t    // called `QUnit.module( \"\" );` before any other tests were defined.\n\t\t\t    //\n\t\t\t    // If we reach begin() and no tests were put in it, we dequeue it as if it\n\t\t\t    // never existed, and in that case never expose it to the events and\n\t\t\t    // callbacks API.\n\t\t\t    //\n\t\t\t    // When global tests are defined, then this unnamed module will execute\n\t\t\t    // as any other module, including moduleStart/moduleDone events etc.\n\t\t\t    //\n\t\t\t    // Since this module isn't explicitly created by the user, they have no\n\t\t\t    // access to add hooks for it. The hooks object is defined to comply\n\t\t\t    // with internal expectations of test.js, but they will be empty.\n\t\t\t    // To apply hooks, place tests explicitly in a QUnit.module(), and use\n\t\t\t    // its hooks accordingly.\n\t\t\t    //\n\t\t\t    // For global hooks that apply to all tests and all modules, use QUnit.hooks.\n\t\t\t    //\n\t\t\t    // NOTE: This is *not* a \"global module\". It is not an ancestor of all modules\n\t\t\t    // and tests. It is merely the parent for any tests defined globally,\n\t\t\t    // before the first QUnit.module(). As such, the events for this unnamed\n\t\t\t    // module will fire as normal, right after its last test, and *not* at\n\t\t\t    // the end of the test run.\n\t\t\t    //\n\t\t\t    // NOTE: This also should probably also not become a global module, unless\n\t\t\t    // we keep it out of the public API. For example, it would likely not\n\t\t\t    // improve the user interface and plugin behaviour if all modules became\n\t\t\t    // wrapped between the start and end events of this module, and thus\n\t\t\t    // needlessly add indentation, indirection, or other visible noise.\n\t\t\t    // Unit tests for the callbacks API would detect that as a regression.\n\t\t\t    currentModule: {\n\t\t\t      name: '',\n\t\t\t      tests: [],\n\t\t\t      childModules: [],\n\t\t\t      testsRun: 0,\n\t\t\t      testsIgnored: 0,\n\t\t\t      hooks: {\n\t\t\t        before: [],\n\t\t\t        beforeEach: [],\n\t\t\t        afterEach: [],\n\t\t\t        after: []\n\t\t\t      }\n\t\t\t    },\n\t\t\t    // Internal: Exposed to make resets easier\n\t\t\t    // Ref https://github.com/qunitjs/qunit/pull/1598\n\t\t\t    globalHooks: {},\n\t\t\t    // Internal: ProcessingQueue singleton, created in /src/core.js\n\t\t\t    pq: null,\n\t\t\t    // Internal: Created in /src/core.js\n\t\t\t    // TODO: Move definitions here in QUnit 3.0.\n\t\t\t    // started: 0,\n\n\t\t\t    // Internal state\n\t\t\t    _event_listeners: Object.create(null),\n\t\t\t    _event_memory: {},\n\t\t\t    _deprecated_timeout_shown: false,\n\t\t\t    _deprecated_countEachStep_shown: false,\n\t\t\t    blocking: true,\n\t\t\t    callbacks: {},\n\t\t\t    modules: [],\n\t\t\t    queue: [],\n\t\t\t    stats: {\n\t\t\t      all: 0,\n\t\t\t      bad: 0,\n\t\t\t      testCount: 0\n\t\t\t    }\n\t\t\t  };\n\t\t\t  function readFlatPreconfigBoolean(val, dest) {\n\t\t\t    if (typeof val === 'boolean' || typeof val === 'string' && val !== '') {\n\t\t\t      config[dest] = val === true || val === 'true';\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function readFlatPreconfigNumber(val, dest) {\n\t\t\t    if (typeof val === 'number' || typeof val === 'string' && /^[0-9]+$/.test(val)) {\n\t\t\t      config[dest] = +val;\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function readFlatPreconfigString(val, dest) {\n\t\t\t    if (typeof val === 'string' && val !== '') {\n\t\t\t      config[dest] = val;\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function readFlatPreconfigStringOrBoolean(val, dest) {\n\t\t\t    if (typeof val === 'boolean' || typeof val === 'string' && val !== '') {\n\t\t\t      config[dest] = val;\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function readFlatPreconfigStringArray(val, dest) {\n\t\t\t    if (typeof val === 'string' && val !== '') {\n\t\t\t      config[dest] = [val];\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function readFlatPreconfig(obj) {\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_altertitle, 'altertitle');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_autostart, 'autostart');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_collapse, 'collapse');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_failonzerotests, 'failOnZeroTests');\n\t\t\t    readFlatPreconfigString(obj.qunit_config_filter, 'filter');\n\t\t\t    readFlatPreconfigString(obj.qunit_config_fixture, 'fixture');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_hidepassed, 'hidepassed');\n\t\t\t    readFlatPreconfigNumber(obj.qunit_config_maxdepth, 'maxDepth');\n\t\t\t    readFlatPreconfigString(obj.qunit_config_module, 'module');\n\t\t\t    readFlatPreconfigStringArray(obj.qunit_config_moduleid, 'moduleId');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_noglobals, 'noglobals');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_notrycatch, 'notrycatch');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_reorder, 'reorder');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_requireexpects, 'requireExpects');\n\t\t\t    readFlatPreconfigBoolean(obj.qunit_config_scrolltop, 'scrolltop');\n\t\t\t    readFlatPreconfigStringOrBoolean(obj.qunit_config_seed, 'seed');\n\t\t\t    readFlatPreconfigStringArray(obj.qunit_config_testid, 'testId');\n\t\t\t    readFlatPreconfigNumber(obj.qunit_config_testtimeout, 'testTimeout');\n\t\t\t    var reporterKeys = {\n\t\t\t      qunit_config_reporters_console: 'console',\n\t\t\t      qunit_config_reporters_tap: 'tap'\n\t\t\t    };\n\t\t\t    for (var key in reporterKeys) {\n\t\t\t      var val = obj[key];\n\t\t\t      // Based on readFlatPreconfigBoolean\n\t\t\t      if (typeof val === 'boolean' || typeof val === 'string' && val !== '') {\n\t\t\t        var dest = reporterKeys[key];\n\t\t\t        config.reporters[dest] = val === true || val === 'true' || val === '1';\n\t\t\t      }\n\t\t\t    }\n\t\t\t  }\n\t\t\t  if (process$1 && 'env' in process$1) {\n\t\t\t    readFlatPreconfig(process$1.env);\n\t\t\t  }\n\t\t\t  readFlatPreconfig(g);\n\n\t\t\t  // Apply a predefined QUnit.config object\n\t\t\t  //\n\t\t\t  // Ignore QUnit.config if it is a QUnit distribution instead of preconfig.\n\t\t\t  // That means QUnit was loaded twice! (Use the same approach as export.js)\n\t\t\t  var preConfig = g && g.QUnit && !g.QUnit.version && g.QUnit.config;\n\t\t\t  if (preConfig) {\n\t\t\t    extend(config, preConfig);\n\t\t\t  }\n\n\t\t\t  // Push a loose unnamed module to the modules collection\n\t\t\t  config.modules.push(config.currentModule);\n\t\t\t  if (config.seed === 'true' || config.seed === true) {\n\t\t\t    // Generate a random seed\n\t\t\t    // Length of `Math.random()` fraction, in base 36, may vary from 6-14.\n\t\t\t    // Pad and take slice to a consistent 10-digit value.\n\t\t\t    config.seed = (Math.random().toString(36) + '0000000000').slice(2, 12);\n\t\t\t  }\n\n\t\t\t  var dump = (function () {\n\t\t\t    function quote(str) {\n\t\t\t      return '\"' + str.toString().replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') + '\"';\n\t\t\t    }\n\t\t\t    function literal(o) {\n\t\t\t      return o + '';\n\t\t\t    }\n\t\t\t    function join(pre, arr, post) {\n\t\t\t      var s = dump.separator();\n\t\t\t      var inner = dump.indent(1);\n\t\t\t      if (arr.join) {\n\t\t\t        arr = arr.join(',' + s + inner);\n\t\t\t      }\n\t\t\t      if (!arr) {\n\t\t\t        return pre + post;\n\t\t\t      }\n\t\t\t      var base = dump.indent();\n\t\t\t      return [pre, inner + arr, base + post].join(s);\n\t\t\t    }\n\t\t\t    function array(arr, stack) {\n\t\t\t      if (dump.maxDepth && dump.depth > dump.maxDepth) {\n\t\t\t        return '[object Array]';\n\t\t\t      }\n\t\t\t      this.up();\n\t\t\t      var i = arr.length;\n\t\t\t      var ret = new Array(i);\n\t\t\t      while (i--) {\n\t\t\t        ret[i] = this.parse(arr[i], undefined, stack);\n\t\t\t      }\n\t\t\t      this.down();\n\t\t\t      return join('[', ret, ']');\n\t\t\t    }\n\t\t\t    function isArray(obj) {\n\t\t\t      return (\n\t\t\t        // Native Arrays\n\t\t\t        toString.call(obj) === '[object Array]' ||\n\t\t\t        // NodeList objects\n\t\t\t        typeof obj.length === 'number' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)\n\t\t\t      );\n\t\t\t    }\n\t\t\t    var reName = /^function (\\w+)/;\n\t\t\t    var dump = {\n\t\t\t      // The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\t      parse: function parse(obj, objType, stack) {\n\t\t\t        stack = stack || [];\n\t\t\t        var objIndex = stack.indexOf(obj);\n\t\t\t        if (objIndex !== -1) {\n\t\t\t          return \"recursion(\".concat(objIndex - stack.length, \")\");\n\t\t\t        }\n\t\t\t        objType = objType || this.typeOf(obj);\n\t\t\t        var parser = this.parsers[objType];\n\t\t\t        var parserType = _typeof(parser);\n\t\t\t        if (parserType === 'function') {\n\t\t\t          stack.push(obj);\n\t\t\t          var res = parser.call(this, obj, stack);\n\t\t\t          stack.pop();\n\t\t\t          return res;\n\t\t\t        }\n\t\t\t        if (parserType === 'string') {\n\t\t\t          return parser;\n\t\t\t        }\n\t\t\t        return '[ERROR: Missing QUnit.dump formatter for type ' + objType + ']';\n\t\t\t      },\n\t\t\t      typeOf: function typeOf(obj) {\n\t\t\t        var type;\n\t\t\t        if (obj === null) {\n\t\t\t          type = 'null';\n\t\t\t        } else if (typeof obj === 'undefined') {\n\t\t\t          type = 'undefined';\n\t\t\t        } else if (is('regexp', obj)) {\n\t\t\t          type = 'regexp';\n\t\t\t        } else if (is('date', obj)) {\n\t\t\t          type = 'date';\n\t\t\t        } else if (is('function', obj)) {\n\t\t\t          type = 'function';\n\t\t\t        } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {\n\t\t\t          type = 'window';\n\t\t\t        } else if (obj.nodeType === 9) {\n\t\t\t          type = 'document';\n\t\t\t        } else if (obj.nodeType) {\n\t\t\t          type = 'node';\n\t\t\t        } else if (isArray(obj)) {\n\t\t\t          type = 'array';\n\t\t\t        } else if (obj.constructor === Error.prototype.constructor) {\n\t\t\t          type = 'error';\n\t\t\t        } else {\n\t\t\t          type = _typeof(obj);\n\t\t\t        }\n\t\t\t        return type;\n\t\t\t      },\n\t\t\t      separator: function separator() {\n\t\t\t        if (this.multiline) {\n\t\t\t          return this.HTML ? '<br />' : '\\n';\n\t\t\t        } else {\n\t\t\t          return this.HTML ? '&#160;' : ' ';\n\t\t\t        }\n\t\t\t      },\n\t\t\t      // Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\t      indent: function indent(extra) {\n\t\t\t        if (!this.multiline) {\n\t\t\t          return '';\n\t\t\t        }\n\t\t\t        var chr = this.indentChar;\n\t\t\t        if (this.HTML) {\n\t\t\t          chr = chr.replace(/\\t/g, '   ').replace(/ /g, '&#160;');\n\t\t\t        }\n\t\t\t        return new Array(this.depth + (extra || 0)).join(chr);\n\t\t\t      },\n\t\t\t      up: function up(a) {\n\t\t\t        this.depth += a || 1;\n\t\t\t      },\n\t\t\t      down: function down(a) {\n\t\t\t        this.depth -= a || 1;\n\t\t\t      },\n\t\t\t      setParser: function setParser(name, parser) {\n\t\t\t        this.parsers[name] = parser;\n\t\t\t      },\n\t\t\t      // The next 3 are exposed so you can use them\n\t\t\t      quote: quote,\n\t\t\t      literal: literal,\n\t\t\t      join: join,\n\t\t\t      depth: 1,\n\t\t\t      maxDepth: config.maxDepth,\n\t\t\t      // This is the list of parsers, to modify them, use dump.setParser\n\t\t\t      parsers: {\n\t\t\t        window: '[Window]',\n\t\t\t        document: '[Document]',\n\t\t\t        error: function error(_error) {\n\t\t\t          return 'Error(\"' + _error.message + '\")';\n\t\t\t        },\n\t\t\t        // This has been unused since QUnit 1.0.0.\n\t\t\t        // @todo Deprecate and remove.\n\t\t\t        unknown: '[Unknown]',\n\t\t\t        null: 'null',\n\t\t\t        undefined: 'undefined',\n\t\t\t        function: function _function(fn) {\n\t\t\t          var ret = 'function';\n\n\t\t\t          // Functions never have name in IE\n\t\t\t          var name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1];\n\t\t\t          if (name) {\n\t\t\t            ret += ' ' + name;\n\t\t\t          }\n\t\t\t          ret += '(';\n\t\t\t          ret = [ret, dump.parse(fn, 'functionArgs'), '){'].join('');\n\t\t\t          return join(ret, dump.parse(fn, 'functionCode'), '}');\n\t\t\t        },\n\t\t\t        array: array,\n\t\t\t        nodelist: array,\n\t\t\t        arguments: array,\n\t\t\t        object: function object(map, stack) {\n\t\t\t          var ret = [];\n\t\t\t          if (dump.maxDepth && dump.depth > dump.maxDepth) {\n\t\t\t            return '[object Object]';\n\t\t\t          }\n\t\t\t          dump.up();\n\t\t\t          var keys = [];\n\t\t\t          for (var key in map) {\n\t\t\t            keys.push(key);\n\t\t\t          }\n\n\t\t\t          // Some properties are not always enumerable on Error objects.\n\t\t\t          var nonEnumerableProperties = ['message', 'name'];\n\t\t\t          for (var i in nonEnumerableProperties) {\n\t\t\t            var _key = nonEnumerableProperties[i];\n\t\t\t            if (_key in map && !inArray(_key, keys)) {\n\t\t\t              keys.push(_key);\n\t\t\t            }\n\t\t\t          }\n\t\t\t          keys.sort();\n\t\t\t          for (var _i = 0; _i < keys.length; _i++) {\n\t\t\t            var _key2 = keys[_i];\n\t\t\t            var val = map[_key2];\n\t\t\t            ret.push(dump.parse(_key2, 'key') + ': ' + dump.parse(val, undefined, stack));\n\t\t\t          }\n\t\t\t          dump.down();\n\t\t\t          return join('{', ret, '}');\n\t\t\t        },\n\t\t\t        node: function node(_node) {\n\t\t\t          var open = dump.HTML ? '&lt;' : '<';\n\t\t\t          var close = dump.HTML ? '&gt;' : '>';\n\t\t\t          var tag = _node.nodeName.toLowerCase();\n\t\t\t          var ret = open + tag;\n\t\t\t          var attrs = _node.attributes;\n\t\t\t          if (attrs) {\n\t\t\t            for (var i = 0; i < attrs.length; i++) {\n\t\t\t              var val = attrs[i].nodeValue;\n\n\t\t\t              // IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t              // set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t              // \"inherit\".\n\t\t\t              if (val && val !== 'inherit') {\n\t\t\t                ret += ' ' + attrs[i].nodeName + '=' + dump.parse(val, 'attribute');\n\t\t\t              }\n\t\t\t            }\n\t\t\t          }\n\t\t\t          ret += close;\n\n\t\t\t          // Show content of TextNode or CDATASection\n\t\t\t          if (_node.nodeType === 3 || _node.nodeType === 4) {\n\t\t\t            ret += _node.nodeValue;\n\t\t\t          }\n\t\t\t          return ret + open + '/' + tag + close;\n\t\t\t        },\n\t\t\t        // Function calls it internally, it's the arguments part of the function\n\t\t\t        functionArgs: function functionArgs(fn) {\n\t\t\t          var l = fn.length;\n\t\t\t          if (!l) {\n\t\t\t            return '';\n\t\t\t          }\n\t\t\t          var args = new Array(l);\n\t\t\t          while (l--) {\n\t\t\t            // 97 is 'a'\n\t\t\t            args[l] = String.fromCharCode(97 + l);\n\t\t\t          }\n\t\t\t          return ' ' + args.join(', ') + ' ';\n\t\t\t        },\n\t\t\t        // Object calls it internally, the key part of an item in a map\n\t\t\t        key: quote,\n\t\t\t        // Function calls it internally, it's the content of the function\n\t\t\t        functionCode: '[code]',\n\t\t\t        // Node calls it internally, it's a html attribute value\n\t\t\t        attribute: quote,\n\t\t\t        string: quote,\n\t\t\t        date: quote,\n\t\t\t        regexp: literal,\n\t\t\t        number: literal,\n\t\t\t        boolean: literal,\n\t\t\t        symbol: function symbol(sym) {\n\t\t\t          return sym.toString();\n\t\t\t        }\n\t\t\t      },\n\t\t\t      // If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\t      HTML: false,\n\t\t\t      // Indentation unit\n\t\t\t      indentChar: '  ',\n\t\t\t      // If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\t      multiline: true\n\t\t\t    };\n\t\t\t    return dump;\n\t\t\t  })();\n\n\t\t\t  // Support: IE 9\n\t\t\t  // Detect if the console object exists and no-op otherwise.\n\t\t\t  // This allows support for IE 9, which doesn't have a console\n\t\t\t  // object if the developer tools are not open.\n\n\t\t\t  // Support: IE 9\n\t\t\t  // Function#bind is supported, but no console.log.bind().\n\n\t\t\t  // Support: SpiderMonkey (mozjs 68+)\n\t\t\t  // The console object has a log method, but no warn method.\n\n\t\t\t  var Logger = {\n\t\t\t    warn: console$1 ? Function.prototype.bind.call(console$1.warn || console$1.log, console$1) : function () {}\n\t\t\t  };\n\n\t\t\t  var SuiteReport = /*#__PURE__*/function () {\n\t\t\t    function SuiteReport(name, parentSuite) {\n\t\t\t      _classCallCheck(this, SuiteReport);\n\t\t\t      this.name = name;\n\t\t\t      this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];\n\n\t\t\t      // When an \"error\" event is emitted from onUncaughtException(), the\n\t\t\t      // \"runEnd\" event should report the status as failed. The \"runEnd\" event data\n\t\t\t      // is tracked through this property (via the \"runSuite\" instance).\n\t\t\t      this.globalFailureCount = 0;\n\t\t\t      this.tests = [];\n\t\t\t      this.childSuites = [];\n\t\t\t      if (parentSuite) {\n\t\t\t        parentSuite.pushChildSuite(this);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return _createClass(SuiteReport, [{\n\t\t\t      key: \"start\",\n\t\t\t      value: function start(recordTime) {\n\t\t\t        if (recordTime) {\n\t\t\t          this._startTime = performance.now();\n\t\t\t        }\n\t\t\t        return {\n\t\t\t          name: this.name,\n\t\t\t          fullName: this.fullName.slice(),\n\t\t\t          tests: this.tests.map(function (test) {\n\t\t\t            return test.start();\n\t\t\t          }),\n\t\t\t          childSuites: this.childSuites.map(function (suite) {\n\t\t\t            return suite.start();\n\t\t\t          }),\n\t\t\t          testCounts: {\n\t\t\t            total: this.getTestCounts().total\n\t\t\t          }\n\t\t\t        };\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"end\",\n\t\t\t      value: function end(recordTime) {\n\t\t\t        if (recordTime) {\n\t\t\t          this._endTime = performance.now();\n\t\t\t        }\n\t\t\t        return {\n\t\t\t          name: this.name,\n\t\t\t          fullName: this.fullName.slice(),\n\t\t\t          tests: this.tests.map(function (test) {\n\t\t\t            return test.end();\n\t\t\t          }),\n\t\t\t          childSuites: this.childSuites.map(function (suite) {\n\t\t\t            return suite.end();\n\t\t\t          }),\n\t\t\t          testCounts: this.getTestCounts(),\n\t\t\t          runtime: this.getRuntime(),\n\t\t\t          status: this.getStatus()\n\t\t\t        };\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"pushChildSuite\",\n\t\t\t      value: function pushChildSuite(suite) {\n\t\t\t        this.childSuites.push(suite);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"pushTest\",\n\t\t\t      value: function pushTest(test) {\n\t\t\t        this.tests.push(test);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"getRuntime\",\n\t\t\t      value: function getRuntime() {\n\t\t\t        return Math.round(this._endTime - this._startTime);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"getTestCounts\",\n\t\t\t      value: function getTestCounts() {\n\t\t\t        var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n\t\t\t          passed: 0,\n\t\t\t          failed: 0,\n\t\t\t          skipped: 0,\n\t\t\t          todo: 0,\n\t\t\t          total: 0\n\t\t\t        };\n\t\t\t        counts.failed += this.globalFailureCount;\n\t\t\t        counts.total += this.globalFailureCount;\n\t\t\t        counts = this.tests.reduce(function (counts, test) {\n\t\t\t          if (test.valid) {\n\t\t\t            counts[test.getStatus()]++;\n\t\t\t            counts.total++;\n\t\t\t          }\n\t\t\t          return counts;\n\t\t\t        }, counts);\n\t\t\t        return this.childSuites.reduce(function (counts, suite) {\n\t\t\t          return suite.getTestCounts(counts);\n\t\t\t        }, counts);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"getStatus\",\n\t\t\t      value: function getStatus() {\n\t\t\t        var _this$getTestCounts = this.getTestCounts(),\n\t\t\t          total = _this$getTestCounts.total,\n\t\t\t          failed = _this$getTestCounts.failed,\n\t\t\t          skipped = _this$getTestCounts.skipped,\n\t\t\t          todo = _this$getTestCounts.todo;\n\t\t\t        if (failed) {\n\t\t\t          return 'failed';\n\t\t\t        } else {\n\t\t\t          if (skipped === total) {\n\t\t\t            return 'skipped';\n\t\t\t          } else if (todo === total) {\n\t\t\t            return 'todo';\n\t\t\t          } else {\n\t\t\t            return 'passed';\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }]);\n\t\t\t  }();\n\n\t\t\t  var moduleStack = [];\n\t\t\t  var runSuite = new SuiteReport();\n\t\t\t  function isParentModuleInQueue() {\n\t\t\t    var modulesInQueue = config.modules.filter(function (module) {\n\t\t\t      return !module.ignored;\n\t\t\t    }).map(function (module) {\n\t\t\t      return module.moduleId;\n\t\t\t    });\n\t\t\t    return moduleStack.some(function (module) {\n\t\t\t      return modulesInQueue.includes(module.moduleId);\n\t\t\t    });\n\t\t\t  }\n\t\t\t  function createModule(name, testEnvironment, modifiers) {\n\t\t\t    var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;\n\t\t\t    var moduleName = parentModule !== null ? [parentModule.name, name].join(' > ') : name;\n\t\t\t    var parentSuite = parentModule ? parentModule.suiteReport : runSuite;\n\t\t\t    var skip = parentModule !== null && parentModule.skip || modifiers.skip;\n\t\t\t    var todo = parentModule !== null && parentModule.todo || modifiers.todo;\n\t\t\t    var env = {};\n\t\t\t    if (parentModule) {\n\t\t\t      extend(env, parentModule.testEnvironment);\n\t\t\t    }\n\t\t\t    extend(env, testEnvironment);\n\t\t\t    var module = {\n\t\t\t      name: moduleName,\n\t\t\t      parentModule: parentModule,\n\t\t\t      hooks: {\n\t\t\t        before: [],\n\t\t\t        beforeEach: [],\n\t\t\t        afterEach: [],\n\t\t\t        after: []\n\t\t\t      },\n\t\t\t      testEnvironment: env,\n\t\t\t      tests: [],\n\t\t\t      moduleId: generateHash(moduleName),\n\t\t\t      testsRun: 0,\n\t\t\t      testsIgnored: 0,\n\t\t\t      childModules: [],\n\t\t\t      suiteReport: new SuiteReport(name, parentSuite),\n\t\t\t      // Initialised by test.js when the module start executing,\n\t\t\t      // i.e. before the first test in this module (or a child).\n\t\t\t      stats: null,\n\t\t\t      // Pass along `skip` and `todo` properties from parent module, in case\n\t\t\t      // there is one, to childs. And use own otherwise.\n\t\t\t      // This property will be used to mark own tests and tests of child suites\n\t\t\t      // as either `skipped` or `todo`.\n\t\t\t      skip: skip,\n\t\t\t      todo: skip ? false : todo,\n\t\t\t      ignored: modifiers.ignored || false\n\t\t\t    };\n\t\t\t    if (parentModule) {\n\t\t\t      parentModule.childModules.push(module);\n\t\t\t    }\n\t\t\t    config.modules.push(module);\n\t\t\t    return module;\n\t\t\t  }\n\t\t\t  function setHookFromEnvironment(hooks, environment, name) {\n\t\t\t    var potentialHook = environment[name];\n\t\t\t    if (typeof potentialHook === 'function') {\n\t\t\t      hooks[name].push(potentialHook);\n\t\t\t    }\n\t\t\t    delete environment[name];\n\t\t\t  }\n\t\t\t  function makeSetHook(module, hookName) {\n\t\t\t    return function setHook(callback) {\n\t\t\t      if (config.currentModule !== module) {\n\t\t\t        Logger.warn('The `' + hookName + '` hook was called inside the wrong module (`' + config.currentModule.name + '`). ' + 'Instead, use hooks provided by the callback to the containing module (`' + module.name + '`). ' + 'This will become an error in QUnit 3.0.');\n\t\t\t      }\n\t\t\t      module.hooks[hookName].push(callback);\n\t\t\t    };\n\t\t\t  }\n\t\t\t  function processModule(name, options, scope) {\n\t\t\t    var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\t\t    if (typeof options === 'function') {\n\t\t\t      scope = options;\n\t\t\t      options = undefined;\n\t\t\t    }\n\t\t\t    var module = createModule(name, options, modifiers);\n\n\t\t\t    // Transfer any initial hooks from the options object to the 'hooks' object\n\t\t\t    var testEnvironment = module.testEnvironment;\n\t\t\t    var hooks = module.hooks;\n\t\t\t    setHookFromEnvironment(hooks, testEnvironment, 'before');\n\t\t\t    setHookFromEnvironment(hooks, testEnvironment, 'beforeEach');\n\t\t\t    setHookFromEnvironment(hooks, testEnvironment, 'afterEach');\n\t\t\t    setHookFromEnvironment(hooks, testEnvironment, 'after');\n\t\t\t    var moduleFns = {\n\t\t\t      before: makeSetHook(module, 'before'),\n\t\t\t      beforeEach: makeSetHook(module, 'beforeEach'),\n\t\t\t      afterEach: makeSetHook(module, 'afterEach'),\n\t\t\t      after: makeSetHook(module, 'after')\n\t\t\t    };\n\t\t\t    var prevModule = config.currentModule;\n\t\t\t    config.currentModule = module;\n\t\t\t    if (typeof scope === 'function') {\n\t\t\t      moduleStack.push(module);\n\t\t\t      try {\n\t\t\t        var cbReturnValue = scope.call(module.testEnvironment, moduleFns);\n\t\t\t        if (cbReturnValue && typeof cbReturnValue.then === 'function') {\n\t\t\t          Logger.warn('Returning a promise from a module callback is not supported. ' + 'Instead, use hooks for async behavior. ' + 'This will become an error in QUnit 3.0.');\n\t\t\t        }\n\t\t\t      } finally {\n\t\t\t        // If the module closure threw an uncaught error during the load phase,\n\t\t\t        // we let this bubble up to global error handlers. But, not until after\n\t\t\t        // we teardown internal state to ensure correct module nesting.\n\t\t\t        // Ref https://github.com/qunitjs/qunit/issues/1478.\n\t\t\t        moduleStack.pop();\n\t\t\t        config.currentModule = module.parentModule || prevModule;\n\t\t\t      }\n\t\t\t    }\n\t\t\t  }\n\t\t\t  var focused$1 = false; // indicates that the \"only\" filter was used\n\n\t\t\t  function module$1(name, options, scope) {\n\t\t\t    var ignored = focused$1 && !isParentModuleInQueue();\n\t\t\t    processModule(name, options, scope, {\n\t\t\t      ignored: ignored\n\t\t\t    });\n\t\t\t  }\n\t\t\t  module$1.only = function () {\n\t\t\t    if (!focused$1) {\n\t\t\t      // Upon the first module.only() call,\n\t\t\t      // delete any and all previously registered modules and tests.\n\t\t\t      config.modules.length = 0;\n\t\t\t      config.queue.length = 0;\n\n\t\t\t      // Ignore any tests declared after this block within the same\n\t\t\t      // module parent. https://github.com/qunitjs/qunit/issues/1645\n\t\t\t      config.currentModule.ignored = true;\n\t\t\t    }\n\t\t\t    focused$1 = true;\n\t\t\t    processModule.apply(void 0, arguments);\n\t\t\t  };\n\t\t\t  module$1.skip = function (name, options, scope) {\n\t\t\t    if (focused$1) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    processModule(name, options, scope, {\n\t\t\t      skip: true\n\t\t\t    });\n\t\t\t  };\n\t\t\t  module$1.if = function (name, condition, options, scope) {\n\t\t\t    if (focused$1) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    processModule(name, options, scope, {\n\t\t\t      skip: !condition\n\t\t\t    });\n\t\t\t  };\n\t\t\t  module$1.todo = function (name, options, scope) {\n\t\t\t    if (focused$1) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    processModule(name, options, scope, {\n\t\t\t      todo: true\n\t\t\t    });\n\t\t\t  };\n\n\t\t\t  // Stacktrace cleaner to focus on the path from error source to test suite.\n\t\t\t  //\n\t\t\t  // This should reduce a raw stack trace like this:\n\t\t\t  //\n\t\t\t  // > foo.broken()@/example/foo.js\n\t\t\t  // > Bar@/example/bar.js\n\t\t\t  // > @/test/bar.test.js\n\t\t\t  // > @/lib/qunit.js:500:12\n\t\t\t  // > @/lib/qunit.js:100:28\n\t\t\t  // > @/lib/qunit.js:200:56\n\t\t\t  // > setTimeout@\n\t\t\t  // > @/dist/vendor.js\n\t\t\t  //\n\t\t\t  // and shorten it to show up until the end of the user's bar.test.js code.\n\t\t\t  //\n\t\t\t  // > foo.broken()@/example/foo.js\n\t\t\t  // > Bar@/example/bar.js\n\t\t\t  // > @/test/bar.test.js\n\t\t\t  //\n\t\t\t  // QUnit will obtain one example trace (once per process/pageload suffices),\n\t\t\t  // strip off any :<line> and :<line>:<column>, and use that as match needle,\n\t\t\t  // to the first QUnit-internal frames, and then stop at that point.\n\t\t\t  // Any later frames, including those that are outside QUnit again, will be ommitted\n\t\t\t  // as being uninteresting to the test, since QUnit will have either started or\n\t\t\t  // resumed the test. This we also clean away browser built-ins, or other\n\t\t\t  // vendor/bundler that may be higher up the stack.\n\t\t\t  //\n\t\t\t  // Stripping :<line>:<column> is not for prettyness, it is essential for the\n\t\t\t  // match needle to work, since this sample trace will by definitin not be the\n\t\t\t  // same line as e.g. the QUnit.test() call we're trying to identify.\n\t\t\t  //\n\t\t\t  // See also:\n\t\t\t  // - https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n\n\t\t\t  function qunitFileName() {\n\t\t\t    var error = new Error();\n\t\t\t    if (!error.stack) {\n\t\t\t      // Copy of sourceFromStacktrace() to avoid circular dependency\n\t\t\t      // Support: IE 9-11\n\t\t\t      try {\n\t\t\t        throw error;\n\t\t\t      } catch (err) {\n\t\t\t        error = err;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return (error.stack || ''\n\t\t\t    // Copy of extractStacktrace() to avoid circular dependency\n\t\t\t    // Support: V8/Chrome\n\t\t\t    ).replace(/^error$\\n/im, '').split('\\n')[0]\n\t\t\t    // Global replace, because a frame like localhost:4000/lib/qunit.js:1234:50,\n\t\t\t    // would otherwise (harmlessly, but uselessly) remove only the port (first match).\n\t\t\t    // https://github.com/qunitjs/qunit/issues/1769\n\t\t\t    .replace(/(:\\d+)+\\)?/g, '')\n\t\t\t    // Remove anything prior to the last slash (Unix/Windows) from the last frame,\n\t\t\t    // leaving only \"qunit.js\".\n\t\t\t    .replace(/.+[/\\\\]/, '');\n\t\t\t  }\n\t\t\t  var fileName = qunitFileName();\n\n\t\t\t  /**\n\t\t\t   * Responsibilities:\n\t\t\t   * - For internal errors from QUnit itself, remove the first qunit.js frames.\n\t\t\t   * - For errors in Node.js, format any remaining qunit.js and node:internal\n\t\t\t   *   frames as internal (i.e. grey out).\n\t\t\t   *\n\t\t\t   * @param {string} stack Error#stack\n\t\t\t   * @param {Function} formatInternal Format a string in an \"internal\" color\n\t\t\t   * @param {string|null} [eToString] Error#toString() to help remove\n\t\t\t   *  noise from Node.js/V8 stack traces.\n\t\t\t   */\n\t\t\t  function annotateStacktrace(stack, formatInternal) {\n\t\t\t    var eToString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\t    var frames = stack.split('\\n');\n\t\t\t    var annotated = [];\n\t\t\t    if (eToString && eToString.indexOf(frames[0]) !== -1) {\n\t\t\t      // In Firefox and Safari e.stack starts with frame 0, but in V8 (Chrome/Node.js),\n\t\t\t      // e.stack starts first stringified message. Preserve this separately,\n\t\t\t      // so that, below, we can distinguish between internal frames on top\n\t\t\t      // (to remove) vs later internal frames (to format differently).\n\t\t\t      annotated.push(frames.shift());\n\t\t\t    }\n\t\t\t    var initialInternal = true;\n\t\t\t    for (var i = 0; i < frames.length; i++) {\n\t\t\t      var frame = frames[i];\n\t\t\t      var isInternal = fileName && frame.indexOf(fileName) !== -1 ||\n\t\t\t      // Support Node 16+: ESM-style\n\t\t\t      // \"at wrap (node:internal/modules/cjs/loader:1)\"\n\t\t\t      frame.indexOf('node:internal/') !== -1 ||\n\t\t\t      // Support Node 12-14 (CJS-style)\n\t\t\t      // \"at load (internal/modules/cjs/loader.js:7)\"\n\t\t\t      frame.match(/^\\s+at .+\\(internal[^)]*\\)$/) ||\n\t\t\t      // Support Node 10\n\t\t\t      // \"at listOnTimeout (timers.js:263)\"\n\t\t\t      // Avoid matching \"(C:)\" on Windows\n\t\t\t      // Avoid matching \"(http:)\"\n\t\t\t      frame.match(/^\\s+at .+\\([a-z]+\\.js[:\\d]*\\)$/);\n\t\t\t      if (!isInternal) {\n\t\t\t        initialInternal = false;\n\t\t\t      }\n\t\t\t      // Remove initial internal frames entirely.\n\t\t\t      if (!initialInternal) {\n\t\t\t        annotated.push(isInternal ? formatInternal(frame) : frame);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return annotated.join('\\n');\n\t\t\t  }\n\t\t\t  function extractStacktrace(e, offset) {\n\t\t\t    offset = offset === undefined ? 4 : offset;\n\n\t\t\t    // Support: IE9, e.stack is not supported, we will return undefined\n\t\t\t    if (e && e.stack) {\n\t\t\t      var stack = e.stack.split('\\n');\n\t\t\t      // In Firefox and Safari, e.stack starts immediately with the first frame.\n\t\t\t      //\n\t\t\t      // In V8 (Chrome/Node.js), the stack starts first with a stringified error message,\n\t\t\t      // and the real stack starting on line 2.\n\t\t\t      if (/^error$/i.test(stack[0])) {\n\t\t\t        stack.shift();\n\t\t\t      }\n\t\t\t      if (fileName) {\n\t\t\t        var include = [];\n\t\t\t        for (var i = offset; i < stack.length; i++) {\n\t\t\t          if (stack[i].indexOf(fileName) !== -1) {\n\t\t\t            break;\n\t\t\t          }\n\t\t\t          include.push(stack[i]);\n\t\t\t        }\n\t\t\t        if (include.length) {\n\t\t\t          return include.join('\\n');\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return stack[offset];\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function sourceFromStacktrace(offset) {\n\t\t\t    var error = new Error();\n\n\t\t\t    // Support: IE 9-11, iOS 7\n\t\t\t    // Not all browsers generate the `stack` property for `new Error()`\n\t\t\t    // See also https://github.com/qunitjs/qunit/issues/636\n\t\t\t    if (!error.stack) {\n\t\t\t      try {\n\t\t\t        throw error;\n\t\t\t      } catch (err) {\n\t\t\t        error = err;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return extractStacktrace(error, offset);\n\t\t\t  }\n\n\t\t\t  var Assert = /*#__PURE__*/function () {\n\t\t\t    function Assert(testContext) {\n\t\t\t      _classCallCheck(this, Assert);\n\t\t\t      this.test = testContext;\n\t\t\t    }\n\t\t\t    return _createClass(Assert, [{\n\t\t\t      key: \"timeout\",\n\t\t\t      value: function timeout(duration) {\n\t\t\t        if (typeof duration !== 'number') {\n\t\t\t          throw new Error('You must pass a number as the duration to assert.timeout');\n\t\t\t        }\n\t\t\t        this.test.timeout = duration;\n\n\t\t\t        // If a timeout has been set, clear it and reset with the new duration\n\t\t\t        if (config.timeout) {\n\t\t\t          clearTimeout(config.timeout);\n\t\t\t          config.timeout = null;\n\t\t\t          if (config.timeoutHandler && this.test.timeout > 0) {\n\t\t\t            this.test.internalResetTimeout(this.test.timeout);\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      // Documents a \"step\", which is a string value, in a test as a passing assertion\n\t\t\t    }, {\n\t\t\t      key: \"step\",\n\t\t\t      value: function step(message) {\n\t\t\t        var assertionMessage = message;\n\t\t\t        var result = !!message;\n\t\t\t        this.test.steps.push(message);\n\t\t\t        if (typeof message === 'undefined' || message === '') {\n\t\t\t          assertionMessage = 'You must provide a message to assert.step';\n\t\t\t        } else if (typeof message !== 'string') {\n\t\t\t          assertionMessage = 'You must provide a string value to assert.step';\n\t\t\t          result = false;\n\t\t\t        }\n\t\t\t        this.pushResult({\n\t\t\t          result: result,\n\t\t\t          message: assertionMessage\n\t\t\t        });\n\t\t\t      }\n\n\t\t\t      // Verifies the steps in a test match a given array of string values\n\t\t\t    }, {\n\t\t\t      key: \"verifySteps\",\n\t\t\t      value: function verifySteps(steps, message) {\n\t\t\t        // Since the steps array is just string values, we can clone with slice\n\t\t\t        var actualStepsClone = this.test.steps.slice();\n\t\t\t        this.deepEqual(actualStepsClone, steps, message);\n\t\t\t        this.test.stepsCount += this.test.steps.length;\n\t\t\t        this.test.steps.length = 0;\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"expect\",\n\t\t\t      value: function expect(asserts) {\n\t\t\t        if (arguments.length === 1) {\n\t\t\t          this.test.expected = asserts;\n\t\t\t        } else {\n\t\t\t          return this.test.expected;\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      // Create a new async pause and return a new function that can release the pause.\n\t\t\t    }, {\n\t\t\t      key: \"async\",\n\t\t\t      value: function async(count) {\n\t\t\t        if (count === undefined) {\n\t\t\t          count = 1;\n\t\t\t        } else if (typeof count !== 'number') {\n\t\t\t          throw new TypeError('async takes number as an input');\n\t\t\t        }\n\t\t\t        var requiredCalls = count;\n\t\t\t        return this.test.internalStop(requiredCalls);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"closeTo\",\n\t\t\t      value: function closeTo(actual, expected, delta, message) {\n\t\t\t        if (typeof delta !== 'number') {\n\t\t\t          throw new TypeError('closeTo() requires a delta argument');\n\t\t\t        }\n\t\t\t        this.pushResult({\n\t\t\t          result: Math.abs(actual - expected) <= delta,\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message || \"value should be within \".concat(delta, \" inclusive\")\n\t\t\t        });\n\t\t\t      }\n\n\t\t\t      // Alias of pushResult.\n\t\t\t    }, {\n\t\t\t      key: \"push\",\n\t\t\t      value: function push(result, actual, expected, message, negative) {\n\t\t\t        var currentAssert = this instanceof Assert ? this : config.current.assert;\n\t\t\t        return currentAssert.pushResult({\n\t\t\t          result: result,\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message,\n\t\t\t          negative: negative\n\t\t\t        });\n\t\t\t      }\n\n\t\t\t      // Public API to internal test.pushResult()\n\t\t\t    }, {\n\t\t\t      key: \"pushResult\",\n\t\t\t      value: function pushResult(resultInfo) {\n\t\t\t        // Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\t\t        var assert = this;\n\t\t\t        var currentTest = assert instanceof Assert && assert.test || config.current;\n\n\t\t\t        // Backwards compatibility fix.\n\t\t\t        // Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t\t        // Although, it's use is not recommended as it can leak assertions\n\t\t\t        // to other tests from async tests, because we only get a reference to the current test,\n\t\t\t        // not exactly the test where assertion were intended to be called.\n\t\t\t        if (!currentTest) {\n\t\t\t          throw new Error('assertion outside test context, in ' + sourceFromStacktrace(2));\n\t\t\t        }\n\t\t\t        if (!(assert instanceof Assert)) {\n\t\t\t          assert = currentTest.assert;\n\t\t\t        }\n\t\t\t        return assert.test.pushResult(resultInfo);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"ok\",\n\t\t\t      value: function ok(result, message) {\n\t\t\t        if (!message) {\n\t\t\t          message = result ? 'okay' : \"failed, expected argument to be truthy, was: \".concat(dump.parse(result));\n\t\t\t        }\n\t\t\t        this.pushResult({\n\t\t\t          result: !!result,\n\t\t\t          actual: result,\n\t\t\t          expected: true,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"notOk\",\n\t\t\t      value: function notOk(result, message) {\n\t\t\t        if (!message) {\n\t\t\t          message = !result ? 'okay' : \"failed, expected argument to be falsy, was: \".concat(dump.parse(result));\n\t\t\t        }\n\t\t\t        this.pushResult({\n\t\t\t          result: !result,\n\t\t\t          actual: result,\n\t\t\t          expected: false,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"true\",\n\t\t\t      value: function _true(result, message) {\n\t\t\t        this.pushResult({\n\t\t\t          result: result === true,\n\t\t\t          actual: result,\n\t\t\t          expected: true,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"false\",\n\t\t\t      value: function _false(result, message) {\n\t\t\t        this.pushResult({\n\t\t\t          result: result === false,\n\t\t\t          actual: result,\n\t\t\t          expected: false,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"equal\",\n\t\t\t      value: function equal(actual, expected, message) {\n\t\t\t        this.pushResult({\n\t\t\t          // eslint-disable-next-line eqeqeq\n\t\t\t          result: expected == actual,\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"notEqual\",\n\t\t\t      value: function notEqual(actual, expected, message) {\n\t\t\t        this.pushResult({\n\t\t\t          // eslint-disable-next-line eqeqeq\n\t\t\t          result: expected != actual,\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message,\n\t\t\t          negative: true\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"propEqual\",\n\t\t\t      value: function propEqual(actual, expected, message) {\n\t\t\t        actual = objectValues(actual);\n\t\t\t        expected = objectValues(expected);\n\t\t\t        this.pushResult({\n\t\t\t          result: equiv(actual, expected),\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"notPropEqual\",\n\t\t\t      value: function notPropEqual(actual, expected, message) {\n\t\t\t        actual = objectValues(actual);\n\t\t\t        expected = objectValues(expected);\n\t\t\t        this.pushResult({\n\t\t\t          result: !equiv(actual, expected),\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message,\n\t\t\t          negative: true\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"propContains\",\n\t\t\t      value: function propContains(actual, expected, message) {\n\t\t\t        actual = objectValuesSubset(actual, expected);\n\n\t\t\t        // The expected parameter is usually a plain object, but clone it for\n\t\t\t        // consistency with propEqual(), and to make it easy to explain that\n\t\t\t        // inheritence is not considered (on either side), and to support\n\t\t\t        // recursively checking subsets of nested objects.\n\t\t\t        expected = objectValues(expected, false);\n\t\t\t        this.pushResult({\n\t\t\t          result: equiv(actual, expected),\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"notPropContains\",\n\t\t\t      value: function notPropContains(actual, expected, message) {\n\t\t\t        actual = objectValuesSubset(actual, expected);\n\t\t\t        expected = objectValues(expected);\n\t\t\t        this.pushResult({\n\t\t\t          result: !equiv(actual, expected),\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message,\n\t\t\t          negative: true\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"deepEqual\",\n\t\t\t      value: function deepEqual(actual, expected, message) {\n\t\t\t        this.pushResult({\n\t\t\t          result: equiv(actual, expected),\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"notDeepEqual\",\n\t\t\t      value: function notDeepEqual(actual, expected, message) {\n\t\t\t        this.pushResult({\n\t\t\t          result: !equiv(actual, expected),\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message,\n\t\t\t          negative: true\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"strictEqual\",\n\t\t\t      value: function strictEqual(actual, expected, message) {\n\t\t\t        this.pushResult({\n\t\t\t          result: expected === actual,\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"notStrictEqual\",\n\t\t\t      value: function notStrictEqual(actual, expected, message) {\n\t\t\t        this.pushResult({\n\t\t\t          result: expected !== actual,\n\t\t\t          actual: actual,\n\t\t\t          expected: expected,\n\t\t\t          message: message,\n\t\t\t          negative: true\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: 'throws',\n\t\t\t      value: function throws(block, expected, message) {\n\t\t\t        var _validateExpectedExce = validateExpectedExceptionArgs(expected, message, 'throws');\n\t\t\t        var _validateExpectedExce2 = _slicedToArray(_validateExpectedExce, 2);\n\t\t\t        expected = _validateExpectedExce2[0];\n\t\t\t        message = _validateExpectedExce2[1];\n\t\t\t        var currentTest = this instanceof Assert && this.test || config.current;\n\t\t\t        if (typeof block !== 'function') {\n\t\t\t          currentTest.assert.pushResult({\n\t\t\t            result: false,\n\t\t\t            actual: block,\n\t\t\t            message: 'The value provided to `assert.throws` in ' + '\"' + currentTest.testName + '\" was not a function.'\n\t\t\t          });\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        var actual;\n\t\t\t        var result = false;\n\t\t\t        currentTest.ignoreGlobalErrors = true;\n\t\t\t        try {\n\t\t\t          block.call(currentTest.testEnvironment);\n\t\t\t        } catch (e) {\n\t\t\t          actual = e;\n\t\t\t        }\n\t\t\t        currentTest.ignoreGlobalErrors = false;\n\t\t\t        if (actual) {\n\t\t\t          var _validateException = validateException(actual, expected, message);\n\t\t\t          var _validateException2 = _slicedToArray(_validateException, 3);\n\t\t\t          result = _validateException2[0];\n\t\t\t          expected = _validateException2[1];\n\t\t\t          message = _validateException2[2];\n\t\t\t        }\n\t\t\t        currentTest.assert.pushResult({\n\t\t\t          result: result,\n\t\t\t          // undefined if it didn't throw\n\t\t\t          actual: actual && errorString(actual),\n\t\t\t          expected: expected,\n\t\t\t          message: message\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"rejects\",\n\t\t\t      value: function rejects(promise, expected, message) {\n\t\t\t        var _validateExpectedExce3 = validateExpectedExceptionArgs(expected, message, 'rejects');\n\t\t\t        var _validateExpectedExce4 = _slicedToArray(_validateExpectedExce3, 2);\n\t\t\t        expected = _validateExpectedExce4[0];\n\t\t\t        message = _validateExpectedExce4[1];\n\t\t\t        var currentTest = this instanceof Assert && this.test || config.current;\n\t\t\t        var then = promise && promise.then;\n\t\t\t        if (typeof then !== 'function') {\n\t\t\t          currentTest.assert.pushResult({\n\t\t\t            result: false,\n\t\t\t            message: 'The value provided to `assert.rejects` in ' + '\"' + currentTest.testName + '\" was not a promise.',\n\t\t\t            actual: promise\n\t\t\t          });\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        var done = this.async();\n\t\t\t        return then.call(promise, function handleFulfillment() {\n\t\t\t          currentTest.assert.pushResult({\n\t\t\t            result: false,\n\t\t\t            message: 'The promise returned by the `assert.rejects` callback in ' + '\"' + currentTest.testName + '\" did not reject.',\n\t\t\t            actual: promise\n\t\t\t          });\n\t\t\t          done();\n\t\t\t        }, function handleRejection(actual) {\n\t\t\t          var result;\n\t\t\t          var _validateException3 = validateException(actual, expected, message);\n\t\t\t          var _validateException4 = _slicedToArray(_validateException3, 3);\n\t\t\t          result = _validateException4[0];\n\t\t\t          expected = _validateException4[1];\n\t\t\t          message = _validateException4[2];\n\t\t\t          currentTest.assert.pushResult({\n\t\t\t            result: result,\n\t\t\t            // leave rejection value of undefined as-is\n\t\t\t            actual: actual && errorString(actual),\n\t\t\t            expected: expected,\n\t\t\t            message: message\n\t\t\t          });\n\t\t\t          done();\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }]);\n\t\t\t  }();\n\t\t\t  function validateExpectedExceptionArgs(expected, message, assertionMethod) {\n\t\t\t    var expectedType = objectType(expected);\n\n\t\t\t    // 'expected' is optional unless doing string comparison\n\t\t\t    if (expectedType === 'string') {\n\t\t\t      if (message === undefined) {\n\t\t\t        message = expected;\n\t\t\t        expected = undefined;\n\t\t\t        return [expected, message];\n\t\t\t      } else {\n\t\t\t        throw new Error('assert.' + assertionMethod + ' does not accept a string value for the expected argument.\\n' + 'Use a non-string object value (e.g. RegExp or validator function) ' + 'instead if necessary.');\n\t\t\t      }\n\t\t\t    }\n\t\t\t    var valid = !expected ||\n\t\t\t    // TODO: be more explicit here\n\t\t\t    expectedType === 'regexp' || expectedType === 'function' || expectedType === 'object';\n\t\t\t    if (!valid) {\n\t\t\t      throw new Error('Invalid expected value type (' + expectedType + ') ' + 'provided to assert.' + assertionMethod + '.');\n\t\t\t    }\n\t\t\t    return [expected, message];\n\t\t\t  }\n\t\t\t  function validateException(actual, expected, message) {\n\t\t\t    var result = false;\n\t\t\t    var expectedType = objectType(expected);\n\n\t\t\t    // These branches should be exhaustive, based on validation done in validateExpectedException\n\n\t\t\t    // We don't want to validate\n\t\t\t    if (!expected) {\n\t\t\t      result = true;\n\n\t\t\t      // Expected is a regexp\n\t\t\t    } else if (expectedType === 'regexp') {\n\t\t\t      result = expected.test(errorString(actual));\n\n\t\t\t      // Log the string form of the regexp\n\t\t\t      expected = String(expected);\n\n\t\t\t      // Expected is a constructor, maybe an Error constructor.\n\t\t\t      // Note the extra check on its prototype - this is an implicit\n\t\t\t      // requirement of \"instanceof\", else it will throw a TypeError.\n\t\t\t    } else if (expectedType === 'function' && expected.prototype !== undefined && actual instanceof expected) {\n\t\t\t      result = true;\n\n\t\t\t      // Expected is an Error object\n\t\t\t    } else if (expectedType === 'object') {\n\t\t\t      result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n\t\t\t      // Log the string form of the Error object\n\t\t\t      expected = errorString(expected);\n\n\t\t\t      // Expected is a validation function which returns true if validation passed\n\t\t\t    } else if (expectedType === 'function') {\n\t\t\t      // protect against accidental semantics which could hard error in the test\n\t\t\t      try {\n\t\t\t        result = expected.call({}, actual) === true;\n\t\t\t        expected = null;\n\t\t\t      } catch (e) {\n\t\t\t        // assign the \"expected\" to a nice error string to communicate the local failure to the user\n\t\t\t        expected = errorString(e);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return [result, expected, message];\n\t\t\t  }\n\n\t\t\t  // Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n\t\t\t  // Known to us are: Closure Compiler, Narwhal\n\t\t\t  // eslint-disable-next-line dot-notation\n\t\t\t  Assert.prototype.raises = Assert.prototype['throws'];\n\n\t\t\t  var SUPPORTED_EVENTS = ['error', 'runStart', 'suiteStart', 'testStart', 'assertion', 'testEnd', 'suiteEnd', 'runEnd'];\n\t\t\t  var MEMORY_EVENTS = ['error', 'runEnd'];\n\n\t\t\t  /**\n\t\t\t   * Emits an event with the specified data to all currently registered listeners.\n\t\t\t   * Callbacks will fire in the order in which they are registered (FIFO). This\n\t\t\t   * function is not exposed publicly; it is used by QUnit internals to emit\n\t\t\t   * logging events.\n\t\t\t   *\n\t\t\t   * @private\n\t\t\t   * @method emit\n\t\t\t   * @param {string} eventName\n\t\t\t   * @param {Object} data\n\t\t\t   * @return {void}\n\t\t\t   */\n\t\t\t  function emit(eventName, data) {\n\t\t\t    if (typeof eventName !== 'string') {\n\t\t\t      throw new TypeError('eventName must be a string when emitting an event');\n\t\t\t    }\n\n\t\t\t    // Clone the callbacks in case one of them registers a new callback\n\t\t\t    var originalCallbacks = config._event_listeners[eventName];\n\t\t\t    var callbacks = originalCallbacks ? _toConsumableArray(originalCallbacks) : [];\n\t\t\t    for (var i = 0; i < callbacks.length; i++) {\n\t\t\t      callbacks[i](data);\n\t\t\t    }\n\t\t\t    if (inArray(eventName, MEMORY_EVENTS)) {\n\t\t\t      config._event_memory[eventName] = data;\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Registers a callback as a listener to the specified event.\n\t\t\t   *\n\t\t\t   * @public\n\t\t\t   * @method on\n\t\t\t   * @param {string} eventName\n\t\t\t   * @param {Function} callback\n\t\t\t   * @return {void}\n\t\t\t   */\n\t\t\t  function on(eventName, callback) {\n\t\t\t    if (typeof eventName !== 'string') {\n\t\t\t      throw new TypeError('eventName must be a string when registering a listener');\n\t\t\t    } else if (!inArray(eventName, SUPPORTED_EVENTS)) {\n\t\t\t      var events = SUPPORTED_EVENTS.join(', ');\n\t\t\t      throw new Error(\"\\\"\".concat(eventName, \"\\\" is not a valid event; must be one of: \").concat(events, \".\"));\n\t\t\t    } else if (typeof callback !== 'function') {\n\t\t\t      throw new TypeError('callback must be a function when registering a listener');\n\t\t\t    }\n\t\t\t    var listeners = config._event_listeners[eventName] || (config._event_listeners[eventName] = []);\n\n\t\t\t    // Don't register the same callback more than once\n\t\t\t    if (!inArray(callback, listeners)) {\n\t\t\t      listeners.push(callback);\n\t\t\t      if (config._event_memory[eventName] !== undefined) {\n\t\t\t        callback(config._event_memory[eventName]);\n\t\t\t      }\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};\n\n\t\t\t  function commonjsRequire (path) {\n\t\t\t  \tthrow new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n\t\t\t  }\n\n\t\t\t  var promisePolyfill = {exports: {}};\n\n\t\t\t  (function () {\n\n\t\t\t    /** @suppress {undefinedVars} */\n\t\t\t    var globalNS = function () {\n\t\t\t      // the only reliable means to get the global object is\n\t\t\t      // `Function('return this')()`\n\t\t\t      // However, this causes CSP violations in Chrome apps.\n\t\t\t      if (typeof globalThis !== 'undefined') {\n\t\t\t        return globalThis;\n\t\t\t      }\n\t\t\t      if (typeof self !== 'undefined') {\n\t\t\t        return self;\n\t\t\t      }\n\t\t\t      if (typeof window !== 'undefined') {\n\t\t\t        return window;\n\t\t\t      }\n\t\t\t      if (typeof commonjsGlobal$1 !== 'undefined') {\n\t\t\t        return commonjsGlobal$1;\n\t\t\t      }\n\t\t\t      throw new Error('unable to locate global object');\n\t\t\t    }();\n\n\t\t\t    // Expose the polyfill if Promise is undefined or set to a\n\t\t\t    // non-function value. The latter can be due to a named HTMLElement\n\t\t\t    // being exposed by browsers for legacy reasons.\n\t\t\t    // https://github.com/taylorhakes/promise-polyfill/issues/114\n\t\t\t    if (typeof globalNS['Promise'] === 'function') {\n\t\t\t      promisePolyfill.exports = globalNS['Promise'];\n\t\t\t      return;\n\t\t\t    }\n\n\t\t\t    /**\n\t\t\t     * @this {Promise}\n\t\t\t     */\n\t\t\t    function finallyConstructor(callback) {\n\t\t\t      var constructor = this.constructor;\n\t\t\t      return this.then(function (value) {\n\t\t\t        // @ts-ignore\n\t\t\t        return constructor.resolve(callback()).then(function () {\n\t\t\t          return value;\n\t\t\t        });\n\t\t\t      }, function (reason) {\n\t\t\t        // @ts-ignore\n\t\t\t        return constructor.resolve(callback()).then(function () {\n\t\t\t          // @ts-ignore\n\t\t\t          return constructor.reject(reason);\n\t\t\t        });\n\t\t\t      });\n\t\t\t    }\n\t\t\t    function allSettled(arr) {\n\t\t\t      var P = this;\n\t\t\t      return new P(function (resolve, reject) {\n\t\t\t        if (!(arr && typeof arr.length !== 'undefined')) {\n\t\t\t          return reject(new TypeError(_typeof(arr) + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));\n\t\t\t        }\n\t\t\t        var args = Array.prototype.slice.call(arr);\n\t\t\t        if (args.length === 0) return resolve([]);\n\t\t\t        var remaining = args.length;\n\t\t\t        function res(i, val) {\n\t\t\t          if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n\t\t\t            var then = val.then;\n\t\t\t            if (typeof then === 'function') {\n\t\t\t              then.call(val, function (val) {\n\t\t\t                res(i, val);\n\t\t\t              }, function (e) {\n\t\t\t                args[i] = {\n\t\t\t                  status: 'rejected',\n\t\t\t                  reason: e\n\t\t\t                };\n\t\t\t                if (--remaining === 0) {\n\t\t\t                  resolve(args);\n\t\t\t                }\n\t\t\t              });\n\t\t\t              return;\n\t\t\t            }\n\t\t\t          }\n\t\t\t          args[i] = {\n\t\t\t            status: 'fulfilled',\n\t\t\t            value: val\n\t\t\t          };\n\t\t\t          if (--remaining === 0) {\n\t\t\t            resolve(args);\n\t\t\t          }\n\t\t\t        }\n\t\t\t        for (var i = 0; i < args.length; i++) {\n\t\t\t          res(i, args[i]);\n\t\t\t        }\n\t\t\t      });\n\t\t\t    }\n\n\t\t\t    // Store setTimeout reference so promise-polyfill will be unaffected by\n\t\t\t    // other code modifying setTimeout (like sinon.useFakeTimers())\n\t\t\t    var setTimeoutFunc = setTimeout;\n\t\t\t    function isArray(x) {\n\t\t\t      return Boolean(x && typeof x.length !== 'undefined');\n\t\t\t    }\n\t\t\t    function noop() {}\n\n\t\t\t    // Polyfill for Function.prototype.bind\n\t\t\t    function bind(fn, thisArg) {\n\t\t\t      return function () {\n\t\t\t        fn.apply(thisArg, arguments);\n\t\t\t      };\n\t\t\t    }\n\n\t\t\t    /**\n\t\t\t     * @constructor\n\t\t\t     * @param {Function} fn\n\t\t\t     */\n\t\t\t    function Promise(fn) {\n\t\t\t      if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n\t\t\t      if (typeof fn !== 'function') throw new TypeError('not a function');\n\t\t\t      /** @type {!number} */\n\t\t\t      this._state = 0;\n\t\t\t      /** @type {!boolean} */\n\t\t\t      this._handled = false;\n\t\t\t      /** @type {Promise|undefined} */\n\t\t\t      this._value = undefined;\n\t\t\t      /** @type {!Array<!Function>} */\n\t\t\t      this._deferreds = [];\n\t\t\t      doResolve(fn, this);\n\t\t\t    }\n\t\t\t    function handle(self, deferred) {\n\t\t\t      while (self._state === 3) {\n\t\t\t        self = self._value;\n\t\t\t      }\n\t\t\t      if (self._state === 0) {\n\t\t\t        self._deferreds.push(deferred);\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      self._handled = true;\n\t\t\t      Promise._immediateFn(function () {\n\t\t\t        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n\t\t\t        if (cb === null) {\n\t\t\t          (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        var ret;\n\t\t\t        try {\n\t\t\t          ret = cb(self._value);\n\t\t\t        } catch (e) {\n\t\t\t          reject(deferred.promise, e);\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        resolve(deferred.promise, ret);\n\t\t\t      });\n\t\t\t    }\n\t\t\t    function resolve(self, newValue) {\n\t\t\t      try {\n\t\t\t        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t\t\t        if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n\t\t\t        if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {\n\t\t\t          var then = newValue.then;\n\t\t\t          if (newValue instanceof Promise) {\n\t\t\t            self._state = 3;\n\t\t\t            self._value = newValue;\n\t\t\t            finale(self);\n\t\t\t            return;\n\t\t\t          } else if (typeof then === 'function') {\n\t\t\t            doResolve(bind(then, newValue), self);\n\t\t\t            return;\n\t\t\t          }\n\t\t\t        }\n\t\t\t        self._state = 1;\n\t\t\t        self._value = newValue;\n\t\t\t        finale(self);\n\t\t\t      } catch (e) {\n\t\t\t        reject(self, e);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function reject(self, newValue) {\n\t\t\t      self._state = 2;\n\t\t\t      self._value = newValue;\n\t\t\t      finale(self);\n\t\t\t    }\n\t\t\t    function finale(self) {\n\t\t\t      if (self._state === 2 && self._deferreds.length === 0) {\n\t\t\t        Promise._immediateFn(function () {\n\t\t\t          if (!self._handled) {\n\t\t\t            Promise._unhandledRejectionFn(self._value);\n\t\t\t          }\n\t\t\t        });\n\t\t\t      }\n\t\t\t      for (var i = 0, len = self._deferreds.length; i < len; i++) {\n\t\t\t        handle(self, self._deferreds[i]);\n\t\t\t      }\n\t\t\t      self._deferreds = null;\n\t\t\t    }\n\n\t\t\t    /**\n\t\t\t     * @constructor\n\t\t\t     */\n\t\t\t    function Handler(onFulfilled, onRejected, promise) {\n\t\t\t      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t\t\t      this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t\t\t      this.promise = promise;\n\t\t\t    }\n\n\t\t\t    /**\n\t\t\t     * Take a potentially misbehaving resolver function and make sure\n\t\t\t     * onFulfilled and onRejected are only called once.\n\t\t\t     *\n\t\t\t     * Makes no guarantees about asynchrony.\n\t\t\t     */\n\t\t\t    function doResolve(fn, self) {\n\t\t\t      var done = false;\n\t\t\t      try {\n\t\t\t        fn(function (value) {\n\t\t\t          if (done) return;\n\t\t\t          done = true;\n\t\t\t          resolve(self, value);\n\t\t\t        }, function (reason) {\n\t\t\t          if (done) return;\n\t\t\t          done = true;\n\t\t\t          reject(self, reason);\n\t\t\t        });\n\t\t\t      } catch (ex) {\n\t\t\t        if (done) return;\n\t\t\t        done = true;\n\t\t\t        reject(self, ex);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    Promise.prototype['catch'] = function (onRejected) {\n\t\t\t      return this.then(null, onRejected);\n\t\t\t    };\n\t\t\t    Promise.prototype.then = function (onFulfilled, onRejected) {\n\t\t\t      // @ts-ignore\n\t\t\t      var prom = new this.constructor(noop);\n\t\t\t      handle(this, new Handler(onFulfilled, onRejected, prom));\n\t\t\t      return prom;\n\t\t\t    };\n\t\t\t    Promise.prototype['finally'] = finallyConstructor;\n\t\t\t    Promise.all = function (arr) {\n\t\t\t      return new Promise(function (resolve, reject) {\n\t\t\t        if (!isArray(arr)) {\n\t\t\t          return reject(new TypeError('Promise.all accepts an array'));\n\t\t\t        }\n\t\t\t        var args = Array.prototype.slice.call(arr);\n\t\t\t        if (args.length === 0) return resolve([]);\n\t\t\t        var remaining = args.length;\n\t\t\t        function res(i, val) {\n\t\t\t          try {\n\t\t\t            if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n\t\t\t              var then = val.then;\n\t\t\t              if (typeof then === 'function') {\n\t\t\t                then.call(val, function (val) {\n\t\t\t                  res(i, val);\n\t\t\t                }, reject);\n\t\t\t                return;\n\t\t\t              }\n\t\t\t            }\n\t\t\t            args[i] = val;\n\t\t\t            if (--remaining === 0) {\n\t\t\t              resolve(args);\n\t\t\t            }\n\t\t\t          } catch (ex) {\n\t\t\t            reject(ex);\n\t\t\t          }\n\t\t\t        }\n\t\t\t        for (var i = 0; i < args.length; i++) {\n\t\t\t          res(i, args[i]);\n\t\t\t        }\n\t\t\t      });\n\t\t\t    };\n\t\t\t    Promise.allSettled = allSettled;\n\t\t\t    Promise.resolve = function (value) {\n\t\t\t      if (value && _typeof(value) === 'object' && value.constructor === Promise) {\n\t\t\t        return value;\n\t\t\t      }\n\t\t\t      return new Promise(function (resolve) {\n\t\t\t        resolve(value);\n\t\t\t      });\n\t\t\t    };\n\t\t\t    Promise.reject = function (value) {\n\t\t\t      return new Promise(function (resolve, reject) {\n\t\t\t        reject(value);\n\t\t\t      });\n\t\t\t    };\n\t\t\t    Promise.race = function (arr) {\n\t\t\t      return new Promise(function (resolve, reject) {\n\t\t\t        if (!isArray(arr)) {\n\t\t\t          return reject(new TypeError('Promise.race accepts an array'));\n\t\t\t        }\n\t\t\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t\t\t          Promise.resolve(arr[i]).then(resolve, reject);\n\t\t\t        }\n\t\t\t      });\n\t\t\t    };\n\n\t\t\t    // Use polyfill for setImmediate for performance gains\n\t\t\t    // @ts-ignore\n\t\t\t    if (typeof setImmediate === 'function') {\n\t\t\t      // @ts-ignore\n\t\t\t      var setImmediateFunc = setImmediate;\n\t\t\t      Promise._immediateFn = function (fn) {\n\t\t\t        setImmediateFunc(fn);\n\t\t\t      };\n\t\t\t    } else {\n\t\t\t      Promise._immediateFn = function (fn) {\n\t\t\t        setTimeoutFunc(fn, 0);\n\t\t\t      };\n\t\t\t    }\n\t\t\t    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n\t\t\t      if (typeof console !== 'undefined' && console) {\n\t\t\t        console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n\t\t\t      }\n\t\t\t    };\n\t\t\t    promisePolyfill.exports = Promise;\n\t\t\t  })();\n\t\t\t  var _Promise = promisePolyfill.exports;\n\n\t\t\t  // Register logging callbacks\n\t\t\t  function registerLoggingCallbacks(obj) {\n\t\t\t    var callbackNames = ['begin', 'done', 'log', 'testStart', 'testDone', 'moduleStart', 'moduleDone'];\n\t\t\t    function registerLoggingCallback(key) {\n\t\t\t      return function loggingCallback(callback) {\n\t\t\t        if (typeof callback !== 'function') {\n\t\t\t          throw new Error('Callback parameter must be a function');\n\t\t\t        }\n\t\t\t        config.callbacks[key].push(callback);\n\t\t\t      };\n\t\t\t    }\n\t\t\t    for (var i = 0; i < callbackNames.length; i++) {\n\t\t\t      var key = callbackNames[i];\n\n\t\t\t      // Initialize key collection of logging callback\n\t\t\t      if (typeof config.callbacks[key] === 'undefined') {\n\t\t\t        config.callbacks[key] = [];\n\t\t\t      }\n\t\t\t      obj[key] = registerLoggingCallback(key);\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function runLoggingCallbacks(key, args) {\n\t\t\t    var callbacks = config.callbacks[key];\n\n\t\t\t    // Handling 'log' callbacks separately. Unlike the other callbacks,\n\t\t\t    // the log callback is not controlled by the processing queue,\n\t\t\t    // but rather used by asserts. Hence to promisfy the 'log' callback\n\t\t\t    // would mean promisfying each step of a test\n\t\t\t    if (key === 'log') {\n\t\t\t      callbacks.map(function (callback) {\n\t\t\t        return callback(args);\n\t\t\t      });\n\t\t\t      return;\n\t\t\t    }\n\n\t\t\t    // ensure that each callback is executed serially\n\t\t\t    var promiseChain = _Promise.resolve();\n\t\t\t    callbacks.forEach(function (callback) {\n\t\t\t      promiseChain = promiseChain.then(function () {\n\t\t\t        return _Promise.resolve(callback(args));\n\t\t\t      });\n\t\t\t    });\n\t\t\t    return promiseChain;\n\t\t\t  }\n\n\t\t\t  var TestReport = /*#__PURE__*/function () {\n\t\t\t    function TestReport(name, suite, options) {\n\t\t\t      _classCallCheck(this, TestReport);\n\t\t\t      this.name = name;\n\t\t\t      this.suiteName = suite.name;\n\t\t\t      this.fullName = suite.fullName.concat(name);\n\t\t\t      this.runtime = 0;\n\t\t\t      this.assertions = [];\n\t\t\t      this.skipped = !!options.skip;\n\t\t\t      this.todo = !!options.todo;\n\t\t\t      this.valid = options.valid;\n\t\t\t      this._startTime = 0;\n\t\t\t      this._endTime = 0;\n\t\t\t      suite.pushTest(this);\n\t\t\t    }\n\t\t\t    return _createClass(TestReport, [{\n\t\t\t      key: \"start\",\n\t\t\t      value: function start(recordTime) {\n\t\t\t        if (recordTime) {\n\t\t\t          this._startTime = performance.now();\n\t\t\t        }\n\t\t\t        return {\n\t\t\t          name: this.name,\n\t\t\t          suiteName: this.suiteName,\n\t\t\t          fullName: this.fullName.slice()\n\t\t\t        };\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"end\",\n\t\t\t      value: function end(recordTime) {\n\t\t\t        if (recordTime) {\n\t\t\t          this._endTime = performance.now();\n\t\t\t        }\n\t\t\t        return extend(this.start(), {\n\t\t\t          runtime: this.getRuntime(),\n\t\t\t          status: this.getStatus(),\n\t\t\t          errors: this.getFailedAssertions(),\n\t\t\t          assertions: this.getAssertions()\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"pushAssertion\",\n\t\t\t      value: function pushAssertion(assertion) {\n\t\t\t        this.assertions.push(assertion);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"getRuntime\",\n\t\t\t      value: function getRuntime() {\n\t\t\t        return Math.round(this._endTime - this._startTime);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"getStatus\",\n\t\t\t      value: function getStatus() {\n\t\t\t        if (this.skipped) {\n\t\t\t          return 'skipped';\n\t\t\t        }\n\t\t\t        var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;\n\t\t\t        if (!testPassed) {\n\t\t\t          return 'failed';\n\t\t\t        } else if (this.todo) {\n\t\t\t          return 'todo';\n\t\t\t        } else {\n\t\t\t          return 'passed';\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"getFailedAssertions\",\n\t\t\t      value: function getFailedAssertions() {\n\t\t\t        return this.assertions.filter(function (assertion) {\n\t\t\t          return !assertion.passed;\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"getAssertions\",\n\t\t\t      value: function getAssertions() {\n\t\t\t        return this.assertions.slice();\n\t\t\t      }\n\n\t\t\t      // Remove actual and expected values from assertions. This is to prevent\n\t\t\t      // leaking memory throughout a test suite.\n\t\t\t    }, {\n\t\t\t      key: \"slimAssertions\",\n\t\t\t      value: function slimAssertions() {\n\t\t\t        this.assertions = this.assertions.map(function (assertion) {\n\t\t\t          delete assertion.actual;\n\t\t\t          delete assertion.expected;\n\t\t\t          return assertion;\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }]);\n\t\t\t  }();\n\n\t\t\t  function Test(settings) {\n\t\t\t    this.expected = null;\n\t\t\t    this.assertions = [];\n\t\t\t    this.module = config.currentModule;\n\t\t\t    this.steps = [];\n\t\t\t    // This powers the QUnit.config.countStepsAsOne feature.\n\t\t\t    // https://github.com/qunitjs/qunit/pull/1775\n\t\t\t    this.stepsCount = 0;\n\t\t\t    this.timeout = undefined;\n\t\t\t    this.data = undefined;\n\t\t\t    this.withData = false;\n\t\t\t    this.pauses = new StringMap();\n\t\t\t    this.nextPauseId = 1;\n\n\t\t\t    // For the most common case, we have:\n\t\t\t    // - 0: new Test\n\t\t\t    // - 1: addTest\n\t\t\t    // - 2: QUnit.test\n\t\t\t    // - 3: user file\n\t\t\t    //\n\t\t\t    // This needs is customised by test.each()\n\t\t\t    this.stackOffset = 3;\n\t\t\t    extend(this, settings);\n\n\t\t\t    // If a module is skipped, all its tests and the tests of the child suites\n\t\t\t    // should be treated as skipped even if they are defined as `only` or `todo`.\n\t\t\t    // As for `todo` module, all its tests will be treated as `todo` except for\n\t\t\t    // tests defined as `skip` which will be left intact.\n\t\t\t    //\n\t\t\t    // So, if a test is defined as `todo` and is inside a skipped module, we should\n\t\t\t    // then treat that test as if was defined as `skip`.\n\t\t\t    if (this.module.skip) {\n\t\t\t      this.skip = true;\n\t\t\t      this.todo = false;\n\n\t\t\t      // Skipped tests should be left intact\n\t\t\t    } else if (this.module.todo && !this.skip) {\n\t\t\t      this.todo = true;\n\t\t\t    }\n\n\t\t\t    // Queuing a late test after the run has ended is not allowed.\n\t\t\t    // This was once supported for internal use by QUnit.onError().\n\t\t\t    // Ref https://github.com/qunitjs/qunit/issues/1377\n\t\t\t    if (config.pq.finished) {\n\t\t\t      // Using this for anything other than onError(), such as testing in QUnit.done(),\n\t\t\t      // is unstable and will likely result in the added tests being ignored by CI.\n\t\t\t      // (Meaning the CI passes irregardless of the added tests).\n\t\t\t      //\n\t\t\t      // TODO: Make this an error in QUnit 3.0\n\t\t\t      // throw new Error( \"Unexpected test after runEnd\" );\n\t\t\t      Logger.warn('Unexpected test after runEnd. This is unstable and will fail in QUnit 3.0.');\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    if (!this.skip && typeof this.callback !== 'function') {\n\t\t\t      var method = this.todo ? 'QUnit.todo' : 'QUnit.test';\n\t\t\t      throw new TypeError(\"You must provide a callback to \".concat(method, \"(\\\"\").concat(this.testName, \"\\\")\"));\n\t\t\t    }\n\n\t\t\t    // Register unique strings\n\t\t\t    for (var i = 0, l = this.module.tests; i < l.length; i++) {\n\t\t\t      if (this.module.tests[i].name === this.testName) {\n\t\t\t        this.testName += ' ';\n\t\t\t      }\n\t\t\t    }\n\t\t\t    this.testId = generateHash(this.module.name, this.testName);\n\n\t\t\t    // No validation after this. Beyond this point, failures must be recorded as\n\t\t\t    // a completed test with errors, instead of early bail out.\n\t\t\t    // Otherwise, internals may be left in an inconsistent state.\n\t\t\t    // Ref https://github.com/qunitjs/qunit/issues/1514\n\n\t\t\t    ++Test.count;\n\t\t\t    this.errorForStack = new Error();\n\t\t\t    if (this.callback && this.callback.validTest) {\n\t\t\t      // Omit the test-level trace for the internal \"No tests\" test failure,\n\t\t\t      // There is already an assertion-level trace, and that's noisy enough\n\t\t\t      // as it is.\n\t\t\t      this.errorForStack.stack = undefined;\n\t\t\t    }\n\t\t\t    this.testReport = new TestReport(this.testName, this.module.suiteReport, {\n\t\t\t      todo: this.todo,\n\t\t\t      skip: this.skip,\n\t\t\t      valid: this.valid()\n\t\t\t    });\n\t\t\t    this.module.tests.push({\n\t\t\t      name: this.testName,\n\t\t\t      testId: this.testId,\n\t\t\t      skip: !!this.skip\n\t\t\t    });\n\t\t\t    if (this.skip) {\n\t\t\t      // Skipped tests will fully ignore (and dereference for garbage collect) any sent callback\n\t\t\t      this.callback = function () {};\n\t\t\t      this.async = false;\n\t\t\t      this.expected = 0;\n\t\t\t    } else {\n\t\t\t      this.assert = new Assert(this);\n\t\t\t    }\n\t\t\t  }\n\t\t\t  Test.count = 0;\n\t\t\t  function getNotStartedModules(startModule) {\n\t\t\t    var module = startModule;\n\t\t\t    var modules = [];\n\t\t\t    while (module && module.testsRun === 0) {\n\t\t\t      modules.push(module);\n\t\t\t      module = module.parentModule;\n\t\t\t    }\n\n\t\t\t    // The above push modules from the child to the parent\n\t\t\t    // return a reversed order with the top being the top most parent module\n\t\t\t    return modules.reverse();\n\t\t\t  }\n\t\t\t  Test.prototype = {\n\t\t\t    // Use a getter to avoid computing a stack trace (which can be expensive),\n\t\t\t    // This is displayed by the HTML Reporter, but most other integrations do\n\t\t\t    // not access it.\n\t\t\t    get stack() {\n\t\t\t      return extractStacktrace(this.errorForStack, this.stackOffset);\n\t\t\t    },\n\t\t\t    before: function before() {\n\t\t\t      var _this = this;\n\t\t\t      var module = this.module;\n\t\t\t      var notStartedModules = getNotStartedModules(module);\n\n\t\t\t      // ensure the callbacks are executed serially for each module\n\t\t\t      var moduleStartChain = _Promise.resolve();\n\t\t\t      notStartedModules.forEach(function (startModule) {\n\t\t\t        moduleStartChain = moduleStartChain.then(function () {\n\t\t\t          startModule.stats = {\n\t\t\t            all: 0,\n\t\t\t            bad: 0,\n\t\t\t            started: performance.now()\n\t\t\t          };\n\t\t\t          emit('suiteStart', startModule.suiteReport.start(true));\n\t\t\t          return runLoggingCallbacks('moduleStart', {\n\t\t\t            name: startModule.name,\n\t\t\t            tests: startModule.tests\n\t\t\t          });\n\t\t\t        });\n\t\t\t      });\n\t\t\t      return moduleStartChain.then(function () {\n\t\t\t        config.current = _this;\n\t\t\t        _this.testEnvironment = extend({}, module.testEnvironment);\n\t\t\t        _this.started = performance.now();\n\t\t\t        emit('testStart', _this.testReport.start(true));\n\t\t\t        return runLoggingCallbacks('testStart', {\n\t\t\t          name: _this.testName,\n\t\t\t          module: module.name,\n\t\t\t          testId: _this.testId,\n\t\t\t          previousFailure: _this.previousFailure\n\t\t\t        }).then(function () {\n\t\t\t          if (!config.pollution) {\n\t\t\t            saveGlobal();\n\t\t\t          }\n\t\t\t        });\n\t\t\t      });\n\t\t\t    },\n\t\t\t    run: function run() {\n\t\t\t      config.current = this;\n\t\t\t      if (config.notrycatch) {\n\t\t\t        runTest(this);\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      try {\n\t\t\t        runTest(this);\n\t\t\t      } catch (e) {\n\t\t\t        this.pushFailure('Died on test #' + (this.assertions.length + 1) + ': ' + (e.message || e) + '\\n' + this.stack, extractStacktrace(e, 0));\n\n\t\t\t        // Else next test will carry the responsibility\n\t\t\t        saveGlobal();\n\n\t\t\t        // Restart the tests if they're blocking\n\t\t\t        if (config.blocking) {\n\t\t\t          internalRecover(this);\n\t\t\t        }\n\t\t\t      }\n\t\t\t      function runTest(test) {\n\t\t\t        var promise;\n\t\t\t        if (test.withData) {\n\t\t\t          promise = test.callback.call(test.testEnvironment, test.assert, test.data);\n\t\t\t        } else {\n\t\t\t          promise = test.callback.call(test.testEnvironment, test.assert);\n\t\t\t        }\n\t\t\t        test.resolvePromise(promise);\n\n\t\t\t        // If the test has an async \"pause\" on it, but the timeout is 0, then we push a\n\t\t\t        // failure as the test should be synchronous.\n\t\t\t        if (test.timeout === 0 && test.pauses.size > 0) {\n\t\t\t          pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.', sourceFromStacktrace(2));\n\t\t\t        }\n\t\t\t      }\n\t\t\t    },\n\t\t\t    after: function after() {\n\t\t\t      checkPollution();\n\t\t\t    },\n\t\t\t    queueGlobalHook: function queueGlobalHook(hook, hookName) {\n\t\t\t      var _this2 = this;\n\t\t\t      var runHook = function runHook() {\n\t\t\t        config.current = _this2;\n\t\t\t        var promise;\n\t\t\t        if (config.notrycatch) {\n\t\t\t          promise = hook.call(_this2.testEnvironment, _this2.assert);\n\t\t\t        } else {\n\t\t\t          try {\n\t\t\t            promise = hook.call(_this2.testEnvironment, _this2.assert);\n\t\t\t          } catch (error) {\n\t\t\t            _this2.pushFailure('Global ' + hookName + ' failed on ' + _this2.testName + ': ' + errorString(error), extractStacktrace(error, 0));\n\t\t\t            return;\n\t\t\t          }\n\t\t\t        }\n\t\t\t        _this2.resolvePromise(promise, hookName);\n\t\t\t      };\n\t\t\t      return runHook;\n\t\t\t    },\n\t\t\t    queueHook: function queueHook(hook, hookName, hookOwner) {\n\t\t\t      var _this3 = this;\n\t\t\t      var callHook = function callHook() {\n\t\t\t        var promise = hook.call(_this3.testEnvironment, _this3.assert);\n\t\t\t        _this3.resolvePromise(promise, hookName);\n\t\t\t      };\n\t\t\t      var runHook = function runHook() {\n\t\t\t        if (hookName === 'before') {\n\t\t\t          if (hookOwner.testsRun !== 0) {\n\t\t\t            return;\n\t\t\t          }\n\t\t\t          _this3.preserveEnvironment = true;\n\t\t\t        }\n\n\t\t\t        // The 'after' hook should only execute when there are not tests left and\n\t\t\t        // when the 'after' and 'finish' tasks are the only tasks left to process\n\t\t\t        if (hookName === 'after' && !lastTestWithinModuleExecuted(hookOwner) && (config.queue.length > 0 || config.pq.taskCount() > 2)) {\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        config.current = _this3;\n\t\t\t        if (config.notrycatch) {\n\t\t\t          callHook();\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        try {\n\t\t\t          // This try-block includes the indirect call to resolvePromise, which shouldn't\n\t\t\t          // have to be inside try-catch. But, since we support any user-provided thenable\n\t\t\t          // object, the thenable might throw in some unexpected way.\n\t\t\t          // This subtle behaviour is undocumented. To avoid new failures in minor releases\n\t\t\t          // we will not change this until QUnit 3.\n\t\t\t          // TODO: In QUnit 3, reduce this try-block to just hook.call(), matching\n\t\t\t          // the simplicity of queueGlobalHook.\n\t\t\t          callHook();\n\t\t\t        } catch (error) {\n\t\t\t          _this3.pushFailure(hookName + ' failed on ' + _this3.testName + ': ' + (error.message || error), extractStacktrace(error, 0));\n\t\t\t        }\n\t\t\t      };\n\t\t\t      return runHook;\n\t\t\t    },\n\t\t\t    // Currently only used for module level hooks, can be used to add global level ones\n\t\t\t    hooks: function hooks(handler) {\n\t\t\t      var hooks = [];\n\t\t\t      function processGlobalhooks(test) {\n\t\t\t        if ((handler === 'beforeEach' || handler === 'afterEach') && config.globalHooks[handler]) {\n\t\t\t          for (var i = 0; i < config.globalHooks[handler].length; i++) {\n\t\t\t            hooks.push(test.queueGlobalHook(config.globalHooks[handler][i], handler));\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t      function processHooks(test, module) {\n\t\t\t        if (module.parentModule) {\n\t\t\t          processHooks(test, module.parentModule);\n\t\t\t        }\n\t\t\t        if (module.hooks[handler].length) {\n\t\t\t          for (var i = 0; i < module.hooks[handler].length; i++) {\n\t\t\t            hooks.push(test.queueHook(module.hooks[handler][i], handler, module));\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      // Hooks are ignored on skipped tests\n\t\t\t      if (!this.skip) {\n\t\t\t        processGlobalhooks(this);\n\t\t\t        processHooks(this, this.module);\n\t\t\t      }\n\t\t\t      return hooks;\n\t\t\t    },\n\t\t\t    finish: function finish() {\n\t\t\t      config.current = this;\n\n\t\t\t      // Release the timeout and timeout callback references to be garbage collected.\n\t\t\t      // https://github.com/qunitjs/qunit/pull/1708\n\t\t\t      if (setTimeout$1) {\n\t\t\t        clearTimeout(this.timeout);\n\t\t\t        config.timeoutHandler = null;\n\t\t\t      }\n\n\t\t\t      // Release the test callback to ensure that anything referenced has been\n\t\t\t      // released to be garbage collected.\n\t\t\t      this.callback = undefined;\n\t\t\t      if (this.steps.length) {\n\t\t\t        var stepsList = this.steps.join(', ');\n\t\t\t        this.pushFailure('Expected assert.verifySteps() to be called before end of test ' + \"after using assert.step(). Unverified steps: \".concat(stepsList), this.stack);\n\t\t\t      }\n\t\t\t      if (!config._deprecated_countEachStep_shown && !config.countStepsAsOne && this.expected !== null && this.stepsCount) {\n\t\t\t        config._deprecated_countEachStep_shown = true;\n\t\t\t        if (config.requireExpects) {\n\t\t\t          Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. You can enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');\n\t\t\t        } else {\n\t\t\t          Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. Omit assert.expect() from tests that use assert.step(), or enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');\n\t\t\t        }\n\t\t\t      }\n\t\t\t      var actualCountForExpect = config.countStepsAsOne ? this.assertions.length - this.stepsCount : this.assertions.length;\n\t\t\t      if (config.requireExpects && this.expected === null) {\n\t\t\t        this.pushFailure('Expected number of assertions to be defined, but expect() was ' + 'not called.', this.stack);\n\t\t\t      } else if (this.expected !== null && this.expected !== actualCountForExpect && this.stepsCount && this.expected === this.assertions.length - this.stepsCount && !config.countStepsAsOne) {\n\t\t\t        this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run\\nIt looks like you might prefer to enable QUnit.config.countStepsAsOne, which will become the default in QUnit 3.0. https://qunitjs.com/api/assert/expect/', this.stack);\n\t\t\t      } else if (this.expected !== null && this.expected !== actualCountForExpect && this.stepsCount && this.expected === this.assertions.length && config.countStepsAsOne) {\n\t\t\t        this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run\\nRemember that with QUnit.config.countStepsAsOne and in QUnit 3.0, steps no longer count as separate assertions. https://qunitjs.com/api/assert/expect/', this.stack);\n\t\t\t      } else if (this.expected !== null && this.expected !== actualCountForExpect) {\n\t\t\t        this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run', this.stack);\n\t\t\t      } else if (this.expected === null && !actualCountForExpect) {\n\t\t\t        this.pushFailure('Expected at least one assertion, but none were run - call ' + 'expect(0) to accept zero assertions.', this.stack);\n\t\t\t      }\n\t\t\t      var module = this.module;\n\t\t\t      var moduleName = module.name;\n\t\t\t      var testName = this.testName;\n\t\t\t      var skipped = !!this.skip;\n\t\t\t      var todo = !!this.todo;\n\t\t\t      var bad = 0;\n\t\t\t      var storage = config.storage;\n\t\t\t      this.runtime = Math.round(performance.now() - this.started);\n\t\t\t      config.stats.all += this.assertions.length;\n\t\t\t      config.stats.testCount += 1;\n\t\t\t      module.stats.all += this.assertions.length;\n\t\t\t      for (var i = 0; i < this.assertions.length; i++) {\n\t\t\t        // A failing assertion will counts toward the HTML Reporter's\n\t\t\t        // \"X assertions, Y failed\" line even if it was inside a todo.\n\t\t\t        // Inverting this would be similarly confusing since all but the last\n\t\t\t        // passing assertion inside a todo test should be considered as good.\n\t\t\t        // These stats don't decide the outcome of anything, so counting them\n\t\t\t        // as failing seems the most intuitive.\n\t\t\t        if (!this.assertions[i].result) {\n\t\t\t          bad++;\n\t\t\t          config.stats.bad++;\n\t\t\t          module.stats.bad++;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      if (skipped) {\n\t\t\t        incrementTestsIgnored(module);\n\t\t\t      } else {\n\t\t\t        incrementTestsRun(module);\n\t\t\t      }\n\n\t\t\t      // Store result when possible.\n\t\t\t      // Note that this also marks todo tests as bad, thus they get hoisted,\n\t\t\t      // and always run first on refresh.\n\t\t\t      if (storage) {\n\t\t\t        if (bad) {\n\t\t\t          storage.setItem('qunit-test-' + moduleName + '-' + testName, bad);\n\t\t\t        } else {\n\t\t\t          storage.removeItem('qunit-test-' + moduleName + '-' + testName);\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      // After emitting the js-reporters event we cleanup the assertion data to\n\t\t\t      // avoid leaking it. It is not used by the legacy testDone callbacks.\n\t\t\t      emit('testEnd', this.testReport.end(true));\n\t\t\t      this.testReport.slimAssertions();\n\t\t\t      var test = this;\n\t\t\t      return runLoggingCallbacks('testDone', {\n\t\t\t        name: testName,\n\t\t\t        module: moduleName,\n\t\t\t        skipped: skipped,\n\t\t\t        todo: todo,\n\t\t\t        failed: bad,\n\t\t\t        passed: this.assertions.length - bad,\n\t\t\t        total: this.assertions.length,\n\t\t\t        runtime: skipped ? 0 : this.runtime,\n\t\t\t        // HTML Reporter use\n\t\t\t        assertions: this.assertions,\n\t\t\t        testId: this.testId,\n\t\t\t        // Source of Test\n\t\t\t        // generating stack trace is expensive, so using a getter will help defer this until we need it\n\t\t\t        get source() {\n\t\t\t          return test.stack;\n\t\t\t        }\n\t\t\t      }).then(function () {\n\t\t\t        if (allTestsExecuted(module)) {\n\t\t\t          var completedModules = [module];\n\n\t\t\t          // Check if the parent modules, iteratively, are done. If that the case,\n\t\t\t          // we emit the `suiteEnd` event and trigger `moduleDone` callback.\n\t\t\t          var parent = module.parentModule;\n\t\t\t          while (parent && allTestsExecuted(parent)) {\n\t\t\t            completedModules.push(parent);\n\t\t\t            parent = parent.parentModule;\n\t\t\t          }\n\t\t\t          var moduleDoneChain = _Promise.resolve();\n\t\t\t          completedModules.forEach(function (completedModule) {\n\t\t\t            moduleDoneChain = moduleDoneChain.then(function () {\n\t\t\t              return logSuiteEnd(completedModule);\n\t\t\t            });\n\t\t\t          });\n\t\t\t          return moduleDoneChain;\n\t\t\t        }\n\t\t\t      }).then(function () {\n\t\t\t        config.current = undefined;\n\t\t\t      });\n\t\t\t      function logSuiteEnd(module) {\n\t\t\t        // Reset `module.hooks` to ensure that anything referenced in these hooks\n\t\t\t        // has been released to be garbage collected. Descendant modules that were\n\t\t\t        // entirely skipped, e.g. due to filtering, will never have this method\n\t\t\t        // called for them, but might have hooks with references pinning data in\n\t\t\t        // memory (even if the hooks weren't actually executed), so we reset the\n\t\t\t        // hooks on all descendant modules here as well. This is safe because we\n\t\t\t        // will never call this as long as any descendant modules still have tests\n\t\t\t        // to run. This also means that in multi-tiered nesting scenarios we might\n\t\t\t        // reset the hooks multiple times on some modules, but that's harmless.\n\t\t\t        var modules = [module];\n\t\t\t        while (modules.length) {\n\t\t\t          var nextModule = modules.shift();\n\t\t\t          nextModule.hooks = {};\n\t\t\t          modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n\t\t\t        }\n\t\t\t        emit('suiteEnd', module.suiteReport.end(true));\n\t\t\t        return runLoggingCallbacks('moduleDone', {\n\t\t\t          name: module.name,\n\t\t\t          tests: module.tests,\n\t\t\t          failed: module.stats.bad,\n\t\t\t          passed: module.stats.all - module.stats.bad,\n\t\t\t          total: module.stats.all,\n\t\t\t          runtime: Math.round(performance.now() - module.stats.started)\n\t\t\t        });\n\t\t\t      }\n\t\t\t    },\n\t\t\t    preserveTestEnvironment: function preserveTestEnvironment() {\n\t\t\t      if (this.preserveEnvironment) {\n\t\t\t        this.module.testEnvironment = this.testEnvironment;\n\t\t\t        this.testEnvironment = extend({}, this.module.testEnvironment);\n\t\t\t      }\n\t\t\t    },\n\t\t\t    queue: function queue() {\n\t\t\t      var test = this;\n\t\t\t      if (!this.valid()) {\n\t\t\t        incrementTestsIgnored(this.module);\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      function runTest() {\n\t\t\t        return [function () {\n\t\t\t          return test.before();\n\t\t\t        }].concat(_toConsumableArray(test.hooks('before')), [function () {\n\t\t\t          test.preserveTestEnvironment();\n\t\t\t        }], _toConsumableArray(test.hooks('beforeEach')), [function () {\n\t\t\t          test.run();\n\t\t\t        }], _toConsumableArray(test.hooks('afterEach').reverse()), _toConsumableArray(test.hooks('after').reverse()), [function () {\n\t\t\t          test.after();\n\t\t\t        }, function () {\n\t\t\t          return test.finish();\n\t\t\t        }]);\n\t\t\t      }\n\t\t\t      var previousFailCount = config.storage && +config.storage.getItem('qunit-test-' + this.module.name + '-' + this.testName);\n\n\t\t\t      // Prioritize previously failed tests, detected from storage\n\t\t\t      var prioritize = config.reorder && !!previousFailCount;\n\t\t\t      this.previousFailure = !!previousFailCount;\n\t\t\t      config.pq.add(runTest, prioritize);\n\t\t\t    },\n\t\t\t    pushResult: function pushResult(resultInfo) {\n\t\t\t      if (this !== config.current) {\n\t\t\t        var message = resultInfo && resultInfo.message || '';\n\t\t\t        var testName = this && this.testName || '';\n\t\t\t        var error = 'Assertion occurred after test finished.\\n' + '> Test: ' + testName + '\\n' + '> Message: ' + message + '\\n';\n\t\t\t        throw new Error(error);\n\t\t\t      }\n\n\t\t\t      // Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\t\t      var details = {\n\t\t\t        module: this.module.name,\n\t\t\t        name: this.testName,\n\t\t\t        result: resultInfo.result,\n\t\t\t        message: resultInfo.message,\n\t\t\t        actual: resultInfo.actual,\n\t\t\t        testId: this.testId,\n\t\t\t        negative: resultInfo.negative || false,\n\t\t\t        runtime: Math.round(performance.now() - this.started),\n\t\t\t        todo: !!this.todo\n\t\t\t      };\n\t\t\t      if (hasOwn$1.call(resultInfo, 'expected')) {\n\t\t\t        details.expected = resultInfo.expected;\n\t\t\t      }\n\t\t\t      if (!resultInfo.result) {\n\t\t\t        var source = resultInfo.source || sourceFromStacktrace();\n\t\t\t        if (source) {\n\t\t\t          details.source = source;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      this.logAssertion(details);\n\t\t\t      this.assertions.push({\n\t\t\t        result: !!resultInfo.result,\n\t\t\t        message: resultInfo.message\n\t\t\t      });\n\t\t\t    },\n\t\t\t    pushFailure: function pushFailure(message, source) {\n\t\t\t      if (!(this instanceof Test)) {\n\t\t\t        throw new Error('pushFailure() assertion outside test context, was ' + sourceFromStacktrace(2));\n\t\t\t      }\n\t\t\t      this.pushResult({\n\t\t\t        result: false,\n\t\t\t        message: message || 'error',\n\t\t\t        source: source\n\t\t\t      });\n\t\t\t    },\n\t\t\t    /**\n\t\t\t     * Log assertion details using both the old QUnit.log interface and\n\t\t\t     * QUnit.on( \"assertion\" ) interface.\n\t\t\t     *\n\t\t\t     * @private\n\t\t\t     */\n\t\t\t    logAssertion: function logAssertion(details) {\n\t\t\t      runLoggingCallbacks('log', details);\n\t\t\t      var assertion = {\n\t\t\t        passed: details.result,\n\t\t\t        actual: details.actual,\n\t\t\t        expected: details.expected,\n\t\t\t        message: details.message,\n\t\t\t        stack: details.source,\n\t\t\t        todo: details.todo\n\t\t\t      };\n\t\t\t      this.testReport.pushAssertion(assertion);\n\t\t\t      emit('assertion', assertion);\n\t\t\t    },\n\t\t\t    /**\n\t\t\t     * Reset config.timeout with a new timeout duration.\n\t\t\t     *\n\t\t\t     * @param {number} timeoutDuration\n\t\t\t     */\n\t\t\t    internalResetTimeout: function internalResetTimeout(timeoutDuration) {\n\t\t\t      clearTimeout(config.timeout);\n\t\t\t      config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n\t\t\t    },\n\t\t\t    /**\n\t\t\t     * Create a new async pause and return a new function that can release the pause.\n\t\t\t     *\n\t\t\t     * This mechanism is internally used by:\n\t\t\t     *\n\t\t\t     * - explicit async pauses, created by calling `assert.async()`,\n\t\t\t     * - implicit async pauses, created when `QUnit.test()` or module hook callbacks\n\t\t\t     *   use async-await or otherwise return a Promise.\n\t\t\t     *\n\t\t\t     * Happy scenario:\n\t\t\t     *\n\t\t\t     * - Pause is created by calling internalStop().\n\t\t\t     *\n\t\t\t     *   Pause is released normally by invoking release() during the same test.\n\t\t\t     *\n\t\t\t     *   The release() callback lets internal processing resume.\n\t\t\t     *\n\t\t\t     * Failure scenarios:\n\t\t\t     *\n\t\t\t     * - The test fails due to an uncaught exception.\n\t\t\t     *\n\t\t\t     *   In this case, Test.run() will call internalRecover() which empties the clears all\n\t\t\t     *   async pauses and sets the cancelled flag, which means we silently ignore any\n\t\t\t     *   late calls to the resume() callback, as we will have moved on to a different\n\t\t\t     *   test by then, and we don't want to cause an extra \"release during a different test\"\n\t\t\t     *   errors that the developer isn't really responsible for. This can happen when a test\n\t\t\t     *   correctly schedules a call to release(), but also causes an uncaught error. The\n\t\t\t     *   uncaught error means we will no longer wait for the release (as it might not arrive).\n\t\t\t     *\n\t\t\t     * - Pause is never released, or called an insufficient number of times.\n\t\t\t     *\n\t\t\t     *   Our timeout handler will kill the pause and resume test processing, basically\n\t\t\t     *   like internalRecover(), but for one pause instead of any/all.\n\t\t\t     *\n\t\t\t     *   Here, too, any late calls to resume() will be silently ignored to avoid\n\t\t\t     *   extra errors. We tolerate this since the original test will have already been\n\t\t\t     *   marked as failure.\n\t\t\t     *\n\t\t\t     *   TODO: QUnit 3 will enable timeouts by default <https://github.com/qunitjs/qunit/issues/1483>,\n\t\t\t     *   but right now a test will hang indefinitely if async pauses are not released,\n\t\t\t     *   unless QUnit.config.testTimeout or assert.timeout() is used.\n\t\t\t     *\n\t\t\t     * - Pause is spontaneously released during a different test,\n\t\t\t     *   or when no test is currently running.\n\t\t\t     *\n\t\t\t     *   This is close to impossible because this error only happens if the original test\n\t\t\t     *   succesfully finished first (since other failure scenarios kill pauses and ignore\n\t\t\t     *   late calls). It can happen if a test ended exactly as expected, but has some\n\t\t\t     *   external or shared state continuing to hold a reference to the release callback,\n\t\t\t     *   and either the same test scheduled another call to it in the future, or a later test\n\t\t\t     *   causes it to be called through some shared state.\n\t\t\t     *\n\t\t\t     * - Pause release() is called too often, during the same test.\n\t\t\t     *\n\t\t\t     *   This simply throws an error, after which uncaught error handling picks it up\n\t\t\t     *   and processing resumes.\n\t\t\t     *\n\t\t\t     * @param {number} [requiredCalls=1]\n\t\t\t     */\n\t\t\t    internalStop: function internalStop() {\n\t\t\t      var requiredCalls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\t\t\t      config.blocking = true;\n\t\t\t      var test = this;\n\t\t\t      var pauseId = this.nextPauseId++;\n\t\t\t      var pause = {\n\t\t\t        cancelled: false,\n\t\t\t        remaining: requiredCalls\n\t\t\t      };\n\t\t\t      test.pauses.set(pauseId, pause);\n\t\t\t      function release() {\n\t\t\t        if (pause.cancelled) {\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        if (config.current === undefined) {\n\t\t\t          throw new Error('Unexpected release of async pause after tests finished.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n\t\t\t        }\n\t\t\t        if (config.current !== test) {\n\t\t\t          throw new Error('Unexpected release of async pause during a different test.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n\t\t\t        }\n\t\t\t        if (pause.remaining <= 0) {\n\t\t\t          throw new Error('Tried to release async pause that was already released.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n\t\t\t        }\n\n\t\t\t        // The `requiredCalls` parameter exists to support `assert.async(count)`\n\t\t\t        pause.remaining--;\n\t\t\t        if (pause.remaining === 0) {\n\t\t\t          test.pauses.delete(pauseId);\n\t\t\t        }\n\t\t\t        internalStart(test);\n\t\t\t      }\n\n\t\t\t      // Set a recovery timeout, if so configured.\n\t\t\t      if (setTimeout$1) {\n\t\t\t        var timeoutDuration;\n\t\t\t        if (typeof test.timeout === 'number') {\n\t\t\t          timeoutDuration = test.timeout;\n\t\t\t        } else if (typeof config.testTimeout === 'number') {\n\t\t\t          timeoutDuration = config.testTimeout;\n\t\t\t        }\n\t\t\t        if (typeof timeoutDuration === 'number' && timeoutDuration > 0) {\n\t\t\t          config.timeoutHandler = function (timeout) {\n\t\t\t            return function () {\n\t\t\t              config.timeout = null;\n\t\t\t              pause.cancelled = true;\n\t\t\t              test.pauses.delete(pauseId);\n\t\t\t              test.pushFailure(\"Test took longer than \".concat(timeout, \"ms; test timed out.\"), sourceFromStacktrace(2));\n\t\t\t              internalRecover(test);\n\t\t\t            };\n\t\t\t          };\n\t\t\t          clearTimeout(config.timeout);\n\t\t\t          config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n\t\t\t        } else {\n\t\t\t          clearTimeout(config.timeout);\n\t\t\t          config.timeout = setTimeout$1(function () {\n\t\t\t            config.timeout = null;\n\t\t\t            if (!config._deprecated_timeout_shown) {\n\t\t\t              config._deprecated_timeout_shown = true;\n\t\t\t              Logger.warn(\"Test \\\"\".concat(test.testName, \"\\\" took longer than 3000ms, but no timeout was set. Set QUnit.config.testTimeout or call assert.timeout() to avoid a timeout in QUnit 3. https://qunitjs.com/api/config/testTimeout/\"));\n\t\t\t            }\n\t\t\t          }, 3000);\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return release;\n\t\t\t    },\n\t\t\t    resolvePromise: function resolvePromise(promise, phase) {\n\t\t\t      if (promise != null) {\n\t\t\t        var _test = this;\n\t\t\t        var then = promise.then;\n\t\t\t        if (typeof then === 'function') {\n\t\t\t          var resume = _test.internalStop();\n\t\t\t          var resolve = function resolve() {\n\t\t\t            resume();\n\t\t\t          };\n\t\t\t          if (config.notrycatch) {\n\t\t\t            then.call(promise, resolve);\n\t\t\t          } else {\n\t\t\t            var reject = function reject(error) {\n\t\t\t              var message = 'Promise rejected ' + (!phase ? 'during' : phase.replace(/Each$/, '')) + ' \"' + _test.testName + '\": ' + (error && error.message || error);\n\t\t\t              _test.pushFailure(message, extractStacktrace(error, 0));\n\n\t\t\t              // Else next test will carry the responsibility\n\t\t\t              saveGlobal();\n\n\t\t\t              // Unblock\n\t\t\t              internalRecover(_test);\n\t\t\t            };\n\t\t\t            then.call(promise, resolve, reject);\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t    },\n\t\t\t    valid: function valid() {\n\t\t\t      // Internally-generated tests are always valid\n\t\t\t      if (this.callback && this.callback.validTest) {\n\t\t\t        return true;\n\t\t\t      }\n\t\t\t      function moduleChainIdMatch(testModule, selectedId) {\n\t\t\t        return (\n\t\t\t          // undefined or empty array\n\t\t\t          !selectedId || !selectedId.length || inArray(testModule.moduleId, selectedId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule, selectedId)\n\t\t\t        );\n\t\t\t      }\n\t\t\t      if (!moduleChainIdMatch(this.module, config.moduleId)) {\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      if (config.testId && config.testId.length && !inArray(this.testId, config.testId)) {\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      function moduleChainNameMatch(testModule, selectedModule) {\n\t\t\t        if (!selectedModule) {\n\t\t\t          // undefined or empty string\n\t\t\t          return true;\n\t\t\t        }\n\t\t\t        var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\t        if (testModuleName === selectedModule) {\n\t\t\t          return true;\n\t\t\t        } else if (testModule.parentModule) {\n\t\t\t          return moduleChainNameMatch(testModule.parentModule, selectedModule);\n\t\t\t        } else {\n\t\t\t          return false;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      var selectedModule = config.module && config.module.toLowerCase();\n\t\t\t      if (!moduleChainNameMatch(this.module, selectedModule)) {\n\t\t\t        return false;\n\t\t\t      }\n\t\t\t      var filter = config.filter;\n\t\t\t      if (!filter) {\n\t\t\t        return true;\n\t\t\t      }\n\t\t\t      var regexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec(filter);\n\t\t\t      var fullName = this.module.name + ': ' + this.testName;\n\t\t\t      return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);\n\t\t\t    },\n\t\t\t    regexFilter: function regexFilter(exclude, pattern, flags, fullName) {\n\t\t\t      var regex = new RegExp(pattern, flags);\n\t\t\t      var match = regex.test(fullName);\n\t\t\t      return match !== exclude;\n\t\t\t    },\n\t\t\t    stringFilter: function stringFilter(filter, fullName) {\n\t\t\t      filter = filter.toLowerCase();\n\t\t\t      fullName = fullName.toLowerCase();\n\t\t\t      var include = filter.charAt(0) !== '!';\n\t\t\t      if (!include) {\n\t\t\t        filter = filter.slice(1);\n\t\t\t      }\n\n\t\t\t      // If the filter matches, we need to honour include\n\t\t\t      if (fullName.indexOf(filter) !== -1) {\n\t\t\t        return include;\n\t\t\t      }\n\n\t\t\t      // Otherwise, do the opposite\n\t\t\t      return !include;\n\t\t\t    }\n\t\t\t  };\n\t\t\t  function pushFailure() {\n\t\t\t    if (!config.current) {\n\t\t\t      throw new Error('pushFailure() assertion outside test context, in ' + sourceFromStacktrace(2));\n\t\t\t    }\n\n\t\t\t    // Gets current test obj\n\t\t\t    var currentTest = config.current;\n\t\t\t    return currentTest.pushFailure.apply(currentTest, arguments);\n\t\t\t  }\n\t\t\t  function saveGlobal() {\n\t\t\t    config.pollution = [];\n\t\t\t    if (config.noglobals) {\n\t\t\t      for (var key in g) {\n\t\t\t        if (hasOwn$1.call(g, key)) {\n\t\t\t          // In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t          if (/^qunit-test-output/.test(key)) {\n\t\t\t            continue;\n\t\t\t          }\n\t\t\t          config.pollution.push(key);\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function checkPollution() {\n\t\t\t    var old = config.pollution;\n\t\t\t    saveGlobal();\n\t\t\t    var newGlobals = diff$1(config.pollution, old);\n\t\t\t    if (newGlobals.length > 0) {\n\t\t\t      pushFailure('Introduced global variable(s): ' + newGlobals.join(', '));\n\t\t\t    }\n\t\t\t    var deletedGlobals = diff$1(old, config.pollution);\n\t\t\t    if (deletedGlobals.length > 0) {\n\t\t\t      pushFailure('Deleted global variable(s): ' + deletedGlobals.join(', '));\n\t\t\t    }\n\t\t\t  }\n\t\t\t  var focused = false; // indicates that the \"only\" filter was used\n\n\t\t\t  function addTest(settings) {\n\t\t\t    if (focused || config.currentModule.ignored) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    var newTest = new Test(settings);\n\t\t\t    newTest.queue();\n\t\t\t  }\n\t\t\t  function addOnlyTest(settings) {\n\t\t\t    if (config.currentModule.ignored) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    if (!focused) {\n\t\t\t      config.queue.length = 0;\n\t\t\t      focused = true;\n\t\t\t    }\n\t\t\t    var newTest = new Test(settings);\n\t\t\t    newTest.queue();\n\t\t\t  }\n\n\t\t\t  // Will be exposed as QUnit.test\n\t\t\t  function test(testName, callback) {\n\t\t\t    addTest({\n\t\t\t      testName: testName,\n\t\t\t      callback: callback\n\t\t\t    });\n\t\t\t  }\n\t\t\t  function makeEachTestName(testName, argument) {\n\t\t\t    return \"\".concat(testName, \" [\").concat(argument, \"]\");\n\t\t\t  }\n\n\t\t\t  // Characters to avoid in test names especially CLI/AP output:\n\t\t\t  // * x00-1F: e.g. NULL, backspace (\\b), line breaks (\\r\\n), ESC.\n\t\t\t  // * x74: DEL.\n\t\t\t  // * xA0: non-breaking space.\n\t\t\t  //\n\t\t\t  // See https://en.wikipedia.org/wiki/ASCII#Character_order\n\t\t\t  //\n\t\t\t  // eslint-disable-next-line no-control-regex\n\t\t\t  var rNonObviousStr = /[\\x00-\\x1F\\x7F\\xA0]/;\n\t\t\t  function runEach(data, eachFn) {\n\t\t\t    if (Array.isArray(data)) {\n\t\t\t      for (var i = 0; i < data.length; i++) {\n\t\t\t        var value = data[i];\n\n\t\t\t        // Create automatic labels for primitive data in arrays passed to test.each().\n\t\t\t        // We want to avoid the default \"example [0], example [1]\" where possible since\n\t\t\t        // these are not self-explanatory in results, and are also tedious to locate\n\t\t\t        // the source of since the numerical key of an array isn't literally in the\n\t\t\t        // code (you have to count).\n\t\t\t        //\n\t\t\t        // Design requirements:\n\t\t\t        // * Unique. Each label must be unique and correspond 1:1 with a data value.\n\t\t\t        //   This way each test name will hash to a unique testId with Rerun link,\n\t\t\t        //   without having to rely on Test class enforcing uniqueness with invisible\n\t\t\t        //   space hack.\n\t\t\t        // * Unambigious. While technical uniqueness is a hard requirement above,\n\t\t\t        //   we also want the labels to be obvious and unambiguous to humans.\n\t\t\t        //   For example, abbrebating \"foobar\" and \"foobaz\" to \"f\" and \"fo\" is\n\t\t\t        //   technically unique, but ambigious to humans which one is which.\n\t\t\t        // * Short and readable. Where possible we omit the array index numbers\n\t\t\t        //   so that in most cases, the value is simply shown as-is.\n\t\t\t        //   We prefer \"example [foo], example [bar]\"\n\t\t\t        //   over \"example [0: foo], example [2: bar]\".\n\t\t\t        //   This also has the benefit of being stable and robust against e.g.\n\t\t\t        //   re-ordering data or adding new items during development, without\n\t\t\t        //   invalidating a previous filter or rerun link immediately.\n\t\t\t        var valueType = _typeof(value);\n\t\t\t        var testKey = i;\n\t\t\t        if (valueType === 'string' && value.length <= 40 && !rNonObviousStr.test(value) && !/\\s*\\d+: /.test(value)) {\n\t\t\t          testKey = value;\n\t\t\t        } else if (valueType === 'string' || valueType === 'number' || valueType === 'boolean' || valueType === 'undefined' || value === null) {\n\t\t\t          var valueForName = String(value);\n\t\t\t          if (!rNonObviousStr.test(valueForName)) {\n\t\t\t            testKey = i + ': ' + (valueForName.length <= 30 ? valueForName : valueForName.slice(0, 29) + '');\n\t\t\t          }\n\t\t\t        }\n\t\t\t        eachFn(value, testKey);\n\t\t\t      }\n\t\t\t    } else if (_typeof(data) === 'object' && data !== null) {\n\t\t\t      for (var key in data) {\n\t\t\t        eachFn(data[key], key);\n\t\t\t      }\n\t\t\t    } else {\n\t\t\t      throw new Error(\"test.each() expects an array or object as input, but\\nfound \".concat(_typeof(data), \" instead.\"));\n\t\t\t    }\n\t\t\t  }\n\t\t\t  extend(test, {\n\t\t\t    todo: function todo(testName, callback) {\n\t\t\t      addTest({\n\t\t\t        testName: testName,\n\t\t\t        callback: callback,\n\t\t\t        todo: true\n\t\t\t      });\n\t\t\t    },\n\t\t\t    skip: function skip(testName) {\n\t\t\t      addTest({\n\t\t\t        testName: testName,\n\t\t\t        skip: true\n\t\t\t      });\n\t\t\t    },\n\t\t\t    if: function _if(testName, condition, callback) {\n\t\t\t      addTest({\n\t\t\t        testName: testName,\n\t\t\t        callback: callback,\n\t\t\t        skip: !condition\n\t\t\t      });\n\t\t\t    },\n\t\t\t    only: function only(testName, callback) {\n\t\t\t      addOnlyTest({\n\t\t\t        testName: testName,\n\t\t\t        callback: callback\n\t\t\t      });\n\t\t\t    },\n\t\t\t    each: function each(testName, dataset, callback) {\n\t\t\t      runEach(dataset, function (data, testKey) {\n\t\t\t        addTest({\n\t\t\t          testName: makeEachTestName(testName, testKey),\n\t\t\t          callback: callback,\n\t\t\t          withData: true,\n\t\t\t          stackOffset: 5,\n\t\t\t          data: data\n\t\t\t        });\n\t\t\t      });\n\t\t\t    }\n\t\t\t  });\n\t\t\t  test.todo.each = function (testName, dataset, callback) {\n\t\t\t    runEach(dataset, function (data, testKey) {\n\t\t\t      addTest({\n\t\t\t        testName: makeEachTestName(testName, testKey),\n\t\t\t        callback: callback,\n\t\t\t        todo: true,\n\t\t\t        withData: true,\n\t\t\t        stackOffset: 5,\n\t\t\t        data: data\n\t\t\t      });\n\t\t\t    });\n\t\t\t  };\n\t\t\t  test.skip.each = function (testName, dataset) {\n\t\t\t    runEach(dataset, function (_, testKey) {\n\t\t\t      addTest({\n\t\t\t        testName: makeEachTestName(testName, testKey),\n\t\t\t        stackOffset: 5,\n\t\t\t        skip: true\n\t\t\t      });\n\t\t\t    });\n\t\t\t  };\n\t\t\t  test.if.each = function (testName, condition, dataset, callback) {\n\t\t\t    runEach(dataset, function (data, testKey) {\n\t\t\t      addTest({\n\t\t\t        testName: makeEachTestName(testName, testKey),\n\t\t\t        callback: callback,\n\t\t\t        withData: true,\n\t\t\t        stackOffset: 5,\n\t\t\t        skip: !condition,\n\t\t\t        data: condition ? data : undefined\n\t\t\t      });\n\t\t\t    });\n\t\t\t  };\n\t\t\t  test.only.each = function (testName, dataset, callback) {\n\t\t\t    runEach(dataset, function (data, testKey) {\n\t\t\t      addOnlyTest({\n\t\t\t        testName: makeEachTestName(testName, testKey),\n\t\t\t        callback: callback,\n\t\t\t        withData: true,\n\t\t\t        stackOffset: 5,\n\t\t\t        data: data\n\t\t\t      });\n\t\t\t    });\n\t\t\t  };\n\n\t\t\t  // Forcefully release all processing holds.\n\t\t\t  function internalRecover(test) {\n\t\t\t    test.pauses.forEach(function (pause) {\n\t\t\t      pause.cancelled = true;\n\t\t\t    });\n\t\t\t    test.pauses.clear();\n\t\t\t    internalStart(test);\n\t\t\t  }\n\n\t\t\t  // Release a processing hold, scheduling a resumption attempt if no holds remain.\n\t\t\t  function internalStart(test) {\n\t\t\t    // Ignore if other async pauses still exist.\n\t\t\t    if (test.pauses.size > 0) {\n\t\t\t      return;\n\t\t\t    }\n\n\t\t\t    // Add a slight delay to allow more assertions etc.\n\t\t\t    if (setTimeout$1) {\n\t\t\t      clearTimeout(config.timeout);\n\t\t\t      config.timeout = setTimeout$1(function () {\n\t\t\t        if (test.pauses.size > 0) {\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        clearTimeout(config.timeout);\n\t\t\t        config.timeout = null;\n\t\t\t        config.blocking = false;\n\t\t\t        config.pq.advance();\n\t\t\t      });\n\t\t\t    } else {\n\t\t\t      config.blocking = false;\n\t\t\t      config.pq.advance();\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function collectTests(module) {\n\t\t\t    var tests = [].concat(module.tests);\n\t\t\t    var modules = _toConsumableArray(module.childModules);\n\n\t\t\t    // Do a breadth-first traversal of the child modules\n\t\t\t    while (modules.length) {\n\t\t\t      var nextModule = modules.shift();\n\t\t\t      tests.push.apply(tests, nextModule.tests);\n\t\t\t      modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n\t\t\t    }\n\t\t\t    return tests;\n\t\t\t  }\n\n\t\t\t  // This returns true after all executable and skippable tests\n\t\t\t  // in a module have been proccessed, and informs 'suiteEnd'\n\t\t\t  // and moduleDone().\n\t\t\t  function allTestsExecuted(module) {\n\t\t\t    return module.testsRun + module.testsIgnored === collectTests(module).length;\n\t\t\t  }\n\n\t\t\t  // This returns true during the last executable non-skipped test\n\t\t\t  // within a module, and informs the running of the 'after' hook\n\t\t\t  // for a given module. This runs only once for a given module,\n\t\t\t  // but must run during the last non-skipped test. When it runs,\n\t\t\t  // there may be non-zero skipped tests left.\n\t\t\t  function lastTestWithinModuleExecuted(module) {\n\t\t\t    return module.testsRun === collectTests(module).filter(function (test) {\n\t\t\t      return !test.skip;\n\t\t\t    }).length - 1;\n\t\t\t  }\n\t\t\t  function incrementTestsRun(module) {\n\t\t\t    module.testsRun++;\n\t\t\t    while (module = module.parentModule) {\n\t\t\t      module.testsRun++;\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function incrementTestsIgnored(module) {\n\t\t\t    module.testsIgnored++;\n\t\t\t    while (module = module.parentModule) {\n\t\t\t      module.testsIgnored++;\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  /* global module, exports, define */\n\t\t\t  function exportQUnit(QUnit) {\n\t\t\t    var exportedModule = false;\n\t\t\t    if (window$1 && document) {\n\t\t\t      // QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.\n\t\t\t      if (window$1.QUnit && window$1.QUnit.version) {\n\t\t\t        throw new Error('QUnit has already been defined.');\n\t\t\t      }\n\t\t\t      window$1.QUnit = QUnit;\n\t\t\t      exportedModule = true;\n\t\t\t    }\n\n\t\t\t    // For Node.js\n\t\t\t    if (module && module.exports) {\n\t\t\t      module.exports = QUnit;\n\n\t\t\t      // For consistency with CommonJS environments' exports\n\t\t\t      module.exports.QUnit = QUnit;\n\t\t\t      exportedModule = true;\n\t\t\t    }\n\n\t\t\t    // For CommonJS with exports, but without module.exports, like Rhino\n\t\t\t    if (exports) {\n\t\t\t      exports.QUnit = QUnit;\n\t\t\t      exportedModule = true;\n\t\t\t    }\n\n\t\t\t    // For other environments, including Web Workers (globalThis === self),\n\t\t\t    // SpiderMonkey (mozjs), and other embedded JavaScript engines\n\t\t\t    if (!exportedModule) {\n\t\t\t      g.QUnit = QUnit;\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  var ConsoleReporter = /*#__PURE__*/function () {\n\t\t\t    function ConsoleReporter(runner) {\n\t\t\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\t      _classCallCheck(this, ConsoleReporter);\n\t\t\t      // Cache references to console methods to ensure we can report failures\n\t\t\t      // from tests tests that mock the console object itself.\n\t\t\t      // https://github.com/qunitjs/qunit/issues/1340\n\t\t\t      // Support IE 9: Function#bind is supported, but no console.log.bind().\n\t\t\t      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n\t\t\t      runner.on('error', this.onError.bind(this));\n\t\t\t      runner.on('runStart', this.onRunStart.bind(this));\n\t\t\t      runner.on('testStart', this.onTestStart.bind(this));\n\t\t\t      runner.on('testEnd', this.onTestEnd.bind(this));\n\t\t\t      runner.on('runEnd', this.onRunEnd.bind(this));\n\t\t\t    }\n\t\t\t    return _createClass(ConsoleReporter, [{\n\t\t\t      key: \"onError\",\n\t\t\t      value: function onError(error) {\n\t\t\t        this.log('error', error);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onRunStart\",\n\t\t\t      value: function onRunStart(runStart) {\n\t\t\t        this.log('runStart', runStart);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onTestStart\",\n\t\t\t      value: function onTestStart(test) {\n\t\t\t        this.log('testStart', test);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onTestEnd\",\n\t\t\t      value: function onTestEnd(test) {\n\t\t\t        this.log('testEnd', test);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onRunEnd\",\n\t\t\t      value: function onRunEnd(runEnd) {\n\t\t\t        this.log('runEnd', runEnd);\n\t\t\t      }\n\t\t\t    }], [{\n\t\t\t      key: \"init\",\n\t\t\t      value: function init(runner, options) {\n\t\t\t        return new ConsoleReporter(runner, options);\n\t\t\t      }\n\t\t\t    }]);\n\t\t\t  }();\n\n\t\t\t  // TODO: Consider using globalThis instead of window, so that the reporter\n\t\t\t  // works for Node.js as well. As this can add overhead, we should make\n\t\t\t  // this opt-in before we enable it for CLI.\n\t\t\t  //\n\t\t\t  // QUnit 3 will switch from `window` to `globalThis` and then make it\n\t\t\t  // no longer an implicit feature of the HTML Reporter, but rather let\n\t\t\t  // it be opt-in via `QUnit.config.reporters = ['perf']` or something\n\t\t\t  // like that.\n\t\t\t  var nativePerf = window$1 && typeof window$1.performance !== 'undefined' &&\n\t\t\t  // eslint-disable-next-line compat/compat -- Checked\n\t\t\t  typeof window$1.performance.mark === 'function' &&\n\t\t\t  // eslint-disable-next-line compat/compat -- Checked\n\t\t\t  typeof window$1.performance.measure === 'function' ? window$1.performance : undefined;\n\t\t\t  var perf = {\n\t\t\t    measure: nativePerf ? function (comment, startMark, endMark) {\n\t\t\t      // `performance.measure` may fail if the mark could not be found.\n\t\t\t      // reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`\n\t\t\t      try {\n\t\t\t        nativePerf.measure(comment, startMark, endMark);\n\t\t\t      } catch (ex) {\n\t\t\t        Logger.warn('performance.measure could not be executed because of ', ex.message);\n\t\t\t      }\n\t\t\t    } : function () {},\n\t\t\t    mark: nativePerf ? nativePerf.mark.bind(nativePerf) : function () {}\n\t\t\t  };\n\t\t\t  var PerfReporter = /*#__PURE__*/function () {\n\t\t\t    function PerfReporter(runner) {\n\t\t\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\t      _classCallCheck(this, PerfReporter);\n\t\t\t      this.perf = options.perf || perf;\n\t\t\t      runner.on('runStart', this.onRunStart.bind(this));\n\t\t\t      runner.on('runEnd', this.onRunEnd.bind(this));\n\t\t\t      runner.on('suiteStart', this.onSuiteStart.bind(this));\n\t\t\t      runner.on('suiteEnd', this.onSuiteEnd.bind(this));\n\t\t\t      runner.on('testStart', this.onTestStart.bind(this));\n\t\t\t      runner.on('testEnd', this.onTestEnd.bind(this));\n\t\t\t    }\n\t\t\t    return _createClass(PerfReporter, [{\n\t\t\t      key: \"onRunStart\",\n\t\t\t      value: function onRunStart() {\n\t\t\t        this.perf.mark('qunit_suite_0_start');\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onSuiteStart\",\n\t\t\t      value: function onSuiteStart(suiteStart) {\n\t\t\t        var suiteLevel = suiteStart.fullName.length;\n\t\t\t        this.perf.mark(\"qunit_suite_\".concat(suiteLevel, \"_start\"));\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onSuiteEnd\",\n\t\t\t      value: function onSuiteEnd(suiteEnd) {\n\t\t\t        var suiteLevel = suiteEnd.fullName.length;\n\t\t\t        var suiteName = suiteEnd.fullName.join('  ');\n\t\t\t        this.perf.mark(\"qunit_suite_\".concat(suiteLevel, \"_end\"));\n\t\t\t        this.perf.measure(\"QUnit Test Suite: \".concat(suiteName), \"qunit_suite_\".concat(suiteLevel, \"_start\"), \"qunit_suite_\".concat(suiteLevel, \"_end\"));\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onTestStart\",\n\t\t\t      value: function onTestStart() {\n\t\t\t        this.perf.mark('qunit_test_start');\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onTestEnd\",\n\t\t\t      value: function onTestEnd(testEnd) {\n\t\t\t        this.perf.mark('qunit_test_end');\n\t\t\t        var testName = testEnd.fullName.join('  ');\n\t\t\t        this.perf.measure(\"QUnit Test: \".concat(testName), 'qunit_test_start', 'qunit_test_end');\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onRunEnd\",\n\t\t\t      value: function onRunEnd() {\n\t\t\t        this.perf.mark('qunit_suite_0_end');\n\t\t\t        this.perf.measure('QUnit Test Run', 'qunit_suite_0_start', 'qunit_suite_0_end');\n\t\t\t      }\n\t\t\t    }], [{\n\t\t\t      key: \"init\",\n\t\t\t      value: function init(runner, options) {\n\t\t\t        return new PerfReporter(runner, options);\n\t\t\t      }\n\t\t\t    }]);\n\t\t\t  }();\n\n\t\t\t  var FORCE_COLOR,\n\t\t\t    NODE_DISABLE_COLORS,\n\t\t\t    NO_COLOR,\n\t\t\t    TERM,\n\t\t\t    isTTY = true;\n\t\t\t  if (typeof _polyfillNode_process.browser$1 !== 'undefined') {\n\t\t\t    var _ref = _polyfillNode_process.browser$1.env || {};\n\t\t\t    FORCE_COLOR = _ref.FORCE_COLOR;\n\t\t\t    NODE_DISABLE_COLORS = _ref.NODE_DISABLE_COLORS;\n\t\t\t    NO_COLOR = _ref.NO_COLOR;\n\t\t\t    TERM = _ref.TERM;\n\t\t\t    isTTY = _polyfillNode_process.browser$1.stdout && _polyfillNode_process.browser$1.stdout.isTTY;\n\t\t\t  }\n\t\t\t  var $ = {\n\t\t\t    enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY),\n\t\t\t    // modifiers\n\t\t\t    reset: init(0, 0),\n\t\t\t    bold: init(1, 22),\n\t\t\t    dim: init(2, 22),\n\t\t\t    italic: init(3, 23),\n\t\t\t    underline: init(4, 24),\n\t\t\t    inverse: init(7, 27),\n\t\t\t    hidden: init(8, 28),\n\t\t\t    strikethrough: init(9, 29),\n\t\t\t    // colors\n\t\t\t    black: init(30, 39),\n\t\t\t    red: init(31, 39),\n\t\t\t    green: init(32, 39),\n\t\t\t    yellow: init(33, 39),\n\t\t\t    blue: init(34, 39),\n\t\t\t    magenta: init(35, 39),\n\t\t\t    cyan: init(36, 39),\n\t\t\t    white: init(37, 39),\n\t\t\t    gray: init(90, 39),\n\t\t\t    grey: init(90, 39),\n\t\t\t    // background colors\n\t\t\t    bgBlack: init(40, 49),\n\t\t\t    bgRed: init(41, 49),\n\t\t\t    bgGreen: init(42, 49),\n\t\t\t    bgYellow: init(43, 49),\n\t\t\t    bgBlue: init(44, 49),\n\t\t\t    bgMagenta: init(45, 49),\n\t\t\t    bgCyan: init(46, 49),\n\t\t\t    bgWhite: init(47, 49)\n\t\t\t  };\n\t\t\t  function run(arr, str) {\n\t\t\t    var i = 0,\n\t\t\t      tmp,\n\t\t\t      beg = '',\n\t\t\t      end = '';\n\t\t\t    for (; i < arr.length; i++) {\n\t\t\t      tmp = arr[i];\n\t\t\t      beg += tmp.open;\n\t\t\t      end += tmp.close;\n\t\t\t      if (!!~str.indexOf(tmp.close)) {\n\t\t\t        str = str.replace(tmp.rgx, tmp.close + tmp.open);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return beg + str + end;\n\t\t\t  }\n\t\t\t  function chain(has, keys) {\n\t\t\t    var ctx = {\n\t\t\t      has: has,\n\t\t\t      keys: keys\n\t\t\t    };\n\t\t\t    ctx.reset = $.reset.bind(ctx);\n\t\t\t    ctx.bold = $.bold.bind(ctx);\n\t\t\t    ctx.dim = $.dim.bind(ctx);\n\t\t\t    ctx.italic = $.italic.bind(ctx);\n\t\t\t    ctx.underline = $.underline.bind(ctx);\n\t\t\t    ctx.inverse = $.inverse.bind(ctx);\n\t\t\t    ctx.hidden = $.hidden.bind(ctx);\n\t\t\t    ctx.strikethrough = $.strikethrough.bind(ctx);\n\t\t\t    ctx.black = $.black.bind(ctx);\n\t\t\t    ctx.red = $.red.bind(ctx);\n\t\t\t    ctx.green = $.green.bind(ctx);\n\t\t\t    ctx.yellow = $.yellow.bind(ctx);\n\t\t\t    ctx.blue = $.blue.bind(ctx);\n\t\t\t    ctx.magenta = $.magenta.bind(ctx);\n\t\t\t    ctx.cyan = $.cyan.bind(ctx);\n\t\t\t    ctx.white = $.white.bind(ctx);\n\t\t\t    ctx.gray = $.gray.bind(ctx);\n\t\t\t    ctx.grey = $.grey.bind(ctx);\n\t\t\t    ctx.bgBlack = $.bgBlack.bind(ctx);\n\t\t\t    ctx.bgRed = $.bgRed.bind(ctx);\n\t\t\t    ctx.bgGreen = $.bgGreen.bind(ctx);\n\t\t\t    ctx.bgYellow = $.bgYellow.bind(ctx);\n\t\t\t    ctx.bgBlue = $.bgBlue.bind(ctx);\n\t\t\t    ctx.bgMagenta = $.bgMagenta.bind(ctx);\n\t\t\t    ctx.bgCyan = $.bgCyan.bind(ctx);\n\t\t\t    ctx.bgWhite = $.bgWhite.bind(ctx);\n\t\t\t    return ctx;\n\t\t\t  }\n\t\t\t  function init(open, close) {\n\t\t\t    var blk = {\n\t\t\t      open: \"\\x1B[\".concat(open, \"m\"),\n\t\t\t      close: \"\\x1B[\".concat(close, \"m\"),\n\t\t\t      rgx: new RegExp(\"\\\\x1b\\\\[\".concat(close, \"m\"), 'g')\n\t\t\t    };\n\t\t\t    return function (txt) {\n\t\t\t      if (this !== void 0 && this.has !== void 0) {\n\t\t\t        !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));\n\t\t\t        return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';\n\t\t\t      }\n\t\t\t      return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + '') : txt + '';\n\t\t\t    };\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Format a given value into YAML.\n\t\t\t   *\n\t\t\t   * YAML is a superset of JSON that supports all the same data\n\t\t\t   * types and syntax, and more. As such, it is always possible\n\t\t\t   * to fallback to JSON.stringfify, but we generally avoid\n\t\t\t   * that to make output easier to read for humans.\n\t\t\t   *\n\t\t\t   * Supported data types:\n\t\t\t   *\n\t\t\t   * - null\n\t\t\t   * - boolean\n\t\t\t   * - number\n\t\t\t   * - string\n\t\t\t   * - array\n\t\t\t   * - object\n\t\t\t   *\n\t\t\t   * Anything else (including NaN, Infinity, and undefined)\n\t\t\t   * must be described in strings, for display purposes.\n\t\t\t   *\n\t\t\t   * Note that quotes are optional in YAML strings if the\n\t\t\t   * strings are \"simple\", and as such we generally prefer\n\t\t\t   * that for improved readability. We output strings in\n\t\t\t   * one of three ways:\n\t\t\t   *\n\t\t\t   * - bare unquoted text, for simple one-line strings.\n\t\t\t   * - JSON (quoted text), for complex one-line strings.\n\t\t\t   * - YAML Block, for complex multi-line strings.\n\t\t\t   *\n\t\t\t   * Objects with cyclical references will be stringifed as\n\t\t\t   * \"[Circular]\" as they cannot otherwise be represented.\n\t\t\t   */\n\t\t\t  function prettyYamlValue(value) {\n\t\t\t    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\t\t\t    if (value === undefined) {\n\t\t\t      // Not supported in JSON/YAML, turn into string\n\t\t\t      // and let the below output it as bare string.\n\t\t\t      value = String(value);\n\t\t\t    }\n\n\t\t\t    // Support IE 9-11: Use isFinite instead of ES6 Number.isFinite\n\t\t\t    if (typeof value === 'number' && !isFinite(value)) {\n\t\t\t      // Turn NaN and Infinity into simple strings.\n\t\t\t      // Paranoia: Don't return directly just in case there's\n\t\t\t      // a way to add special characters here.\n\t\t\t      value = String(value);\n\t\t\t    }\n\t\t\t    if (typeof value === 'number') {\n\t\t\t      // Simple numbers\n\t\t\t      return JSON.stringify(value);\n\t\t\t    }\n\t\t\t    if (typeof value === 'string') {\n\t\t\t      // If any of these match, then we can't output it\n\t\t\t      // as bare unquoted text, because that would either\n\t\t\t      // cause data loss or invalid YAML syntax.\n\t\t\t      //\n\t\t\t      // - Quotes, escapes, line breaks, or JSON-like stuff.\n\t\t\t      var rSpecialJson = /['\"\\\\/[{}\\]\\r\\n]/;\n\n\t\t\t      // - Characters that are special at the start of a YAML value\n\t\t\t      var rSpecialYaml = /[-?:,[\\]{}#&*!|=>'\"%@`]/;\n\n\t\t\t      // - Leading or trailing whitespace.\n\t\t\t      var rUntrimmed = /(^\\s|\\s$)/;\n\n\t\t\t      // - Ambiguous as YAML number, e.g. '2', '-1.2', '.2', or '2_000'\n\t\t\t      var rNumerical = /^[\\d._-]+$/;\n\n\t\t\t      // - Ambiguous as YAML bool.\n\t\t\t      //   Use case-insensitive match, although technically only\n\t\t\t      //   fully-lower, fully-upper, or uppercase-first would be ambiguous.\n\t\t\t      //   e.g. true/True/TRUE, but not tRUe.\n\t\t\t      var rBool = /^(true|false|y|n|yes|no|on|off)$/i;\n\n\t\t\t      // Is this a complex string?\n\t\t\t      if (value === '' || rSpecialJson.test(value) || rSpecialYaml.test(value[0]) || rUntrimmed.test(value) || rNumerical.test(value) || rBool.test(value)) {\n\t\t\t        if (!/\\n/.test(value)) {\n\t\t\t          // Complex one-line string, use JSON (quoted string)\n\t\t\t          return JSON.stringify(value);\n\t\t\t        }\n\n\t\t\t        // See also <https://yaml-multiline.info/>\n\t\t\t        // Support IE 9-11: Avoid ES6 String#repeat\n\t\t\t        var _prefix = new Array(indent * 2 + 1).join(' ');\n\t\t\t        var trailingLinebreakMatch = value.match(/\\n+$/);\n\t\t\t        var trailingLinebreaks = trailingLinebreakMatch ? trailingLinebreakMatch[0].length : 0;\n\t\t\t        if (trailingLinebreaks === 1) {\n\t\t\t          // Use the most straight-forward \"Block\" string in YAML\n\t\t\t          // without any \"Chomping\" indicators.\n\t\t\t          var lines = value\n\n\t\t\t          // Ignore the last new line, since we'll get that one for free\n\t\t\t          // with the straight-forward Block syntax.\n\t\t\t          .replace(/\\n$/, '').split('\\n').map(function (line) {\n\t\t\t            return _prefix + line;\n\t\t\t          });\n\t\t\t          return '|\\n' + lines.join('\\n');\n\t\t\t        } else {\n\t\t\t          // This has either no trailing new lines, or more than 1.\n\t\t\t          // Use |+ so that YAML parsers will preserve it exactly.\n\t\t\t          var _lines = value.split('\\n').map(function (line) {\n\t\t\t            return _prefix + line;\n\t\t\t          });\n\t\t\t          return '|+\\n' + _lines.join('\\n');\n\t\t\t        }\n\t\t\t      } else {\n\t\t\t        // Simple string, use bare unquoted text\n\t\t\t        return value;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    var prefix = new Array(indent + 1).join(' ');\n\n\t\t\t    // Handle null, boolean, array, and object\n\t\t\t    return JSON.stringify(decycledShallowClone(value), null, 2).split('\\n').map(function (line, i) {\n\t\t\t      return i === 0 ? line : prefix + line;\n\t\t\t    }).join('\\n');\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Creates a shallow clone of an object where cycles have\n\t\t\t   * been replaced with \"[Circular]\".\n\t\t\t   */\n\t\t\t  function decycledShallowClone(object) {\n\t\t\t    var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\t\t    if (ancestors.indexOf(object) !== -1) {\n\t\t\t      return '[Circular]';\n\t\t\t    }\n\t\t\t    var type = Object.prototype.toString.call(object).replace(/^\\[.+\\s(.+?)]$/, '$1').toLowerCase();\n\t\t\t    var clone;\n\t\t\t    switch (type) {\n\t\t\t      case 'array':\n\t\t\t        ancestors.push(object);\n\t\t\t        clone = object.map(function (element) {\n\t\t\t          return decycledShallowClone(element, ancestors);\n\t\t\t        });\n\t\t\t        ancestors.pop();\n\t\t\t        break;\n\t\t\t      case 'object':\n\t\t\t        ancestors.push(object);\n\t\t\t        clone = {};\n\t\t\t        Object.keys(object).forEach(function (key) {\n\t\t\t          clone[key] = decycledShallowClone(object[key], ancestors);\n\t\t\t        });\n\t\t\t        ancestors.pop();\n\t\t\t        break;\n\t\t\t      default:\n\t\t\t        clone = object;\n\t\t\t    }\n\t\t\t    return clone;\n\t\t\t  }\n\t\t\t  var TapReporter = /*#__PURE__*/function () {\n\t\t\t    function TapReporter(runner) {\n\t\t\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\t      _classCallCheck(this, TapReporter);\n\t\t\t      // Cache references to console methods to ensure we can report failures\n\t\t\t      // from tests tests that mock the console object itself.\n\t\t\t      // https://github.com/qunitjs/qunit/issues/1340\n\t\t\t      // Support IE 9: Function#bind is supported, but no console.log.bind().\n\t\t\t      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n\t\t\t      this.testCount = 0;\n\t\t\t      this.started = false;\n\t\t\t      this.ended = false;\n\t\t\t      this.bailed = false;\n\t\t\t      runner.on('error', this.onError.bind(this));\n\t\t\t      runner.on('runStart', this.onRunStart.bind(this));\n\t\t\t      runner.on('testEnd', this.onTestEnd.bind(this));\n\t\t\t      runner.on('runEnd', this.onRunEnd.bind(this));\n\t\t\t    }\n\t\t\t    return _createClass(TapReporter, [{\n\t\t\t      key: \"onRunStart\",\n\t\t\t      value: function onRunStart(_runSuite) {\n\t\t\t        if (!this.started) {\n\t\t\t          this.log('TAP version 13');\n\t\t\t          this.started = true;\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onError\",\n\t\t\t      value: function onError(error) {\n\t\t\t        if (this.bailed) {\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        this.bailed = true;\n\n\t\t\t        // Imitate onTestEnd\n\t\t\t        // Skip this if we're past \"runEnd\" as it would look odd\n\t\t\t        if (!this.ended) {\n\t\t\t          this.onRunStart();\n\t\t\t          this.testCount = this.testCount + 1;\n\t\t\t          this.log(\"not ok \".concat(this.testCount, \" \").concat($.red('global failure')));\n\t\t\t          this.logError(error);\n\t\t\t        }\n\t\t\t        this.log('Bail out! ' + errorString(error).split('\\n')[0]);\n\t\t\t        if (this.ended) {\n\t\t\t          this.logError(error);\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onTestEnd\",\n\t\t\t      value: function onTestEnd(test) {\n\t\t\t        var _this = this;\n\t\t\t        this.testCount = this.testCount + 1;\n\t\t\t        if (test.status === 'passed') {\n\t\t\t          this.log(\"ok \".concat(this.testCount, \" \").concat(test.fullName.join(' > ')));\n\t\t\t        } else if (test.status === 'skipped') {\n\t\t\t          this.log(\"ok \".concat(this.testCount, \" \").concat($.yellow(test.fullName.join(' > ')), \" # SKIP\"));\n\t\t\t        } else if (test.status === 'todo') {\n\t\t\t          this.log(\"not ok \".concat(this.testCount, \" \").concat($.cyan(test.fullName.join(' > ')), \" # TODO\"));\n\t\t\t          test.errors.forEach(function (error) {\n\t\t\t            return _this.logAssertion(error, 'todo');\n\t\t\t          });\n\t\t\t        } else {\n\t\t\t          this.log(\"not ok \".concat(this.testCount, \" \").concat($.red(test.fullName.join(' > '))));\n\t\t\t          test.errors.forEach(function (error) {\n\t\t\t            return _this.logAssertion(error);\n\t\t\t          });\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"onRunEnd\",\n\t\t\t      value: function onRunEnd(runEnd) {\n\t\t\t        this.ended = true;\n\t\t\t        this.log(\"1..\".concat(runEnd.testCounts.total));\n\t\t\t        this.log(\"# pass \".concat(runEnd.testCounts.passed));\n\t\t\t        this.log(\"# \".concat($.yellow(\"skip \".concat(runEnd.testCounts.skipped))));\n\t\t\t        this.log(\"# \".concat($.cyan(\"todo \".concat(runEnd.testCounts.todo))));\n\t\t\t        this.log(\"# \".concat($.red(\"fail \".concat(runEnd.testCounts.failed))));\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"logAssertion\",\n\t\t\t      value: function logAssertion(error, severity) {\n\t\t\t        var out = '  ---';\n\t\t\t        out += \"\\n  message: \".concat(prettyYamlValue(error.message || 'failed'));\n\t\t\t        out += \"\\n  severity: \".concat(prettyYamlValue(severity || 'failed'));\n\n\t\t\t        // When pushFailure() is used, actual/expected are initially unset but\n\t\t\t        // eventually in Test#logAssertion, for testReport#pushAssertion, these are\n\t\t\t        // forged into existence as undefined.\n\t\t\t        var hasAny = error.expected !== undefined || error.actual !== undefined;\n\t\t\t        if (hasAny) {\n\t\t\t          out += \"\\n  actual  : \".concat(prettyYamlValue(error.actual));\n\t\t\t          out += \"\\n  expected: \".concat(prettyYamlValue(error.expected));\n\t\t\t        }\n\t\t\t        if (error.stack) {\n\t\t\t          // Since stacks aren't user generated, take a bit of liberty by\n\t\t\t          // adding a trailing new line to allow a straight-forward YAML Blocks.\n\t\t\t          var fmtStack = annotateStacktrace(error.stack, $.grey);\n\t\t\t          if (fmtStack.length) {\n\t\t\t            out += \"\\n  stack: \".concat(prettyYamlValue(fmtStack + '\\n'));\n\t\t\t          }\n\t\t\t        }\n\t\t\t        out += '\\n  ...';\n\t\t\t        this.log(out);\n\t\t\t      }\n\t\t\t    }, {\n\t\t\t      key: \"logError\",\n\t\t\t      value: function logError(error) {\n\t\t\t        var out = '  ---';\n\t\t\t        out += \"\\n  message: \".concat(prettyYamlValue(errorString(error)));\n\t\t\t        out += \"\\n  severity: \".concat(prettyYamlValue('failed'));\n\t\t\t        if (error && error.stack) {\n\t\t\t          var fmtStack = annotateStacktrace(error.stack, $.grey, error.toString());\n\t\t\t          if (fmtStack.length) {\n\t\t\t            out += \"\\n  stack: \".concat(prettyYamlValue(fmtStack + '\\n'));\n\t\t\t          }\n\t\t\t        }\n\t\t\t        out += '\\n  ...';\n\t\t\t        this.log(out);\n\t\t\t      }\n\t\t\t    }], [{\n\t\t\t      key: \"init\",\n\t\t\t      value: function init(runner, options) {\n\t\t\t        return new TapReporter(runner, options);\n\t\t\t      }\n\t\t\t    }]);\n\t\t\t  }();\n\n\t\t\t  var reporters = {\n\t\t\t    console: ConsoleReporter,\n\t\t\t    perf: PerfReporter,\n\t\t\t    tap: TapReporter\n\t\t\t  };\n\n\t\t\t  function makeAddGlobalHook(hookName) {\n\t\t\t    return function addGlobalHook(callback) {\n\t\t\t      if (!config.globalHooks[hookName]) {\n\t\t\t        config.globalHooks[hookName] = [];\n\t\t\t      }\n\t\t\t      config.globalHooks[hookName].push(callback);\n\t\t\t    };\n\t\t\t  }\n\t\t\t  var hooks = {\n\t\t\t    beforeEach: makeAddGlobalHook('beforeEach'),\n\t\t\t    afterEach: makeAddGlobalHook('afterEach')\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Creates a seeded \"sample\" generator which is used for randomizing tests.\n\t\t\t   */\n\t\t\t  function unitSamplerGenerator(seed) {\n\t\t\t    // 32-bit xorshift, requires only a nonzero seed\n\t\t\t    // https://excamera.com/sphinx/article-xorshift.html\n\t\t\t    var sample = parseInt(generateHash(seed), 16) || -1;\n\t\t\t    return function () {\n\t\t\t      sample ^= sample << 13;\n\t\t\t      sample ^= sample >>> 17;\n\t\t\t      sample ^= sample << 5;\n\n\t\t\t      // ECMAScript has no unsigned number type\n\t\t\t      if (sample < 0) {\n\t\t\t        sample += 0x100000000;\n\t\t\t      }\n\t\t\t      return sample / 0x100000000;\n\t\t\t    };\n\t\t\t  }\n\t\t\t  var ProcessingQueue = /*#__PURE__*/function () {\n\t\t\t    /**\n\t\t\t     * @param {Function} test Reference to the QUnit.test() method\n\t\t\t     */\n\t\t\t    function ProcessingQueue(test) {\n\t\t\t      _classCallCheck(this, ProcessingQueue);\n\t\t\t      this.test = test;\n\t\t\t      this.priorityCount = 0;\n\t\t\t      this.unitSampler = null;\n\n\t\t\t      // This is a queue of functions that are tasks within a single test.\n\t\t\t      // After tests are dequeued from config.queue they are expanded into\n\t\t\t      // a set of tasks in this queue.\n\t\t\t      this.taskQueue = [];\n\t\t\t      this.finished = false;\n\t\t\t    }\n\n\t\t\t    /**\n\t\t\t     * Advances the taskQueue to the next task. If the taskQueue is empty,\n\t\t\t     * process the testQueue\n\t\t\t     */\n\t\t\t    return _createClass(ProcessingQueue, [{\n\t\t\t      key: \"advance\",\n\t\t\t      value: function advance() {\n\t\t\t        this.advanceTaskQueue();\n\t\t\t        if (!this.taskQueue.length && !config.blocking && !config.current) {\n\t\t\t          this.advanceTestQueue();\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * Advances the taskQueue with an increased depth\n\t\t\t       */\n\t\t\t    }, {\n\t\t\t      key: \"advanceTaskQueue\",\n\t\t\t      value: function advanceTaskQueue() {\n\t\t\t        var start = performance.now();\n\t\t\t        config.depth = (config.depth || 0) + 1;\n\t\t\t        this.processTaskQueue(start);\n\t\t\t        config.depth--;\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * Process the first task on the taskQueue as a promise.\n\t\t\t       * Each task is a function added by Test#queue() in /src/test.js\n\t\t\t       */\n\t\t\t    }, {\n\t\t\t      key: \"processTaskQueue\",\n\t\t\t      value: function processTaskQueue(start) {\n\t\t\t        var _this = this;\n\t\t\t        if (this.taskQueue.length && !config.blocking) {\n\t\t\t          var elapsedTime = performance.now() - start;\n\t\t\t          if (!setTimeout$1 || config.updateRate <= 0 || elapsedTime < config.updateRate) {\n\t\t\t            var task = this.taskQueue.shift();\n\t\t\t            _Promise.resolve(task()).then(function () {\n\t\t\t              if (!_this.taskQueue.length) {\n\t\t\t                _this.advance();\n\t\t\t              } else {\n\t\t\t                _this.processTaskQueue(start);\n\t\t\t              }\n\t\t\t            });\n\t\t\t          } else {\n\t\t\t            setTimeout$1(function () {\n\t\t\t              _this.advance();\n\t\t\t            });\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * Advance the testQueue to the next test to process. Call done() if testQueue completes.\n\t\t\t       */\n\t\t\t    }, {\n\t\t\t      key: \"advanceTestQueue\",\n\t\t\t      value: function advanceTestQueue() {\n\t\t\t        if (!config.blocking && !config.queue.length && config.depth === 0) {\n\t\t\t          this.done();\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        var testTasks = config.queue.shift();\n\t\t\t        this.addToTaskQueue(testTasks());\n\t\t\t        if (this.priorityCount > 0) {\n\t\t\t          this.priorityCount--;\n\t\t\t        }\n\t\t\t        this.advance();\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * Enqueue the tasks for a test into the task queue.\n\t\t\t       * @param {Array} tasksArray\n\t\t\t       */\n\t\t\t    }, {\n\t\t\t      key: \"addToTaskQueue\",\n\t\t\t      value: function addToTaskQueue(tasksArray) {\n\t\t\t        var _this$taskQueue;\n\t\t\t        (_this$taskQueue = this.taskQueue).push.apply(_this$taskQueue, _toConsumableArray(tasksArray));\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * Return the number of tasks remaining in the task queue to be processed.\n\t\t\t       * @return {number}\n\t\t\t       */\n\t\t\t    }, {\n\t\t\t      key: \"taskCount\",\n\t\t\t      value: function taskCount() {\n\t\t\t        return this.taskQueue.length;\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * Adds a test to the TestQueue for execution.\n\t\t\t       * @param {Function} testTasksFunc\n\t\t\t       * @param {boolean} prioritize\n\t\t\t       */\n\t\t\t    }, {\n\t\t\t      key: \"add\",\n\t\t\t      value: function add(testTasksFunc, prioritize) {\n\t\t\t        if (prioritize) {\n\t\t\t          config.queue.splice(this.priorityCount++, 0, testTasksFunc);\n\t\t\t        } else if (config.seed) {\n\t\t\t          if (!this.unitSampler) {\n\t\t\t            this.unitSampler = unitSamplerGenerator(config.seed);\n\t\t\t          }\n\n\t\t\t          // Insert into a random position after all prioritized items\n\t\t\t          var index = Math.floor(this.unitSampler() * (config.queue.length - this.priorityCount + 1));\n\t\t\t          config.queue.splice(this.priorityCount + index, 0, testTasksFunc);\n\t\t\t        } else {\n\t\t\t          config.queue.push(testTasksFunc);\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * This function is called when the ProcessingQueue is done processing all\n\t\t\t       * items. It handles emitting the final run events.\n\t\t\t       */\n\t\t\t    }, {\n\t\t\t      key: \"done\",\n\t\t\t      value: function done() {\n\t\t\t        // We have reached the end of the processing queue and are about to emit the\n\t\t\t        // \"runEnd\" event after which reporters typically stop listening and exit\n\t\t\t        // the process. First, check if we need to emit one final test.\n\t\t\t        if (config.stats.testCount === 0 && config.failOnZeroTests === true) {\n\t\t\t          var error;\n\t\t\t          if (config.filter && config.filter.length) {\n\t\t\t            error = new Error(\"No tests matched the filter \\\"\".concat(config.filter, \"\\\".\"));\n\t\t\t          } else if (config.module && config.module.length) {\n\t\t\t            error = new Error(\"No tests matched the module \\\"\".concat(config.module, \"\\\".\"));\n\t\t\t          } else if (config.moduleId && config.moduleId.length) {\n\t\t\t            error = new Error(\"No tests matched the moduleId \\\"\".concat(config.moduleId, \"\\\".\"));\n\t\t\t          } else if (config.testId && config.testId.length) {\n\t\t\t            error = new Error(\"No tests matched the testId \\\"\".concat(config.testId, \"\\\".\"));\n\t\t\t          } else {\n\t\t\t            error = new Error('No tests were run.');\n\t\t\t          }\n\t\t\t          this.test('global failure', extend(function (assert) {\n\t\t\t            assert.pushResult({\n\t\t\t              result: false,\n\t\t\t              message: error.message,\n\t\t\t              source: error.stack\n\t\t\t            });\n\t\t\t          }, {\n\t\t\t            validTest: true\n\t\t\t          }));\n\n\t\t\t          // We do need to call `advance()` in order to resume the processing queue.\n\t\t\t          // Once this new test is finished processing, we'll reach `done` again, and\n\t\t\t          // that time the above condition will evaluate to false.\n\t\t\t          this.advance();\n\t\t\t          return;\n\t\t\t        }\n\t\t\t        var storage = config.storage;\n\t\t\t        var runtime = Math.round(performance.now() - config.started);\n\t\t\t        var passed = config.stats.all - config.stats.bad;\n\t\t\t        this.finished = true;\n\t\t\t        emit('runEnd', runSuite.end(true));\n\t\t\t        runLoggingCallbacks('done', {\n\t\t\t          // @deprecated since 2.19.0 Use done() without `details` parameter,\n\t\t\t          // or use `QUnit.on('runEnd')` instead. Parameter to be replaced in\n\t\t\t          // QUnit 3.0 with test counts.\n\t\t\t          passed: passed,\n\t\t\t          failed: config.stats.bad,\n\t\t\t          total: config.stats.all,\n\t\t\t          runtime: runtime\n\t\t\t        }).then(function () {\n\t\t\t          // Clear own storage items if all tests passed\n\t\t\t          if (storage && config.stats.bad === 0) {\n\t\t\t            for (var i = storage.length - 1; i >= 0; i--) {\n\t\t\t              var key = storage.key(i);\n\t\t\t              if (key.indexOf('qunit-test-') === 0) {\n\t\t\t                storage.removeItem(key);\n\t\t\t              }\n\t\t\t            }\n\t\t\t          }\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }]);\n\t\t\t  }();\n\n\t\t\t  /**\n\t\t\t   * Handle a global error that should result in a failed test run.\n\t\t\t   *\n\t\t\t   * Summary:\n\t\t\t   *\n\t\t\t   * - If we're strictly inside a test (or one if its module hooks), the exception\n\t\t\t   *   becomes a failed assertion.\n\t\t\t   *\n\t\t\t   *   This has the important side-effect that uncaught exceptions (such as\n\t\t\t   *   calling an undefined function) during a \"todo\" test do NOT result in\n\t\t\t   *   a failed test run.\n\t\t\t   *\n\t\t\t   * - If we're anywhere outside a test (be it in early event callbacks, or\n\t\t\t   *   internally between tests, or somewhere after \"runEnd\" if the process is\n\t\t\t   *   still alive for some reason), then send an \"error\" event to the reporters.\n\t\t\t   *\n\t\t\t   * @since 2.17.0\n\t\t\t   * @param {Error|any} error\n\t\t\t   */\n\t\t\t  function onUncaughtException(error) {\n\t\t\t    if (config.current) {\n\t\t\t      // This omits 'actual' and 'expected' (undefined)\n\t\t\t      config.current.assert.pushResult({\n\t\t\t        result: false,\n\t\t\t        message: \"global failure: \".concat(errorString(error)),\n\t\t\t        // We could let callers specify an offset to subtract a number of frames via\n\t\t\t        // sourceFromStacktrace, in case they are a wrapper further away from the error\n\t\t\t        // handler, and thus reduce some noise in the stack trace. However, we're not\n\t\t\t        // doing this right now because it would almost never be used in practice given\n\t\t\t        // the vast majority of error values will be Error objects, and thus have their\n\t\t\t        // own stack trace already.\n\t\t\t        source: error && error.stack || sourceFromStacktrace(2)\n\t\t\t      });\n\t\t\t    } else {\n\t\t\t      // The \"error\" event was added in QUnit 2.17.\n\t\t\t      // Increase \"bad assertion\" stats despite no longer pushing an assertion in this case.\n\t\t\t      // This ensures \"runEnd\" and \"QUnit.done()\" handlers behave as expected, since the \"bad\"\n\t\t\t      // count is typically how reporters decide on the boolean outcome of the test run.\n\t\t\t      runSuite.globalFailureCount++;\n\t\t\t      config.stats.bad++;\n\t\t\t      config.stats.all++;\n\t\t\t      emit('error', error);\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  /**\n\t\t\t   * Handle a window.onerror error.\n\t\t\t   *\n\t\t\t   * If there is a current test that sets the internal `ignoreGlobalErrors` field\n\t\t\t   * (such as during `assert.throws()`), then the error is ignored and native\n\t\t\t   * error reporting is suppressed as well. This is because in browsers, an error\n\t\t\t   * can sometimes end up in `window.onerror` instead of in the local try/catch.\n\t\t\t   * This ignoring of errors does not apply to our general onUncaughtException\n\t\t\t   * method, nor to our `unhandledRejection` handlers, as those are not meant\n\t\t\t   * to receive an \"expected\" error during `assert.throws()`.\n\t\t\t   *\n\t\t\t   * @see <https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror>\n\t\t\t   * @deprecated since 2.17.0 Use QUnit.onUncaughtException instead.\n\t\t\t   * @param {Object} details\n\t\t\t   * @param {string} details.message\n\t\t\t   * @param {string} details.fileName\n\t\t\t   * @param {number} details.lineNumber\n\t\t\t   * @param {string|undefined} [details.stacktrace]\n\t\t\t   * @return {bool} True if native error reporting should be suppressed.\n\t\t\t   */\n\t\t\t  function onWindowError(details) {\n\t\t\t    Logger.warn('QUnit.onError is deprecated and will be removed in QUnit 3.0.' + ' Please use QUnit.onUncaughtException instead.');\n\t\t\t    if (config.current && config.current.ignoreGlobalErrors) {\n\t\t\t      return true;\n\t\t\t    }\n\t\t\t    var err = new Error(details.message);\n\t\t\t    err.stack = details.stacktrace || details.fileName + ':' + details.lineNumber;\n\t\t\t    onUncaughtException(err);\n\t\t\t    return false;\n\t\t\t  }\n\n\t\t\t  /* eslint-disable indent */\n\n\t\t\t  /*\n\t\t\t   * This file is a modified version of google-diff-match-patch's JavaScript implementation\n\t\t\t   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n\t\t\t   * modifications are licensed as more fully set forth in LICENSE.txt.\n\t\t\t   *\n\t\t\t   * The original source of google-diff-match-patch is attributable and licensed as follows:\n\t\t\t   *\n\t\t\t   * Copyright 2006 Google Inc.\n\t\t\t   * https://code.google.com/p/google-diff-match-patch/\n\t\t\t   *\n\t\t\t   * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t\t\t   * you may not use this file except in compliance with the License.\n\t\t\t   * You may obtain a copy of the License at\n\t\t\t   *\n\t\t\t   * https://www.apache.org/licenses/LICENSE-2.0\n\t\t\t   *\n\t\t\t   * Unless required by applicable law or agreed to in writing, software\n\t\t\t   * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t\t\t   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t\t\t   * See the License for the specific language governing permissions and\n\t\t\t   * limitations under the License.\n\t\t\t   *\n\t\t\t   * More Info:\n\t\t\t   *  https://code.google.com/p/google-diff-match-patch/\n\t\t\t   *\n\t\t\t   * Usage: QUnit.diff(expected, actual)\n\t\t\t   *\n\t\t\t   */\n\t\t\t  function DiffMatchPatch() {}\n\n\t\t\t  //  DIFF FUNCTIONS\n\n\t\t\t  /**\n\t\t\t   * The data structure representing a diff is an array of tuples:\n\t\t\t   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t\t\t   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t\t\t   */\n\t\t\t  var DIFF_DELETE = -1;\n\t\t\t  var DIFF_INSERT = 1;\n\t\t\t  var DIFF_EQUAL = 0;\n\t\t\t  var hasOwn = Object.prototype.hasOwnProperty;\n\n\t\t\t  /**\n\t\t\t   * Find the differences between two texts.  Simplifies the problem by stripping\n\t\t\t   * any common prefix or suffix off the texts before diffing.\n\t\t\t   * @param {string} text1 Old string to be diffed.\n\t\t\t   * @param {string} text2 New string to be diffed.\n\t\t\t   * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t\t\t   *     then don't run a line-level diff first to identify the changed areas.\n\t\t\t   *     Defaults to true, which does a faster, slightly less optimal diff.\n\t\t\t   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {\n\t\t\t    // The diff must be complete in up to 1 second.\n\t\t\t    var deadline = Date.now() + 1000;\n\n\t\t\t    // Check for null inputs.\n\t\t\t    if (text1 === null || text2 === null) {\n\t\t\t      throw new Error('Cannot diff null input.');\n\t\t\t    }\n\n\t\t\t    // Check for equality (speedup).\n\t\t\t    if (text1 === text2) {\n\t\t\t      if (text1) {\n\t\t\t        return [[DIFF_EQUAL, text1]];\n\t\t\t      }\n\t\t\t      return [];\n\t\t\t    }\n\t\t\t    if (typeof optChecklines === 'undefined') {\n\t\t\t      optChecklines = true;\n\t\t\t    }\n\n\t\t\t    // Trim off common prefix (speedup).\n\t\t\t    var commonlength = this.diffCommonPrefix(text1, text2);\n\t\t\t    var commonprefix = text1.substring(0, commonlength);\n\t\t\t    text1 = text1.substring(commonlength);\n\t\t\t    text2 = text2.substring(commonlength);\n\n\t\t\t    // Trim off common suffix (speedup).\n\t\t\t    commonlength = this.diffCommonSuffix(text1, text2);\n\t\t\t    var commonsuffix = text1.substring(text1.length - commonlength);\n\t\t\t    text1 = text1.substring(0, text1.length - commonlength);\n\t\t\t    text2 = text2.substring(0, text2.length - commonlength);\n\n\t\t\t    // Compute the diff on the middle block.\n\t\t\t    var diffs = this.diffCompute(text1, text2, optChecklines, deadline);\n\n\t\t\t    // Restore the prefix and suffix.\n\t\t\t    if (commonprefix) {\n\t\t\t      diffs.unshift([DIFF_EQUAL, commonprefix]);\n\t\t\t    }\n\t\t\t    if (commonsuffix) {\n\t\t\t      diffs.push([DIFF_EQUAL, commonsuffix]);\n\t\t\t    }\n\t\t\t    this.diffCleanupMerge(diffs);\n\t\t\t    return diffs;\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Reduce the number of edits by eliminating operationally trivial equalities.\n\t\t\t   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {\n\t\t\t    var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n\t\t\t    changes = false;\n\t\t\t    equalities = []; // Stack of indices where equalities are found.\n\t\t\t    equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t    /** @type {?string} */\n\t\t\t    lastequality = null;\n\n\t\t\t    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\t    pointer = 0; // Index of current position.\n\n\t\t\t    // Is there an insertion operation before the last equality.\n\t\t\t    preIns = false;\n\n\t\t\t    // Is there a deletion operation before the last equality.\n\t\t\t    preDel = false;\n\n\t\t\t    // Is there an insertion operation after the last equality.\n\t\t\t    postIns = false;\n\n\t\t\t    // Is there a deletion operation after the last equality.\n\t\t\t    postDel = false;\n\t\t\t    while (pointer < diffs.length) {\n\t\t\t      // Equality found.\n\t\t\t      if (diffs[pointer][0] === DIFF_EQUAL) {\n\t\t\t        if (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n\t\t\t          // Candidate found.\n\t\t\t          equalities[equalitiesLength++] = pointer;\n\t\t\t          preIns = postIns;\n\t\t\t          preDel = postDel;\n\t\t\t          lastequality = diffs[pointer][1];\n\t\t\t        } else {\n\t\t\t          // Not a candidate, and can never become one.\n\t\t\t          equalitiesLength = 0;\n\t\t\t          lastequality = null;\n\t\t\t        }\n\t\t\t        postIns = postDel = false;\n\n\t\t\t        // An insertion or deletion.\n\t\t\t      } else {\n\t\t\t        if (diffs[pointer][0] === DIFF_DELETE) {\n\t\t\t          postDel = true;\n\t\t\t        } else {\n\t\t\t          postIns = true;\n\t\t\t        }\n\n\t\t\t        /*\n\t\t\t         * Five types to be split:\n\t\t\t         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t         * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t         * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t         * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t         * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t         */\n\t\t\t        if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n\t\t\t          // Duplicate record.\n\t\t\t          diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n\t\t\t          // Change second copy to insert.\n\t\t\t          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\t\t\t          equalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t          lastequality = null;\n\t\t\t          if (preIns && preDel) {\n\t\t\t            // No changes made which could affect previous entry, keep going.\n\t\t\t            postIns = postDel = true;\n\t\t\t            equalitiesLength = 0;\n\t\t\t          } else {\n\t\t\t            equalitiesLength--; // Throw away the previous equality.\n\t\t\t            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\t\t\t            postIns = postDel = false;\n\t\t\t          }\n\t\t\t          changes = true;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      pointer++;\n\t\t\t    }\n\t\t\t    if (changes) {\n\t\t\t      this.diffCleanupMerge(diffs);\n\t\t\t    }\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Convert a diff array into a pretty HTML report.\n\t\t\t   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t\t   * @param {integer} string to be beautified.\n\t\t\t   * @return {string} HTML representation.\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {\n\t\t\t    var html = [];\n\t\t\t    for (var x = 0; x < diffs.length; x++) {\n\t\t\t      var op = diffs[x][0]; // Operation (insert, delete, equal)\n\t\t\t      var data = diffs[x][1]; // Text of change.\n\t\t\t      switch (op) {\n\t\t\t        case DIFF_INSERT:\n\t\t\t          html[x] = '<ins>' + escapeText(data) + '</ins>';\n\t\t\t          break;\n\t\t\t        case DIFF_DELETE:\n\t\t\t          html[x] = '<del>' + escapeText(data) + '</del>';\n\t\t\t          break;\n\t\t\t        case DIFF_EQUAL:\n\t\t\t          html[x] = '<span>' + escapeText(data) + '</span>';\n\t\t\t          break;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    return html.join('');\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Determine the common prefix of two strings.\n\t\t\t   * @param {string} text1 First string.\n\t\t\t   * @param {string} text2 Second string.\n\t\t\t   * @return {number} The number of characters common to the start of each\n\t\t\t   *     string.\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {\n\t\t\t    var pointermid, pointermax, pointermin, pointerstart;\n\n\t\t\t    // Quick check for common null cases.\n\t\t\t    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n\t\t\t      return 0;\n\t\t\t    }\n\n\t\t\t    // Binary search.\n\t\t\t    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\t\t    pointermin = 0;\n\t\t\t    pointermax = Math.min(text1.length, text2.length);\n\t\t\t    pointermid = pointermax;\n\t\t\t    pointerstart = 0;\n\t\t\t    while (pointermin < pointermid) {\n\t\t\t      if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n\t\t\t        pointermin = pointermid;\n\t\t\t        pointerstart = pointermin;\n\t\t\t      } else {\n\t\t\t        pointermax = pointermid;\n\t\t\t      }\n\t\t\t      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t\t\t    }\n\t\t\t    return pointermid;\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Determine the common suffix of two strings.\n\t\t\t   * @param {string} text1 First string.\n\t\t\t   * @param {string} text2 Second string.\n\t\t\t   * @return {number} The number of characters common to the end of each string.\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {\n\t\t\t    var pointermid, pointermax, pointermin, pointerend;\n\n\t\t\t    // Quick check for common null cases.\n\t\t\t    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n\t\t\t      return 0;\n\t\t\t    }\n\n\t\t\t    // Binary search.\n\t\t\t    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\t\t    pointermin = 0;\n\t\t\t    pointermax = Math.min(text1.length, text2.length);\n\t\t\t    pointermid = pointermax;\n\t\t\t    pointerend = 0;\n\t\t\t    while (pointermin < pointermid) {\n\t\t\t      if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n\t\t\t        pointermin = pointermid;\n\t\t\t        pointerend = pointermin;\n\t\t\t      } else {\n\t\t\t        pointermax = pointermid;\n\t\t\t      }\n\t\t\t      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t\t\t    }\n\t\t\t    return pointermid;\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Find the differences between two texts.  Assumes that the texts do not\n\t\t\t   * have any common prefix or suffix.\n\t\t\t   * @param {string} text1 Old string to be diffed.\n\t\t\t   * @param {string} text2 New string to be diffed.\n\t\t\t   * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t\t\t   *     line-level diff first to identify the changed areas.\n\t\t\t   *     If true, then run a faster, slightly less optimal diff.\n\t\t\t   * @param {number} deadline Time when the diff should be complete by.\n\t\t\t   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {\n\t\t\t    var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n\t\t\t    if (!text1) {\n\t\t\t      // Just add some text (speedup).\n\t\t\t      return [[DIFF_INSERT, text2]];\n\t\t\t    }\n\t\t\t    if (!text2) {\n\t\t\t      // Just delete some text (speedup).\n\t\t\t      return [[DIFF_DELETE, text1]];\n\t\t\t    }\n\t\t\t    longtext = text1.length > text2.length ? text1 : text2;\n\t\t\t    shorttext = text1.length > text2.length ? text2 : text1;\n\t\t\t    i = longtext.indexOf(shorttext);\n\t\t\t    if (i !== -1) {\n\t\t\t      // Shorter text is inside the longer text (speedup).\n\t\t\t      diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n\n\t\t\t      // Swap insertions for deletions if diff is reversed.\n\t\t\t      if (text1.length > text2.length) {\n\t\t\t        diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n\t\t\t      }\n\t\t\t      return diffs;\n\t\t\t    }\n\t\t\t    if (shorttext.length === 1) {\n\t\t\t      // Single character string.\n\t\t\t      // After the previous speedup, the character can't be an equality.\n\t\t\t      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t\t\t    }\n\n\t\t\t    // Check to see if the problem can be split in two.\n\t\t\t    hm = this.diffHalfMatch(text1, text2);\n\t\t\t    if (hm) {\n\t\t\t      // A half-match was found, sort out the return data.\n\t\t\t      text1A = hm[0];\n\t\t\t      text1B = hm[1];\n\t\t\t      text2A = hm[2];\n\t\t\t      text2B = hm[3];\n\t\t\t      midCommon = hm[4];\n\n\t\t\t      // Send both pairs off for separate processing.\n\t\t\t      diffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n\t\t\t      diffsB = this.DiffMain(text1B, text2B, checklines, deadline);\n\n\t\t\t      // Merge the results.\n\t\t\t      return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n\t\t\t    }\n\t\t\t    if (checklines && text1.length > 100 && text2.length > 100) {\n\t\t\t      return this.diffLineMode(text1, text2, deadline);\n\t\t\t    }\n\t\t\t    return this.diffBisect(text1, text2, deadline);\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Do the two texts share a substring which is at least half the length of the\n\t\t\t   * longer text?\n\t\t\t   * This speedup can produce non-minimal diffs.\n\t\t\t   * @param {string} text1 First string.\n\t\t\t   * @param {string} text2 Second string.\n\t\t\t   * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t\t   *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t\t\t   *     text2 and the common middle.  Or null if there was no match.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {\n\t\t\t    var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n\t\t\t    longtext = text1.length > text2.length ? text1 : text2;\n\t\t\t    shorttext = text1.length > text2.length ? text2 : text1;\n\t\t\t    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n\t\t\t      return null; // Pointless.\n\t\t\t    }\n\t\t\t    dmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t\t    /**\n\t\t\t     * Does a substring of shorttext exist within longtext such that the substring\n\t\t\t     * is at least half the length of longtext?\n\t\t\t     * Closure, but does not reference any external variables.\n\t\t\t     * @param {string} longtext Longer string.\n\t\t\t     * @param {string} shorttext Shorter string.\n\t\t\t     * @param {number} i Start index of quarter length substring within longtext.\n\t\t\t     * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t\t     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t\t     *     of shorttext and the common middle.  Or null if there was no match.\n\t\t\t     * @private\n\t\t\t     */\n\t\t\t    function diffHalfMatchI(longtext, shorttext, i) {\n\t\t\t      var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t      // Start with a 1/4 length substring at position i as a seed.\n\t\t\t      seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n\t\t\t      j = -1;\n\t\t\t      bestCommon = '';\n\t\t\t      while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n\t\t\t        prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n\t\t\t        suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n\t\t\t        if (bestCommon.length < suffixLength + prefixLength) {\n\t\t\t          bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n\t\t\t          bestLongtextA = longtext.substring(0, i - suffixLength);\n\t\t\t          bestLongtextB = longtext.substring(i + prefixLength);\n\t\t\t          bestShorttextA = shorttext.substring(0, j - suffixLength);\n\t\t\t          bestShorttextB = shorttext.substring(j + prefixLength);\n\t\t\t        }\n\t\t\t      }\n\t\t\t      if (bestCommon.length * 2 >= longtext.length) {\n\t\t\t        return [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];\n\t\t\t      } else {\n\t\t\t        return null;\n\t\t\t      }\n\t\t\t    }\n\n\t\t\t    // First check if the second quarter is the seed for a half-match.\n\t\t\t    hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n\n\t\t\t    // Check again based on the third quarter.\n\t\t\t    hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n\t\t\t    if (!hm1 && !hm2) {\n\t\t\t      return null;\n\t\t\t    } else if (!hm2) {\n\t\t\t      hm = hm1;\n\t\t\t    } else if (!hm1) {\n\t\t\t      hm = hm2;\n\t\t\t    } else {\n\t\t\t      // Both matched.  Select the longest.\n\t\t\t      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n\t\t\t    }\n\n\t\t\t    // A half-match was found, sort out the return data.\n\t\t\t    if (text1.length > text2.length) {\n\t\t\t      text1A = hm[0];\n\t\t\t      text1B = hm[1];\n\t\t\t      text2A = hm[2];\n\t\t\t      text2B = hm[3];\n\t\t\t    } else {\n\t\t\t      text2A = hm[0];\n\t\t\t      text2B = hm[1];\n\t\t\t      text1A = hm[2];\n\t\t\t      text1B = hm[3];\n\t\t\t    }\n\t\t\t    midCommon = hm[4];\n\t\t\t    return [text1A, text1B, text2A, text2B, midCommon];\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Do a quick line-level diff on both strings, then rediff the parts for\n\t\t\t   * greater accuracy.\n\t\t\t   * This speedup can produce non-minimal diffs.\n\t\t\t   * @param {string} text1 Old string to be diffed.\n\t\t\t   * @param {string} text2 New string to be diffed.\n\t\t\t   * @param {number} deadline Time when the diff should be complete by.\n\t\t\t   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {\n\t\t\t    var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;\n\n\t\t\t    // Scan the text on a line-by-line basis first.\n\t\t\t    a = this.diffLinesToChars(text1, text2);\n\t\t\t    text1 = a.chars1;\n\t\t\t    text2 = a.chars2;\n\t\t\t    linearray = a.lineArray;\n\t\t\t    diffs = this.DiffMain(text1, text2, false, deadline);\n\n\t\t\t    // Convert the diff back to original text.\n\t\t\t    this.diffCharsToLines(diffs, linearray);\n\n\t\t\t    // Eliminate freak matches (e.g. blank lines)\n\t\t\t    this.diffCleanupSemantic(diffs);\n\n\t\t\t    // Rediff any replacement blocks, this time character-by-character.\n\t\t\t    // Add a dummy entry at the end.\n\t\t\t    diffs.push([DIFF_EQUAL, '']);\n\t\t\t    pointer = 0;\n\t\t\t    countDelete = 0;\n\t\t\t    countInsert = 0;\n\t\t\t    textDelete = '';\n\t\t\t    textInsert = '';\n\t\t\t    while (pointer < diffs.length) {\n\t\t\t      switch (diffs[pointer][0]) {\n\t\t\t        case DIFF_INSERT:\n\t\t\t          countInsert++;\n\t\t\t          textInsert += diffs[pointer][1];\n\t\t\t          break;\n\t\t\t        case DIFF_DELETE:\n\t\t\t          countDelete++;\n\t\t\t          textDelete += diffs[pointer][1];\n\t\t\t          break;\n\t\t\t        case DIFF_EQUAL:\n\t\t\t          // Upon reaching an equality, check for prior redundancies.\n\t\t\t          if (countDelete >= 1 && countInsert >= 1) {\n\t\t\t            // Delete the offending records and add the merged ones.\n\t\t\t            diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n\t\t\t            pointer = pointer - countDelete - countInsert;\n\t\t\t            a = this.DiffMain(textDelete, textInsert, false, deadline);\n\t\t\t            for (j = a.length - 1; j >= 0; j--) {\n\t\t\t              diffs.splice(pointer, 0, a[j]);\n\t\t\t            }\n\t\t\t            pointer = pointer + a.length;\n\t\t\t          }\n\t\t\t          countInsert = 0;\n\t\t\t          countDelete = 0;\n\t\t\t          textDelete = '';\n\t\t\t          textInsert = '';\n\t\t\t          break;\n\t\t\t      }\n\t\t\t      pointer++;\n\t\t\t    }\n\t\t\t    diffs.pop(); // Remove the dummy entry at the end.\n\n\t\t\t    return diffs;\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Find the 'middle snake' of a diff, split the problem in two\n\t\t\t   * and return the recursively constructed diff.\n\t\t\t   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t\t\t   * @param {string} text1 Old string to be diffed.\n\t\t\t   * @param {string} text2 New string to be diffed.\n\t\t\t   * @param {number} deadline Time at which to bail if not yet complete.\n\t\t\t   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {\n\t\t\t    var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t\t    // Cache the text lengths to prevent multiple calls.\n\t\t\t    text1Length = text1.length;\n\t\t\t    text2Length = text2.length;\n\t\t\t    maxD = Math.ceil((text1Length + text2Length) / 2);\n\t\t\t    vOffset = maxD;\n\t\t\t    vLength = 2 * maxD;\n\t\t\t    v1 = new Array(vLength);\n\t\t\t    v2 = new Array(vLength);\n\n\t\t\t    // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t\t    // integers and undefined.\n\t\t\t    for (x = 0; x < vLength; x++) {\n\t\t\t      v1[x] = -1;\n\t\t\t      v2[x] = -1;\n\t\t\t    }\n\t\t\t    v1[vOffset + 1] = 0;\n\t\t\t    v2[vOffset + 1] = 0;\n\t\t\t    delta = text1Length - text2Length;\n\n\t\t\t    // If the total number of characters is odd, then the front path will collide\n\t\t\t    // with the reverse path.\n\t\t\t    front = delta % 2 !== 0;\n\n\t\t\t    // Offsets for start and end of k loop.\n\t\t\t    // Prevents mapping of space beyond the grid.\n\t\t\t    k1start = 0;\n\t\t\t    k1end = 0;\n\t\t\t    k2start = 0;\n\t\t\t    k2end = 0;\n\t\t\t    for (d = 0; d < maxD; d++) {\n\t\t\t      // Bail out if deadline is reached.\n\t\t\t      if (Date.now() > deadline) {\n\t\t\t        break;\n\t\t\t      }\n\n\t\t\t      // Walk the front path one step.\n\t\t\t      for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n\t\t\t        k1Offset = vOffset + k1;\n\t\t\t        if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {\n\t\t\t          x1 = v1[k1Offset + 1];\n\t\t\t        } else {\n\t\t\t          x1 = v1[k1Offset - 1] + 1;\n\t\t\t        }\n\t\t\t        y1 = x1 - k1;\n\t\t\t        while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n\t\t\t          x1++;\n\t\t\t          y1++;\n\t\t\t        }\n\t\t\t        v1[k1Offset] = x1;\n\t\t\t        if (x1 > text1Length) {\n\t\t\t          // Ran off the right of the graph.\n\t\t\t          k1end += 2;\n\t\t\t        } else if (y1 > text2Length) {\n\t\t\t          // Ran off the bottom of the graph.\n\t\t\t          k1start += 2;\n\t\t\t        } else if (front) {\n\t\t\t          k2Offset = vOffset + delta - k1;\n\t\t\t          if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n\t\t\t            // Mirror x2 onto top-left coordinate system.\n\t\t\t            x2 = text1Length - v2[k2Offset];\n\t\t\t            if (x1 >= x2) {\n\t\t\t              // Overlap detected.\n\t\t\t              return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n\t\t\t            }\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      // Walk the reverse path one step.\n\t\t\t      for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n\t\t\t        k2Offset = vOffset + k2;\n\t\t\t        if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {\n\t\t\t          x2 = v2[k2Offset + 1];\n\t\t\t        } else {\n\t\t\t          x2 = v2[k2Offset - 1] + 1;\n\t\t\t        }\n\t\t\t        y2 = x2 - k2;\n\t\t\t        while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n\t\t\t          x2++;\n\t\t\t          y2++;\n\t\t\t        }\n\t\t\t        v2[k2Offset] = x2;\n\t\t\t        if (x2 > text1Length) {\n\t\t\t          // Ran off the left of the graph.\n\t\t\t          k2end += 2;\n\t\t\t        } else if (y2 > text2Length) {\n\t\t\t          // Ran off the top of the graph.\n\t\t\t          k2start += 2;\n\t\t\t        } else if (!front) {\n\t\t\t          k1Offset = vOffset + delta - k2;\n\t\t\t          if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n\t\t\t            x1 = v1[k1Offset];\n\t\t\t            y1 = vOffset + x1 - k1Offset;\n\n\t\t\t            // Mirror x2 onto top-left coordinate system.\n\t\t\t            x2 = text1Length - x2;\n\t\t\t            if (x1 >= x2) {\n\t\t\t              // Overlap detected.\n\t\t\t              return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n\t\t\t            }\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t    }\n\n\t\t\t    // Diff took too long and hit the deadline or\n\t\t\t    // number of diffs equals number of characters, no commonality at all.\n\t\t\t    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Given the location of the 'middle snake', split the diff in two parts\n\t\t\t   * and recurse.\n\t\t\t   * @param {string} text1 Old string to be diffed.\n\t\t\t   * @param {string} text2 New string to be diffed.\n\t\t\t   * @param {number} x Index of split point in text1.\n\t\t\t   * @param {number} y Index of split point in text2.\n\t\t\t   * @param {number} deadline Time at which to bail if not yet complete.\n\t\t\t   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {\n\t\t\t    var text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\t\t    text1a = text1.substring(0, x);\n\t\t\t    text2a = text2.substring(0, y);\n\t\t\t    text1b = text1.substring(x);\n\t\t\t    text2b = text2.substring(y);\n\n\t\t\t    // Compute both diffs serially.\n\t\t\t    diffs = this.DiffMain(text1a, text2a, false, deadline);\n\t\t\t    diffsb = this.DiffMain(text1b, text2b, false, deadline);\n\t\t\t    return diffs.concat(diffsb);\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Reduce the number of edits by eliminating semantically trivial equalities.\n\t\t\t   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {\n\t\t\t    var changes = false;\n\t\t\t    var equalities = []; // Stack of indices where equalities are found.\n\t\t\t    var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t    /** @type {?string} */\n\t\t\t    var lastequality = null;\n\n\t\t\t    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\t    var pointer = 0; // Index of current position.\n\n\t\t\t    // Number of characters that changed prior to the equality.\n\t\t\t    var lengthInsertions1 = 0;\n\t\t\t    var lengthDeletions1 = 0;\n\n\t\t\t    // Number of characters that changed after the equality.\n\t\t\t    var lengthInsertions2 = 0;\n\t\t\t    var lengthDeletions2 = 0;\n\t\t\t    while (pointer < diffs.length) {\n\t\t\t      if (diffs[pointer][0] === DIFF_EQUAL) {\n\t\t\t        // Equality found.\n\t\t\t        equalities[equalitiesLength++] = pointer;\n\t\t\t        lengthInsertions1 = lengthInsertions2;\n\t\t\t        lengthDeletions1 = lengthDeletions2;\n\t\t\t        lengthInsertions2 = 0;\n\t\t\t        lengthDeletions2 = 0;\n\t\t\t        lastequality = diffs[pointer][1];\n\t\t\t      } else {\n\t\t\t        // An insertion or deletion.\n\t\t\t        if (diffs[pointer][0] === DIFF_INSERT) {\n\t\t\t          lengthInsertions2 += diffs[pointer][1].length;\n\t\t\t        } else {\n\t\t\t          lengthDeletions2 += diffs[pointer][1].length;\n\t\t\t        }\n\n\t\t\t        // Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t        // sides of it.\n\t\t\t        if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n\t\t\t          // Duplicate record.\n\t\t\t          diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n\t\t\t          // Change second copy to insert.\n\t\t\t          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\n\t\t\t          // Throw away the equality we just deleted.\n\t\t\t          equalitiesLength--;\n\n\t\t\t          // Throw away the previous equality (it needs to be reevaluated).\n\t\t\t          equalitiesLength--;\n\t\t\t          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\n\t\t\t          // Reset the counters.\n\t\t\t          lengthInsertions1 = 0;\n\t\t\t          lengthDeletions1 = 0;\n\t\t\t          lengthInsertions2 = 0;\n\t\t\t          lengthDeletions2 = 0;\n\t\t\t          lastequality = null;\n\t\t\t          changes = true;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      pointer++;\n\t\t\t    }\n\n\t\t\t    // Normalize the diff.\n\t\t\t    if (changes) {\n\t\t\t      this.diffCleanupMerge(diffs);\n\t\t\t    }\n\t\t\t    var deletion, insertion, overlapLength1, overlapLength2;\n\n\t\t\t    // Find any overlaps between deletions and insertions.\n\t\t\t    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t\t    //   -> <del>abc</del>xxx<ins>def</ins>\n\t\t\t    // e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t\t    //   -> <ins>def</ins>xxx<del>abc</del>\n\t\t\t    // Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\t\t    pointer = 1;\n\t\t\t    while (pointer < diffs.length) {\n\t\t\t      if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n\t\t\t        deletion = diffs[pointer - 1][1];\n\t\t\t        insertion = diffs[pointer][1];\n\t\t\t        overlapLength1 = this.diffCommonOverlap(deletion, insertion);\n\t\t\t        overlapLength2 = this.diffCommonOverlap(insertion, deletion);\n\t\t\t        if (overlapLength1 >= overlapLength2) {\n\t\t\t          if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n\t\t\t            // Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t            diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n\t\t\t            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n\t\t\t            diffs[pointer + 1][1] = insertion.substring(overlapLength1);\n\t\t\t            pointer++;\n\t\t\t          }\n\t\t\t        } else {\n\t\t\t          if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n\t\t\t            // Reverse overlap found.\n\t\t\t            // Insert an equality and swap and trim the surrounding edits.\n\t\t\t            diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n\t\t\t            diffs[pointer - 1][0] = DIFF_INSERT;\n\t\t\t            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n\t\t\t            diffs[pointer + 1][0] = DIFF_DELETE;\n\t\t\t            diffs[pointer + 1][1] = deletion.substring(overlapLength2);\n\t\t\t            pointer++;\n\t\t\t          }\n\t\t\t        }\n\t\t\t        pointer++;\n\t\t\t      }\n\t\t\t      pointer++;\n\t\t\t    }\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Determine if the suffix of one string is the prefix of another.\n\t\t\t   * @param {string} text1 First string.\n\t\t\t   * @param {string} text2 Second string.\n\t\t\t   * @return {number} The number of characters common to the end of the first\n\t\t\t   *     string and the start of the second string.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {\n\t\t\t    // Cache the text lengths to prevent multiple calls.\n\t\t\t    var text1Length = text1.length;\n\t\t\t    var text2Length = text2.length;\n\n\t\t\t    // Eliminate the null case.\n\t\t\t    if (text1Length === 0 || text2Length === 0) {\n\t\t\t      return 0;\n\t\t\t    }\n\n\t\t\t    // Truncate the longer string.\n\t\t\t    if (text1Length > text2Length) {\n\t\t\t      text1 = text1.substring(text1Length - text2Length);\n\t\t\t    } else if (text1Length < text2Length) {\n\t\t\t      text2 = text2.substring(0, text1Length);\n\t\t\t    }\n\t\t\t    var textLength = Math.min(text1Length, text2Length);\n\n\t\t\t    // Quick check for the worst case.\n\t\t\t    if (text1 === text2) {\n\t\t\t      return textLength;\n\t\t\t    }\n\n\t\t\t    // Start by looking for a single character match\n\t\t\t    // and increase length until no match is found.\n\t\t\t    // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\t\t    var best = 0;\n\t\t\t    var length = 1;\n\t\t\t    while (true) {\n\t\t\t      var pattern = text1.substring(textLength - length);\n\t\t\t      var found = text2.indexOf(pattern);\n\t\t\t      if (found === -1) {\n\t\t\t        return best;\n\t\t\t      }\n\t\t\t      length += found;\n\t\t\t      if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n\t\t\t        best = length;\n\t\t\t        length++;\n\t\t\t      }\n\t\t\t    }\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Split two texts into an array of strings.  Reduce the texts to a string of\n\t\t\t   * hashes where each Unicode character represents one line.\n\t\t\t   * @param {string} text1 First string.\n\t\t\t   * @param {string} text2 Second string.\n\t\t\t   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t\t\t   *     An object containing the encoded text1, the encoded text2 and\n\t\t\t   *     the array of unique strings.\n\t\t\t   *     The zeroth element of the array of unique strings is intentionally blank.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {\n\t\t\t    var lineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\t\t    var lineHash = {}; // E.g. lineHash['Hello\\n'] === 4\n\n\t\t\t    // '\\x00' is a valid character, but various debuggers don't like it.\n\t\t\t    // So we'll insert a junk entry to avoid generating a null character.\n\t\t\t    lineArray[0] = '';\n\n\t\t\t    /**\n\t\t\t     * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t\t     * hashes where each Unicode character represents one line.\n\t\t\t     * Modifies linearray and linehash through being a closure.\n\t\t\t     * @param {string} text String to encode.\n\t\t\t     * @return {string} Encoded string.\n\t\t\t     * @private\n\t\t\t     */\n\t\t\t    function diffLinesToCharsMunge(text) {\n\t\t\t      var chars = '';\n\n\t\t\t      // Walk the text, pulling out a substring for each line.\n\t\t\t      // text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t      // Modifying text would create many large strings to garbage collect.\n\t\t\t      var lineStart = 0;\n\t\t\t      var lineEnd = -1;\n\n\t\t\t      // Keeping our own length variable is faster than looking it up.\n\t\t\t      var lineArrayLength = lineArray.length;\n\t\t\t      while (lineEnd < text.length - 1) {\n\t\t\t        lineEnd = text.indexOf('\\n', lineStart);\n\t\t\t        if (lineEnd === -1) {\n\t\t\t          lineEnd = text.length - 1;\n\t\t\t        }\n\t\t\t        var line = text.substring(lineStart, lineEnd + 1);\n\t\t\t        lineStart = lineEnd + 1;\n\t\t\t        if (hasOwn.call(lineHash, line)) {\n\t\t\t          chars += String.fromCharCode(lineHash[line]);\n\t\t\t        } else {\n\t\t\t          chars += String.fromCharCode(lineArrayLength);\n\t\t\t          lineHash[line] = lineArrayLength;\n\t\t\t          lineArray[lineArrayLength++] = line;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return chars;\n\t\t\t    }\n\t\t\t    var chars1 = diffLinesToCharsMunge(text1);\n\t\t\t    var chars2 = diffLinesToCharsMunge(text2);\n\t\t\t    return {\n\t\t\t      chars1: chars1,\n\t\t\t      chars2: chars2,\n\t\t\t      lineArray: lineArray\n\t\t\t    };\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t\t\t   * text.\n\t\t\t   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t\t   * @param {!Array.<string>} lineArray Array of unique strings.\n\t\t\t   * @private\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {\n\t\t\t    for (var x = 0; x < diffs.length; x++) {\n\t\t\t      var chars = diffs[x][1];\n\t\t\t      var text = [];\n\t\t\t      for (var y = 0; y < chars.length; y++) {\n\t\t\t        text[y] = lineArray[chars.charCodeAt(y)];\n\t\t\t      }\n\t\t\t      diffs[x][1] = text.join('');\n\t\t\t    }\n\t\t\t  };\n\n\t\t\t  /**\n\t\t\t   * Reorder and merge like edit sections.  Merge equalities.\n\t\t\t   * Any edit section can move as long as it doesn't cross an equality.\n\t\t\t   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t\t\t   */\n\t\t\t  DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {\n\t\t\t    diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.\n\t\t\t    var pointer = 0;\n\t\t\t    var countDelete = 0;\n\t\t\t    var countInsert = 0;\n\t\t\t    var textDelete = '';\n\t\t\t    var textInsert = '';\n\t\t\t    while (pointer < diffs.length) {\n\t\t\t      switch (diffs[pointer][0]) {\n\t\t\t        case DIFF_INSERT:\n\t\t\t          countInsert++;\n\t\t\t          textInsert += diffs[pointer][1];\n\t\t\t          pointer++;\n\t\t\t          break;\n\t\t\t        case DIFF_DELETE:\n\t\t\t          countDelete++;\n\t\t\t          textDelete += diffs[pointer][1];\n\t\t\t          pointer++;\n\t\t\t          break;\n\t\t\t        case DIFF_EQUAL:\n\t\t\t          // Upon reaching an equality, check for prior redundancies.\n\t\t\t          if (countDelete + countInsert > 1) {\n\t\t\t            if (countDelete !== 0 && countInsert !== 0) {\n\t\t\t              // Factor out any common prefixes.\n\t\t\t              var commonlength = this.diffCommonPrefix(textInsert, textDelete);\n\t\t\t              if (commonlength !== 0) {\n\t\t\t                if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {\n\t\t\t                  diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n\t\t\t                } else {\n\t\t\t                  diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n\t\t\t                  pointer++;\n\t\t\t                }\n\t\t\t                textInsert = textInsert.substring(commonlength);\n\t\t\t                textDelete = textDelete.substring(commonlength);\n\t\t\t              }\n\n\t\t\t              // Factor out any common suffixies.\n\t\t\t              commonlength = this.diffCommonSuffix(textInsert, textDelete);\n\t\t\t              if (commonlength !== 0) {\n\t\t\t                diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n\t\t\t                textInsert = textInsert.substring(0, textInsert.length - commonlength);\n\t\t\t                textDelete = textDelete.substring(0, textDelete.length - commonlength);\n\t\t\t              }\n\t\t\t            }\n\n\t\t\t            // Delete the offending records and add the merged ones.\n\t\t\t            if (countDelete === 0) {\n\t\t\t              diffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);\n\t\t\t            } else if (countInsert === 0) {\n\t\t\t              diffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);\n\t\t\t            } else {\n\t\t\t              diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);\n\t\t\t            }\n\t\t\t            pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n\t\t\t          } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n\t\t\t            // Merge this equality with the previous one.\n\t\t\t            diffs[pointer - 1][1] += diffs[pointer][1];\n\t\t\t            diffs.splice(pointer, 1);\n\t\t\t          } else {\n\t\t\t            pointer++;\n\t\t\t          }\n\t\t\t          countInsert = 0;\n\t\t\t          countDelete = 0;\n\t\t\t          textDelete = '';\n\t\t\t          textInsert = '';\n\t\t\t          break;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    if (diffs[diffs.length - 1][1] === '') {\n\t\t\t      diffs.pop(); // Remove the dummy entry at the end.\n\t\t\t    }\n\n\t\t\t    // Second pass: look for single edits surrounded on both sides by equalities\n\t\t\t    // which can be shifted sideways to eliminate an equality.\n\t\t\t    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\t\t    var changes = false;\n\t\t\t    pointer = 1;\n\n\t\t\t    // Intentionally ignore the first and last element (don't need checking).\n\t\t\t    while (pointer < diffs.length - 1) {\n\t\t\t      if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n\t\t\t        var diffPointer = diffs[pointer][1];\n\t\t\t        var position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);\n\n\t\t\t        // This is a single edit surrounded by equalities.\n\t\t\t        if (position === diffs[pointer - 1][1]) {\n\t\t\t          // Shift the edit over the previous equality.\n\t\t\t          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n\t\t\t          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n\t\t\t          diffs.splice(pointer - 1, 1);\n\t\t\t          changes = true;\n\t\t\t        } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n\t\t\t          // Shift the edit over the next equality.\n\t\t\t          diffs[pointer - 1][1] += diffs[pointer + 1][1];\n\t\t\t          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n\t\t\t          diffs.splice(pointer + 1, 1);\n\t\t\t          changes = true;\n\t\t\t        }\n\t\t\t      }\n\t\t\t      pointer++;\n\t\t\t    }\n\n\t\t\t    // If shifts were made, the diff needs reordering and another shift sweep.\n\t\t\t    if (changes) {\n\t\t\t      this.diffCleanupMerge(diffs);\n\t\t\t    }\n\t\t\t  };\n\t\t\t  function diff(o, n) {\n\t\t\t    var diff, output, text;\n\t\t\t    diff = new DiffMatchPatch();\n\t\t\t    output = diff.DiffMain(o, n);\n\t\t\t    diff.diffCleanupEfficiency(output);\n\t\t\t    text = diff.diffPrettyHtml(output);\n\t\t\t    return text;\n\t\t\t  }\n\n\t\t\t  var QUnit = {};\n\n\t\t\t  // The \"currentModule\" object would ideally be defined using the createModule()\n\t\t\t  // function. Since it isn't, add the missing suiteReport property to it now that\n\t\t\t  // we have loaded all source code required to do so.\n\t\t\t  //\n\t\t\t  // TODO: Consider defining currentModule in core.js or module.js in its entirely\n\t\t\t  // rather than partly in config.js and partly here.\n\t\t\t  config.currentModule.suiteReport = runSuite;\n\t\t\t  config.pq = new ProcessingQueue(test);\n\t\t\t  var globalStartCalled = false;\n\t\t\t  var runStarted = false;\n\n\t\t\t  // Figure out if we're running the tests from a server or not\n\t\t\t  QUnit.isLocal = window$1 && window$1.location && window$1.location.protocol === 'file:';\n\n\t\t\t  // Expose the current QUnit version\n\t\t\t  QUnit.version = '2.24.1';\n\t\t\t  extend(QUnit, {\n\t\t\t    config: config,\n\t\t\t    diff: diff,\n\t\t\t    dump: dump,\n\t\t\t    equiv: equiv,\n\t\t\t    reporters: reporters,\n\t\t\t    hooks: hooks,\n\t\t\t    is: is,\n\t\t\t    objectType: objectType,\n\t\t\t    on: on,\n\t\t\t    onError: onWindowError,\n\t\t\t    onUncaughtException: onUncaughtException,\n\t\t\t    pushFailure: pushFailure,\n\t\t\t    assert: Assert.prototype,\n\t\t\t    module: module$1,\n\t\t\t    test: test,\n\t\t\t    // alias other test flavors for easy access\n\t\t\t    todo: test.todo,\n\t\t\t    skip: test.skip,\n\t\t\t    only: test.only,\n\t\t\t    start: function start(count) {\n\t\t\t      if (config.current) {\n\t\t\t        throw new Error('QUnit.start cannot be called inside a test context.');\n\t\t\t      }\n\t\t\t      var globalStartAlreadyCalled = globalStartCalled;\n\t\t\t      globalStartCalled = true;\n\t\t\t      if (runStarted) {\n\t\t\t        throw new Error('Called start() while test already started running');\n\t\t\t      }\n\t\t\t      if (globalStartAlreadyCalled || count > 1) {\n\t\t\t        throw new Error('Called start() outside of a test context too many times');\n\t\t\t      }\n\t\t\t      if (config.autostart) {\n\t\t\t        throw new Error('Called start() outside of a test context when ' + 'QUnit.config.autostart was true');\n\t\t\t      }\n\n\t\t\t      // Until we remove QUnit.load() in QUnit 3, we keep `pageLoaded`.\n\t\t\t      // It no longer serves any purpose other than to support old test runners\n\t\t\t      // that still call only QUnit.load(), or that call both it and QUnit.start().\n\t\t\t      if (!config.pageLoaded) {\n\t\t\t        // If the test runner used `autostart = false` and is calling QUnit.start()\n\t\t\t        // to tell is their resources are ready, but the browser isn't ready yet,\n\t\t\t        // then enable autostart now, and we'll let the tests really start after\n\t\t\t        // the browser's \"load\" event handler calls autostart().\n\t\t\t        config.autostart = true;\n\n\t\t\t        // If we're in Node or another non-browser environment, we start now as there\n\t\t\t        // won't be any \"load\" event. We return early either way since autostart\n\t\t\t        // is responsible for calling scheduleBegin (avoid \"beginning\" twice).\n\t\t\t        if (!document) {\n\t\t\t          QUnit.autostart();\n\t\t\t        }\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      scheduleBegin();\n\t\t\t    },\n\t\t\t    onUnhandledRejection: function onUnhandledRejection(reason) {\n\t\t\t      Logger.warn('QUnit.onUnhandledRejection is deprecated and will be removed in QUnit 3.0.' + ' Please use QUnit.onUncaughtException instead.');\n\t\t\t      onUncaughtException(reason);\n\t\t\t    },\n\t\t\t    extend: function extend$1() {\n\t\t\t      Logger.warn('QUnit.extend is deprecated and will be removed in QUnit 3.0.' + ' Please use Object.assign instead.');\n\n\t\t\t      // delegate to utility implementation, which does not warn and can be used elsewhere internally\n\t\t\t      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t        args[_key] = arguments[_key];\n\t\t\t      }\n\t\t\t      return extend.apply(this, args);\n\t\t\t    },\n\t\t\t    load: function load() {\n\t\t\t      Logger.warn('QUnit.load is deprecated and will be removed in QUnit 3.0.' + ' https://qunitjs.com/api/QUnit/load/');\n\t\t\t      QUnit.autostart();\n\t\t\t    },\n\t\t\t    /**\n\t\t\t     * @internal\n\t\t\t     */\n\t\t\t    autostart: function autostart() {\n\t\t\t      config.pageLoaded = true;\n\n\t\t\t      // Initialize the configuration options\n\t\t\t      // TODO: Move this to config.js in QUnit 3.\n\t\t\t      extend(config, {\n\t\t\t        started: 0,\n\t\t\t        updateRate: 1000,\n\t\t\t        autostart: true,\n\t\t\t        filter: ''\n\t\t\t      }, true);\n\t\t\t      if (!runStarted) {\n\t\t\t        config.blocking = false;\n\t\t\t        if (config.autostart) {\n\t\t\t          scheduleBegin();\n\t\t\t        }\n\t\t\t      }\n\t\t\t    },\n\t\t\t    stack: function stack(offset) {\n\t\t\t      offset = (offset || 0) + 2;\n\t\t\t      // Support Safari: Use temp variable to avoid TCO for consistent cross-browser result\n\t\t\t      // https://bugs.webkit.org/show_bug.cgi?id=276187\n\t\t\t      var source = sourceFromStacktrace(offset);\n\t\t\t      return source;\n\t\t\t    }\n\t\t\t  });\n\t\t\t  registerLoggingCallbacks(QUnit);\n\t\t\t  function scheduleBegin() {\n\t\t\t    runStarted = true;\n\n\t\t\t    // Add a slight delay to allow definition of more modules and tests.\n\t\t\t    if (setTimeout$1) {\n\t\t\t      setTimeout$1(function () {\n\t\t\t        begin();\n\t\t\t      });\n\t\t\t    } else {\n\t\t\t      begin();\n\t\t\t    }\n\t\t\t  }\n\t\t\t  function unblockAndAdvanceQueue() {\n\t\t\t    config.blocking = false;\n\t\t\t    config.pq.advance();\n\t\t\t  }\n\t\t\t  function begin() {\n\t\t\t    if (config.started) {\n\t\t\t      unblockAndAdvanceQueue();\n\t\t\t      return;\n\t\t\t    }\n\n\t\t\t    // QUnit.config.reporters is considered writable between qunit.js and QUnit.start().\n\t\t\t    // Now that QUnit.start() has been called, it is time to decide which built-in reporters\n\t\t\t    // to load.\n\t\t\t    if (config.reporters.console) {\n\t\t\t      reporters.console.init(QUnit);\n\t\t\t    }\n\t\t\t    if (config.reporters.tap) {\n\t\t\t      reporters.tap.init(QUnit);\n\t\t\t    }\n\n\t\t\t    // The test run hasn't officially begun yet\n\t\t\t    // Record the time of the test run's beginning\n\t\t\t    config.started = performance.now();\n\n\t\t\t    // Delete the loose unnamed module if unused.\n\t\t\t    if (config.modules[0].name === '' && config.modules[0].tests.length === 0) {\n\t\t\t      config.modules.shift();\n\t\t\t    }\n\t\t\t    var modulesLog = [];\n\t\t\t    for (var i = 0; i < config.modules.length; i++) {\n\t\t\t      // Don't expose the unnamed global test module to plugins.\n\t\t\t      if (config.modules[i].name !== '') {\n\t\t\t        modulesLog.push({\n\t\t\t          name: config.modules[i].name,\n\t\t\t          moduleId: config.modules[i].moduleId,\n\t\t\t          // Added in QUnit 1.16.0 for internal use by html-reporter,\n\t\t\t          // but no longer used since QUnit 2.7.0.\n\t\t\t          // @deprecated Kept unofficially to be removed in QUnit 3.0.\n\t\t\t          tests: config.modules[i].tests\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }\n\n\t\t\t    // The test run is officially beginning now\n\t\t\t    emit('runStart', runSuite.start(true));\n\t\t\t    runLoggingCallbacks('begin', {\n\t\t\t      totalTests: Test.count,\n\t\t\t      modules: modulesLog\n\t\t\t    }).then(unblockAndAdvanceQueue);\n\t\t\t  }\n\t\t\t  exportQUnit(QUnit);\n\n\t\t\t  (function () {\n\t\t\t    if (!window$1 || !document) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    var config = QUnit.config;\n\t\t\t    var hasOwn = Object.prototype.hasOwnProperty;\n\n\t\t\t    // Stores fixture HTML for resetting later\n\t\t\t    function storeFixture() {\n\t\t\t      // Avoid overwriting user-defined values\n\t\t\t      // TODO: Change to negative null/undefined check once declared in /src/config.js\n\t\t\t      if (hasOwn.call(config, 'fixture')) {\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      var fixture = document.getElementById('qunit-fixture');\n\t\t\t      if (fixture) {\n\t\t\t        config.fixture = fixture.cloneNode(true);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    QUnit.begin(storeFixture);\n\n\t\t\t    // Resets the fixture DOM element if available.\n\t\t\t    function resetFixture() {\n\t\t\t      if (config.fixture == null) {\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      var fixture = document.getElementById('qunit-fixture');\n\t\t\t      var resetFixtureType = _typeof(config.fixture);\n\t\t\t      if (resetFixtureType === 'string') {\n\t\t\t        // support user defined values for `config.fixture`\n\t\t\t        var newFixture = document.createElement('div');\n\t\t\t        newFixture.setAttribute('id', 'qunit-fixture');\n\t\t\t        newFixture.innerHTML = config.fixture;\n\t\t\t        fixture.parentNode.replaceChild(newFixture, fixture);\n\t\t\t      } else {\n\t\t\t        var clonedFixture = config.fixture.cloneNode(true);\n\t\t\t        fixture.parentNode.replaceChild(clonedFixture, fixture);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    QUnit.testStart(resetFixture);\n\t\t\t  })();\n\n\t\t\t  (function () {\n\t\t\t    // Only interact with URLs via window.location\n\t\t\t    var location = typeof window$1 !== 'undefined' && window$1.location;\n\t\t\t    if (!location) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    var urlParams = getUrlParams();\n\n\t\t\t    // TODO: Move to /src/core/ in QUnit 3\n\t\t\t    // TODO: Document this as public API (read-only)\n\t\t\t    QUnit.urlParams = urlParams;\n\n\t\t\t    // TODO: Move to /src/core/config.js in QUnit 3,\n\t\t\t    // in accordance with /docs/api/config.index.md#order\n\t\t\t    QUnit.config.filter = urlParams.filter;\n\t\t\t    // NOTE: Based on readFlatPreconfigNumber from QUnit 3.\n\t\t\t    if (/^[0-9]+$/.test(urlParams.maxDepth)) {\n\t\t\t      QUnit.config.maxDepth = QUnit.dump.maxDepth = +urlParams.maxDepth;\n\t\t\t    }\n\t\t\t    QUnit.config.module = urlParams.module;\n\t\t\t    QUnit.config.moduleId = [].concat(urlParams.moduleId || []);\n\t\t\t    QUnit.config.testId = [].concat(urlParams.testId || []);\n\n\t\t\t    // Test order randomization\n\t\t\t    // Generate a random seed if `?seed` is specified without a value (boolean true),\n\t\t\t    // or when set to the string \"true\".\n\t\t\t    if (urlParams.seed === 'true' || urlParams.seed === true) {\n\t\t\t      // NOTE: This duplicates logic from /src/core/config.js. Consolidated in QUnit 3.\n\t\t\t      QUnit.config.seed = (Math.random().toString(36) + '0000000000').slice(2, 12);\n\t\t\t    } else if (urlParams.seed) {\n\t\t\t      QUnit.config.seed = urlParams.seed;\n\t\t\t    }\n\n\t\t\t    // Add URL-parameter-mapped config values with UI form rendering data\n\t\t\t    QUnit.config.urlConfig.push({\n\t\t\t      id: 'hidepassed',\n\t\t\t      label: 'Hide passed tests',\n\t\t\t      tooltip: 'Only show tests and assertions that fail. Stored as query-strings.'\n\t\t\t    }, {\n\t\t\t      id: 'noglobals',\n\t\t\t      label: 'Check for Globals',\n\t\t\t      tooltip: 'Enabling this will test if any test introduces new properties on the ' + 'global object (`window` in Browsers). Stored as query-strings.'\n\t\t\t    }, {\n\t\t\t      id: 'notrycatch',\n\t\t\t      label: 'No try-catch',\n\t\t\t      tooltip: 'Enabling this will run tests outside of a try-catch block. Makes debugging ' + 'exceptions in IE reasonable. Stored as query-strings.'\n\t\t\t    });\n\t\t\t    QUnit.begin(function () {\n\t\t\t      var urlConfig = QUnit.config.urlConfig;\n\t\t\t      for (var i = 0; i < urlConfig.length; i++) {\n\t\t\t        // Options can be either strings or objects with nonempty \"id\" properties\n\t\t\t        var option = QUnit.config.urlConfig[i];\n\t\t\t        if (typeof option !== 'string') {\n\t\t\t          option = option.id;\n\t\t\t        }\n\t\t\t        if (QUnit.config[option] === undefined) {\n\t\t\t          QUnit.config[option] = urlParams[option];\n\t\t\t        }\n\t\t\t      }\n\t\t\t    });\n\t\t\t    function getUrlParams() {\n\t\t\t      var urlParams = Object.create(null);\n\t\t\t      var params = location.search.slice(1).split('&');\n\t\t\t      var length = params.length;\n\t\t\t      for (var i = 0; i < length; i++) {\n\t\t\t        if (params[i]) {\n\t\t\t          var param = params[i].split('=');\n\t\t\t          var name = decodeQueryParam(param[0]);\n\n\t\t\t          // Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\t          var value = param.length === 1 || decodeQueryParam(param.slice(1).join('='));\n\t\t\t          if (name in urlParams) {\n\t\t\t            urlParams[name] = [].concat(urlParams[name], value);\n\t\t\t          } else {\n\t\t\t            urlParams[name] = value;\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return urlParams;\n\t\t\t    }\n\t\t\t    function decodeQueryParam(param) {\n\t\t\t      return decodeURIComponent(param.replace(/\\+/g, '%20'));\n\t\t\t    }\n\t\t\t  })();\n\n\t\t\t  var fuzzysort$1 = {exports: {}};\n\n\t\t\t  (function (module) {\n\t\t\t    (function (root, UMD) {\n\t\t\t      if (module.exports) module.exports = UMD();else root.fuzzysort = UMD();\n\t\t\t    })(commonjsGlobal$1, function UMD() {\n\t\t\t      function fuzzysortNew(instanceOptions) {\n\t\t\t        var fuzzysort = {\n\t\t\t          single: function single(search, target, options) {\n\t\t\t            if (search == 'farzher') return {\n\t\t\t              target: \"farzher was here (^-^*)/\",\n\t\t\t              score: 0,\n\t\t\t              indexes: [0, 1, 2, 3, 4, 5, 6]\n\t\t\t            };\n\t\t\t            if (!search) return null;\n\t\t\t            if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);\n\t\t\t            if (!target) return null;\n\t\t\t            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n\t\t\t            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n\t\t\t            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n\t\t\t            return algorithm(search, target, search[0]);\n\t\t\t          },\n\t\t\t          go: function go(search, targets, options) {\n\t\t\t            if (search == 'farzher') return [{\n\t\t\t              target: \"farzher was here (^-^*)/\",\n\t\t\t              score: 0,\n\t\t\t              indexes: [0, 1, 2, 3, 4, 5, 6],\n\t\t\t              obj: targets ? targets[0] : null\n\t\t\t            }];\n\t\t\t            if (!search) return noResults;\n\t\t\t            search = fuzzysort.prepareSearch(search);\n\t\t\t            var searchLowerCode = search[0];\n\t\t\t            var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n\t\t\t            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n\t\t\t            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n\t\t\t            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n\t\t\t            var resultsLen = 0;\n\t\t\t            var limitedCount = 0;\n\t\t\t            var targetsLen = targets.length;\n\n\t\t\t            // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n\t\t\t            // options.keys\n\t\t\t            if (options && options.keys) {\n\t\t\t              var scoreFn = options.scoreFn || defaultScoreFn;\n\t\t\t              var keys = options.keys;\n\t\t\t              var keysLen = keys.length;\n\t\t\t              for (var i = targetsLen - 1; i >= 0; --i) {\n\t\t\t                var obj = targets[i];\n\t\t\t                var objResults = new Array(keysLen);\n\t\t\t                for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n\t\t\t                  var key = keys[keyI];\n\t\t\t                  var target = getValue(obj, key);\n\t\t\t                  if (!target) {\n\t\t\t                    objResults[keyI] = null;\n\t\t\t                    continue;\n\t\t\t                  }\n\t\t\t                  if (!isObj(target)) target = fuzzysort.getPrepared(target);\n\t\t\t                  objResults[keyI] = algorithm(search, target, searchLowerCode);\n\t\t\t                }\n\t\t\t                objResults.obj = obj; // before scoreFn so scoreFn can use it\n\t\t\t                var score = scoreFn(objResults);\n\t\t\t                if (score === null) continue;\n\t\t\t                if (score < threshold) continue;\n\t\t\t                objResults.score = score;\n\t\t\t                if (resultsLen < limit) {\n\t\t\t                  q.add(objResults);\n\t\t\t                  ++resultsLen;\n\t\t\t                } else {\n\t\t\t                  ++limitedCount;\n\t\t\t                  if (score > q.peek().score) q.replaceTop(objResults);\n\t\t\t                }\n\t\t\t              }\n\n\t\t\t              // options.key\n\t\t\t            } else if (options && options.key) {\n\t\t\t              var key = options.key;\n\t\t\t              for (var i = targetsLen - 1; i >= 0; --i) {\n\t\t\t                var obj = targets[i];\n\t\t\t                var target = getValue(obj, key);\n\t\t\t                if (!target) continue;\n\t\t\t                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n\t\t\t                var result = algorithm(search, target, searchLowerCode);\n\t\t\t                if (result === null) continue;\n\t\t\t                if (result.score < threshold) continue;\n\n\t\t\t                // have to clone result so duplicate targets from different obj can each reference the correct obj\n\t\t\t                result = {\n\t\t\t                  target: result.target,\n\t\t\t                  _targetLowerCodes: null,\n\t\t\t                  _nextBeginningIndexes: null,\n\t\t\t                  score: result.score,\n\t\t\t                  indexes: result.indexes,\n\t\t\t                  obj: obj\n\t\t\t                }; // hidden\n\n\t\t\t                if (resultsLen < limit) {\n\t\t\t                  q.add(result);\n\t\t\t                  ++resultsLen;\n\t\t\t                } else {\n\t\t\t                  ++limitedCount;\n\t\t\t                  if (result.score > q.peek().score) q.replaceTop(result);\n\t\t\t                }\n\t\t\t              }\n\n\t\t\t              // no keys\n\t\t\t            } else {\n\t\t\t              for (var i = targetsLen - 1; i >= 0; --i) {\n\t\t\t                var target = targets[i];\n\t\t\t                if (!target) continue;\n\t\t\t                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n\t\t\t                var result = algorithm(search, target, searchLowerCode);\n\t\t\t                if (result === null) continue;\n\t\t\t                if (result.score < threshold) continue;\n\t\t\t                if (resultsLen < limit) {\n\t\t\t                  q.add(result);\n\t\t\t                  ++resultsLen;\n\t\t\t                } else {\n\t\t\t                  ++limitedCount;\n\t\t\t                  if (result.score > q.peek().score) q.replaceTop(result);\n\t\t\t                }\n\t\t\t              }\n\t\t\t            }\n\t\t\t            if (resultsLen === 0) return noResults;\n\t\t\t            var results = new Array(resultsLen);\n\t\t\t            for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();\n\t\t\t            results.total = resultsLen + limitedCount;\n\t\t\t            return results;\n\t\t\t          },\n\t\t\t          goAsync: function goAsync(search, targets, options) {\n\t\t\t            var canceled = false;\n\t\t\t            var p = new Promise(function (resolve, reject) {\n\t\t\t              if (search == 'farzher') return resolve([{\n\t\t\t                target: \"farzher was here (^-^*)/\",\n\t\t\t                score: 0,\n\t\t\t                indexes: [0, 1, 2, 3, 4, 5, 6],\n\t\t\t                obj: targets ? targets[0] : null\n\t\t\t              }]);\n\t\t\t              if (!search) return resolve(noResults);\n\t\t\t              search = fuzzysort.prepareSearch(search);\n\t\t\t              var searchLowerCode = search[0];\n\t\t\t              var q = fastpriorityqueue();\n\t\t\t              var iCurrent = targets.length - 1;\n\t\t\t              var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n\t\t\t              var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n\t\t\t              var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n\t\t\t              var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n\t\t\t              var resultsLen = 0;\n\t\t\t              var limitedCount = 0;\n\t\t\t              function step() {\n\t\t\t                if (canceled) return reject('canceled');\n\t\t\t                var startMs = Date.now();\n\n\t\t\t                // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n\t\t\t                // options.keys\n\t\t\t                if (options && options.keys) {\n\t\t\t                  var scoreFn = options.scoreFn || defaultScoreFn;\n\t\t\t                  var keys = options.keys;\n\t\t\t                  var keysLen = keys.length;\n\t\t\t                  for (; iCurrent >= 0; --iCurrent) {\n\t\t\t                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n\t\t\t                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n\t\t\t                        isNode ? setImmediate(step) : setTimeout(step);\n\t\t\t                        return;\n\t\t\t                      }\n\t\t\t                    }\n\t\t\t                    var obj = targets[iCurrent];\n\t\t\t                    var objResults = new Array(keysLen);\n\t\t\t                    for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n\t\t\t                      var key = keys[keyI];\n\t\t\t                      var target = getValue(obj, key);\n\t\t\t                      if (!target) {\n\t\t\t                        objResults[keyI] = null;\n\t\t\t                        continue;\n\t\t\t                      }\n\t\t\t                      if (!isObj(target)) target = fuzzysort.getPrepared(target);\n\t\t\t                      objResults[keyI] = algorithm(search, target, searchLowerCode);\n\t\t\t                    }\n\t\t\t                    objResults.obj = obj; // before scoreFn so scoreFn can use it\n\t\t\t                    var score = scoreFn(objResults);\n\t\t\t                    if (score === null) continue;\n\t\t\t                    if (score < threshold) continue;\n\t\t\t                    objResults.score = score;\n\t\t\t                    if (resultsLen < limit) {\n\t\t\t                      q.add(objResults);\n\t\t\t                      ++resultsLen;\n\t\t\t                    } else {\n\t\t\t                      ++limitedCount;\n\t\t\t                      if (score > q.peek().score) q.replaceTop(objResults);\n\t\t\t                    }\n\t\t\t                  }\n\n\t\t\t                  // options.key\n\t\t\t                } else if (options && options.key) {\n\t\t\t                  var key = options.key;\n\t\t\t                  for (; iCurrent >= 0; --iCurrent) {\n\t\t\t                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n\t\t\t                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n\t\t\t                        isNode ? setImmediate(step) : setTimeout(step);\n\t\t\t                        return;\n\t\t\t                      }\n\t\t\t                    }\n\t\t\t                    var obj = targets[iCurrent];\n\t\t\t                    var target = getValue(obj, key);\n\t\t\t                    if (!target) continue;\n\t\t\t                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n\t\t\t                    var result = algorithm(search, target, searchLowerCode);\n\t\t\t                    if (result === null) continue;\n\t\t\t                    if (result.score < threshold) continue;\n\n\t\t\t                    // have to clone result so duplicate targets from different obj can each reference the correct obj\n\t\t\t                    result = {\n\t\t\t                      target: result.target,\n\t\t\t                      _targetLowerCodes: null,\n\t\t\t                      _nextBeginningIndexes: null,\n\t\t\t                      score: result.score,\n\t\t\t                      indexes: result.indexes,\n\t\t\t                      obj: obj\n\t\t\t                    }; // hidden\n\n\t\t\t                    if (resultsLen < limit) {\n\t\t\t                      q.add(result);\n\t\t\t                      ++resultsLen;\n\t\t\t                    } else {\n\t\t\t                      ++limitedCount;\n\t\t\t                      if (result.score > q.peek().score) q.replaceTop(result);\n\t\t\t                    }\n\t\t\t                  }\n\n\t\t\t                  // no keys\n\t\t\t                } else {\n\t\t\t                  for (; iCurrent >= 0; --iCurrent) {\n\t\t\t                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n\t\t\t                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n\t\t\t                        isNode ? setImmediate(step) : setTimeout(step);\n\t\t\t                        return;\n\t\t\t                      }\n\t\t\t                    }\n\t\t\t                    var target = targets[iCurrent];\n\t\t\t                    if (!target) continue;\n\t\t\t                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n\t\t\t                    var result = algorithm(search, target, searchLowerCode);\n\t\t\t                    if (result === null) continue;\n\t\t\t                    if (result.score < threshold) continue;\n\t\t\t                    if (resultsLen < limit) {\n\t\t\t                      q.add(result);\n\t\t\t                      ++resultsLen;\n\t\t\t                    } else {\n\t\t\t                      ++limitedCount;\n\t\t\t                      if (result.score > q.peek().score) q.replaceTop(result);\n\t\t\t                    }\n\t\t\t                  }\n\t\t\t                }\n\t\t\t                if (resultsLen === 0) return resolve(noResults);\n\t\t\t                var results = new Array(resultsLen);\n\t\t\t                for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();\n\t\t\t                results.total = resultsLen + limitedCount;\n\t\t\t                resolve(results);\n\t\t\t              }\n\t\t\t              isNode ? setImmediate(step) : step(); //setTimeout here is too slow\n\t\t\t            });\n\t\t\t            p.cancel = function () {\n\t\t\t              canceled = true;\n\t\t\t            };\n\t\t\t            return p;\n\t\t\t          },\n\t\t\t          highlight: function highlight(result, hOpen, hClose) {\n\t\t\t            if (typeof hOpen == 'function') return fuzzysort.highlightCallback(result, hOpen);\n\t\t\t            if (result === null) return null;\n\t\t\t            if (hOpen === undefined) hOpen = '<b>';\n\t\t\t            if (hClose === undefined) hClose = '</b>';\n\t\t\t            var highlighted = '';\n\t\t\t            var matchesIndex = 0;\n\t\t\t            var opened = false;\n\t\t\t            var target = result.target;\n\t\t\t            var targetLen = target.length;\n\t\t\t            var matchesBest = result.indexes;\n\t\t\t            for (var i = 0; i < targetLen; ++i) {\n\t\t\t              var char = target[i];\n\t\t\t              if (matchesBest[matchesIndex] === i) {\n\t\t\t                ++matchesIndex;\n\t\t\t                if (!opened) {\n\t\t\t                  opened = true;\n\t\t\t                  highlighted += hOpen;\n\t\t\t                }\n\t\t\t                if (matchesIndex === matchesBest.length) {\n\t\t\t                  highlighted += char + hClose + target.substr(i + 1);\n\t\t\t                  break;\n\t\t\t                }\n\t\t\t              } else {\n\t\t\t                if (opened) {\n\t\t\t                  opened = false;\n\t\t\t                  highlighted += hClose;\n\t\t\t                }\n\t\t\t              }\n\t\t\t              highlighted += char;\n\t\t\t            }\n\t\t\t            return highlighted;\n\t\t\t          },\n\t\t\t          highlightCallback: function highlightCallback(result, cb) {\n\t\t\t            if (result === null) return null;\n\t\t\t            var target = result.target;\n\t\t\t            var targetLen = target.length;\n\t\t\t            var indexes = result.indexes;\n\t\t\t            var highlighted = '';\n\t\t\t            var matchI = 0;\n\t\t\t            var indexesI = 0;\n\t\t\t            var opened = false;\n\t\t\t            var result = [];\n\t\t\t            for (var i = 0; i < targetLen; ++i) {\n\t\t\t              var char = target[i];\n\t\t\t              if (indexes[indexesI] === i) {\n\t\t\t                ++indexesI;\n\t\t\t                if (!opened) {\n\t\t\t                  opened = true;\n\t\t\t                  result.push(highlighted);\n\t\t\t                  highlighted = '';\n\t\t\t                }\n\t\t\t                if (indexesI === indexes.length) {\n\t\t\t                  highlighted += char;\n\t\t\t                  result.push(cb(highlighted, matchI++));\n\t\t\t                  highlighted = '';\n\t\t\t                  result.push(target.substr(i + 1));\n\t\t\t                  break;\n\t\t\t                }\n\t\t\t              } else {\n\t\t\t                if (opened) {\n\t\t\t                  opened = false;\n\t\t\t                  result.push(cb(highlighted, matchI++));\n\t\t\t                  highlighted = '';\n\t\t\t                }\n\t\t\t              }\n\t\t\t              highlighted += char;\n\t\t\t            }\n\t\t\t            return result;\n\t\t\t          },\n\t\t\t          prepare: function prepare(target) {\n\t\t\t            if (!target) return {\n\t\t\t              target: '',\n\t\t\t              _targetLowerCodes: [0 /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],\n\t\t\t              _nextBeginningIndexes: null,\n\t\t\t              score: null,\n\t\t\t              indexes: null,\n\t\t\t              obj: null\n\t\t\t            }; // hidden\n\t\t\t            return {\n\t\t\t              target: target,\n\t\t\t              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n\t\t\t              _nextBeginningIndexes: null,\n\t\t\t              score: null,\n\t\t\t              indexes: null,\n\t\t\t              obj: null\n\t\t\t            }; // hidden\n\t\t\t          },\n\t\t\t          prepareSlow: function prepareSlow(target) {\n\t\t\t            if (!target) return {\n\t\t\t              target: '',\n\t\t\t              _targetLowerCodes: [0 /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],\n\t\t\t              _nextBeginningIndexes: null,\n\t\t\t              score: null,\n\t\t\t              indexes: null,\n\t\t\t              obj: null\n\t\t\t            }; // hidden\n\t\t\t            return {\n\t\t\t              target: target,\n\t\t\t              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n\t\t\t              _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),\n\t\t\t              score: null,\n\t\t\t              indexes: null,\n\t\t\t              obj: null\n\t\t\t            }; // hidden\n\t\t\t          },\n\t\t\t          prepareSearch: function prepareSearch(search) {\n\t\t\t            if (!search) search = '';\n\t\t\t            return fuzzysort.prepareLowerCodes(search);\n\t\t\t          },\n\t\t\t          // Below this point is only internal code\n\t\t\t          // Below this point is only internal code\n\t\t\t          // Below this point is only internal code\n\t\t\t          // Below this point is only internal code\n\n\t\t\t          getPrepared: function getPrepared(target) {\n\t\t\t            if (target.length > 999) return fuzzysort.prepare(target); // don't cache huge targets\n\t\t\t            var targetPrepared = preparedCache.get(target);\n\t\t\t            if (targetPrepared !== undefined) return targetPrepared;\n\t\t\t            targetPrepared = fuzzysort.prepare(target);\n\t\t\t            preparedCache.set(target, targetPrepared);\n\t\t\t            return targetPrepared;\n\t\t\t          },\n\t\t\t          getPreparedSearch: function getPreparedSearch(search) {\n\t\t\t            if (search.length > 999) return fuzzysort.prepareSearch(search); // don't cache huge searches\n\t\t\t            var searchPrepared = preparedSearchCache.get(search);\n\t\t\t            if (searchPrepared !== undefined) return searchPrepared;\n\t\t\t            searchPrepared = fuzzysort.prepareSearch(search);\n\t\t\t            preparedSearchCache.set(search, searchPrepared);\n\t\t\t            return searchPrepared;\n\t\t\t          },\n\t\t\t          algorithm: function algorithm(searchLowerCodes, prepared, searchLowerCode) {\n\t\t\t            var targetLowerCodes = prepared._targetLowerCodes;\n\t\t\t            var searchLen = searchLowerCodes.length;\n\t\t\t            var targetLen = targetLowerCodes.length;\n\t\t\t            var searchI = 0; // where we at\n\t\t\t            var targetI = 0; // where you at\n\t\t\t            var typoSimpleI = 0;\n\t\t\t            var matchesSimpleLen = 0;\n\n\t\t\t            // very basic fuzzy match; to remove non-matching targets ASAP!\n\t\t\t            // walk through target. find sequential matches.\n\t\t\t            // if all chars aren't found then exit\n\t\t\t            for (;;) {\n\t\t\t              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\t\t\t              if (isMatch) {\n\t\t\t                matchesSimple[matchesSimpleLen++] = targetI;\n\t\t\t                ++searchI;\n\t\t\t                if (searchI === searchLen) break;\n\t\t\t                searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];\n\t\t\t              }\n\t\t\t              ++targetI;\n\t\t\t              if (targetI >= targetLen) {\n\t\t\t                // Failed to find searchI\n\t\t\t                // Check for typo or exit\n\t\t\t                // we go as far as possible before trying to transpose\n\t\t\t                // then we transpose backwards until we reach the beginning\n\t\t\t                for (;;) {\n\t\t\t                  if (searchI <= 1) return null; // not allowed to transpose first char\n\t\t\t                  if (typoSimpleI === 0) {\n\t\t\t                    // we haven't tried to transpose yet\n\t\t\t                    --searchI;\n\t\t\t                    var searchLowerCodeNew = searchLowerCodes[searchI];\n\t\t\t                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n\t\t\t                    typoSimpleI = searchI;\n\t\t\t                  } else {\n\t\t\t                    if (typoSimpleI === 1) return null; // reached the end of the line for transposing\n\t\t\t                    --typoSimpleI;\n\t\t\t                    searchI = typoSimpleI;\n\t\t\t                    searchLowerCode = searchLowerCodes[searchI + 1];\n\t\t\t                    var searchLowerCodeNew = searchLowerCodes[searchI];\n\t\t\t                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n\t\t\t                  }\n\t\t\t                  matchesSimpleLen = searchI;\n\t\t\t                  targetI = matchesSimple[matchesSimpleLen - 1] + 1;\n\t\t\t                  break;\n\t\t\t                }\n\t\t\t              }\n\t\t\t            }\n\t\t\t            var searchI = 0;\n\t\t\t            var typoStrictI = 0;\n\t\t\t            var successStrict = false;\n\t\t\t            var matchesStrictLen = 0;\n\t\t\t            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n\t\t\t            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n\t\t\t            var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n\n\t\t\t            // Our target string successfully matched all characters in sequence!\n\t\t\t            // Let's try a more advanced and strict test to improve the score\n\t\t\t            // only count it as a match if it's consecutive or a beginning character!\n\t\t\t            if (targetI !== targetLen) for (;;) {\n\t\t\t              if (targetI >= targetLen) {\n\t\t\t                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n\t\t\t                if (searchI <= 0) {\n\t\t\t                  // We failed to push chars forward for a better match\n\t\t\t                  // transpose, starting from the beginning\n\t\t\t                  ++typoStrictI;\n\t\t\t                  if (typoStrictI > searchLen - 2) break;\n\t\t\t                  if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn't make sense to transpose a repeat char\n\t\t\t                  targetI = firstPossibleI;\n\t\t\t                  continue;\n\t\t\t                }\n\t\t\t                --searchI;\n\t\t\t                var lastMatch = matchesStrict[--matchesStrictLen];\n\t\t\t                targetI = nextBeginningIndexes[lastMatch];\n\t\t\t              } else {\n\t\t\t                var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];\n\t\t\t                if (isMatch) {\n\t\t\t                  matchesStrict[matchesStrictLen++] = targetI;\n\t\t\t                  ++searchI;\n\t\t\t                  if (searchI === searchLen) {\n\t\t\t                    successStrict = true;\n\t\t\t                    break;\n\t\t\t                  }\n\t\t\t                  ++targetI;\n\t\t\t                } else {\n\t\t\t                  targetI = nextBeginningIndexes[targetI];\n\t\t\t                }\n\t\t\t              }\n\t\t\t            }\n\t\t\t            {\n\t\t\t              // tally up the score & keep track of matches for highlighting later\n\t\t\t              if (successStrict) {\n\t\t\t                var matchesBest = matchesStrict;\n\t\t\t                var matchesBestLen = matchesStrictLen;\n\t\t\t              } else {\n\t\t\t                var matchesBest = matchesSimple;\n\t\t\t                var matchesBestLen = matchesSimpleLen;\n\t\t\t              }\n\t\t\t              var score = 0;\n\t\t\t              var lastTargetI = -1;\n\t\t\t              for (var i = 0; i < searchLen; ++i) {\n\t\t\t                var targetI = matchesBest[i];\n\t\t\t                // score only goes down if they're not consecutive\n\t\t\t                if (lastTargetI !== targetI - 1) score -= targetI;\n\t\t\t                lastTargetI = targetI;\n\t\t\t              }\n\t\t\t              if (!successStrict) {\n\t\t\t                score *= 1000;\n\t\t\t                if (typoSimpleI !== 0) score += -20; /*typoPenalty*/\n\t\t\t              } else {\n\t\t\t                if (typoStrictI !== 0) score += -20; /*typoPenalty*/\n\t\t\t              }\n\t\t\t              score -= targetLen - searchLen;\n\t\t\t              prepared.score = score;\n\t\t\t              prepared.indexes = new Array(matchesBestLen);\n\t\t\t              for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];\n\t\t\t              return prepared;\n\t\t\t            }\n\t\t\t          },\n\t\t\t          algorithmNoTypo: function algorithmNoTypo(searchLowerCodes, prepared, searchLowerCode) {\n\t\t\t            var targetLowerCodes = prepared._targetLowerCodes;\n\t\t\t            var searchLen = searchLowerCodes.length;\n\t\t\t            var targetLen = targetLowerCodes.length;\n\t\t\t            var searchI = 0; // where we at\n\t\t\t            var targetI = 0; // where you at\n\t\t\t            var matchesSimpleLen = 0;\n\n\t\t\t            // very basic fuzzy match; to remove non-matching targets ASAP!\n\t\t\t            // walk through target. find sequential matches.\n\t\t\t            // if all chars aren't found then exit\n\t\t\t            for (;;) {\n\t\t\t              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\t\t\t              if (isMatch) {\n\t\t\t                matchesSimple[matchesSimpleLen++] = targetI;\n\t\t\t                ++searchI;\n\t\t\t                if (searchI === searchLen) break;\n\t\t\t                searchLowerCode = searchLowerCodes[searchI];\n\t\t\t              }\n\t\t\t              ++targetI;\n\t\t\t              if (targetI >= targetLen) return null; // Failed to find searchI\n\t\t\t            }\n\t\t\t            var searchI = 0;\n\t\t\t            var successStrict = false;\n\t\t\t            var matchesStrictLen = 0;\n\t\t\t            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n\t\t\t            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n\t\t\t            targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n\n\t\t\t            // Our target string successfully matched all characters in sequence!\n\t\t\t            // Let's try a more advanced and strict test to improve the score\n\t\t\t            // only count it as a match if it's consecutive or a beginning character!\n\t\t\t            if (targetI !== targetLen) for (;;) {\n\t\t\t              if (targetI >= targetLen) {\n\t\t\t                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n\t\t\t                if (searchI <= 0) break; // We failed to push chars forward for a better match\n\n\t\t\t                --searchI;\n\t\t\t                var lastMatch = matchesStrict[--matchesStrictLen];\n\t\t\t                targetI = nextBeginningIndexes[lastMatch];\n\t\t\t              } else {\n\t\t\t                var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n\t\t\t                if (isMatch) {\n\t\t\t                  matchesStrict[matchesStrictLen++] = targetI;\n\t\t\t                  ++searchI;\n\t\t\t                  if (searchI === searchLen) {\n\t\t\t                    successStrict = true;\n\t\t\t                    break;\n\t\t\t                  }\n\t\t\t                  ++targetI;\n\t\t\t                } else {\n\t\t\t                  targetI = nextBeginningIndexes[targetI];\n\t\t\t                }\n\t\t\t              }\n\t\t\t            }\n\t\t\t            {\n\t\t\t              // tally up the score & keep track of matches for highlighting later\n\t\t\t              if (successStrict) {\n\t\t\t                var matchesBest = matchesStrict;\n\t\t\t                var matchesBestLen = matchesStrictLen;\n\t\t\t              } else {\n\t\t\t                var matchesBest = matchesSimple;\n\t\t\t                var matchesBestLen = matchesSimpleLen;\n\t\t\t              }\n\t\t\t              var score = 0;\n\t\t\t              var lastTargetI = -1;\n\t\t\t              for (var i = 0; i < searchLen; ++i) {\n\t\t\t                var targetI = matchesBest[i];\n\t\t\t                // score only goes down if they're not consecutive\n\t\t\t                if (lastTargetI !== targetI - 1) score -= targetI;\n\t\t\t                lastTargetI = targetI;\n\t\t\t              }\n\t\t\t              if (!successStrict) score *= 1000;\n\t\t\t              score -= targetLen - searchLen;\n\t\t\t              prepared.score = score;\n\t\t\t              prepared.indexes = new Array(matchesBestLen);\n\t\t\t              for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];\n\t\t\t              return prepared;\n\t\t\t            }\n\t\t\t          },\n\t\t\t          prepareLowerCodes: function prepareLowerCodes(str) {\n\t\t\t            var strLen = str.length;\n\t\t\t            var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n\t\t\t            var lower = str.toLowerCase();\n\t\t\t            for (var i = 0; i < strLen; ++i) lowerCodes[i] = lower.charCodeAt(i);\n\t\t\t            return lowerCodes;\n\t\t\t          },\n\t\t\t          prepareBeginningIndexes: function prepareBeginningIndexes(target) {\n\t\t\t            var targetLen = target.length;\n\t\t\t            var beginningIndexes = [];\n\t\t\t            var beginningIndexesLen = 0;\n\t\t\t            var wasUpper = false;\n\t\t\t            var wasAlphanum = false;\n\t\t\t            for (var i = 0; i < targetLen; ++i) {\n\t\t\t              var targetCode = target.charCodeAt(i);\n\t\t\t              var isUpper = targetCode >= 65 && targetCode <= 90;\n\t\t\t              var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n\t\t\t              var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n\t\t\t              wasUpper = isUpper;\n\t\t\t              wasAlphanum = isAlphanum;\n\t\t\t              if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n\t\t\t            }\n\t\t\t            return beginningIndexes;\n\t\t\t          },\n\t\t\t          prepareNextBeginningIndexes: function prepareNextBeginningIndexes(target) {\n\t\t\t            var targetLen = target.length;\n\t\t\t            var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);\n\t\t\t            var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n\t\t\t            var lastIsBeginning = beginningIndexes[0];\n\t\t\t            var lastIsBeginningI = 0;\n\t\t\t            for (var i = 0; i < targetLen; ++i) {\n\t\t\t              if (lastIsBeginning > i) {\n\t\t\t                nextBeginningIndexes[i] = lastIsBeginning;\n\t\t\t              } else {\n\t\t\t                lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n\t\t\t                nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n\t\t\t              }\n\t\t\t            }\n\t\t\t            return nextBeginningIndexes;\n\t\t\t          },\n\t\t\t          cleanup: cleanup,\n\t\t\t          new: fuzzysortNew\n\t\t\t        };\n\t\t\t        return fuzzysort;\n\t\t\t      } // fuzzysortNew\n\n\t\t\t      // This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\n\t\t\t      var isNode = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined';\n\t\t\t      var MyMap = typeof Map === 'function' ? Map : function () {\n\t\t\t        var s = Object.create(null);\n\t\t\t        this.get = function (k) {\n\t\t\t          return s[k];\n\t\t\t        };\n\t\t\t        this.set = function (k, val) {\n\t\t\t          s[k] = val;\n\t\t\t          return this;\n\t\t\t        };\n\t\t\t        this.clear = function () {\n\t\t\t          s = Object.create(null);\n\t\t\t        };\n\t\t\t      };\n\t\t\t      var preparedCache = new MyMap();\n\t\t\t      var preparedSearchCache = new MyMap();\n\t\t\t      var noResults = [];\n\t\t\t      noResults.total = 0;\n\t\t\t      var matchesSimple = [];\n\t\t\t      var matchesStrict = [];\n\t\t\t      function cleanup() {\n\t\t\t        preparedCache.clear();\n\t\t\t        preparedSearchCache.clear();\n\t\t\t        matchesSimple = [];\n\t\t\t        matchesStrict = [];\n\t\t\t      }\n\t\t\t      function defaultScoreFn(a) {\n\t\t\t        var max = -9007199254740991;\n\t\t\t        for (var i = a.length - 1; i >= 0; --i) {\n\t\t\t          var result = a[i];\n\t\t\t          if (result === null) continue;\n\t\t\t          var score = result.score;\n\t\t\t          if (score > max) max = score;\n\t\t\t        }\n\t\t\t        if (max === -9007199254740991) return null;\n\t\t\t        return max;\n\t\t\t      }\n\n\t\t\t      // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n\t\t\t      // prop = 'key1.key2'        10ms\n\t\t\t      // prop = ['key1', 'key2']   27ms\n\t\t\t      function getValue(obj, prop) {\n\t\t\t        var tmp = obj[prop];\n\t\t\t        if (tmp !== undefined) return tmp;\n\t\t\t        var segs = prop;\n\t\t\t        if (!Array.isArray(prop)) segs = prop.split('.');\n\t\t\t        var len = segs.length;\n\t\t\t        var i = -1;\n\t\t\t        while (obj && ++i < len) obj = obj[segs[i]];\n\t\t\t        return obj;\n\t\t\t      }\n\t\t\t      function isObj(x) {\n\t\t\t        return _typeof(x) === 'object';\n\t\t\t      } // faster as a function\n\n\t\t\t      // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n\t\t\t      var fastpriorityqueue = function fastpriorityqueue() {\n\t\t\t        var r = [],\n\t\t\t          o = 0,\n\t\t\t          e = {};\n\t\t\t        function n() {\n\t\t\t          for (var e = 0, n = r[e], c = 1; c < o;) {\n\t\t\t            var f = c + 1;\n\t\t\t            e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);\n\t\t\t          }\n\t\t\t          for (var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1) r[e] = r[a];\n\t\t\t          r[e] = n;\n\t\t\t        }\n\t\t\t        return e.add = function (e) {\n\t\t\t          var n = o;\n\t\t\t          r[o++] = e;\n\t\t\t          for (var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1) r[n] = r[c];\n\t\t\t          r[n] = e;\n\t\t\t        }, e.poll = function () {\n\t\t\t          if (0 !== o) {\n\t\t\t            var e = r[0];\n\t\t\t            return r[0] = r[--o], n(), e;\n\t\t\t          }\n\t\t\t        }, e.peek = function (e) {\n\t\t\t          if (0 !== o) return r[0];\n\t\t\t        }, e.replaceTop = function (o) {\n\t\t\t          r[0] = o, n();\n\t\t\t        }, e;\n\t\t\t      };\n\t\t\t      var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own\n\n\t\t\t      return fuzzysortNew();\n\t\t\t    }); // UMD\n\n\t\t\t    // TODO: (performance) wasm version!?\n\t\t\t    // TODO: (performance) threads?\n\t\t\t    // TODO: (performance) avoid cache misses\n\t\t\t    // TODO: (performance) preparedCache is a memory leak\n\t\t\t    // TODO: (like sublime) backslash === forwardslash\n\t\t\t    // TODO: (like sublime) spaces: \"a b\" should do 2 searches 1 for a and 1 for b\n\t\t\t    // TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\n\t\t\t    // TODO: (performance) idk if allowTypo is optimized\n\t\t\t  })(fuzzysort$1);\n\t\t\t  var fuzzysort = fuzzysort$1.exports;\n\n\t\t\t  var stats = {\n\t\t\t    failedTests: [],\n\t\t\t    defined: 0,\n\t\t\t    completed: 0\n\t\t\t  };\n\t\t\t  (function () {\n\t\t\t    // Don't load the HTML Reporter on non-browser environments\n\t\t\t    if (!window$1 || !document) {\n\t\t\t      return;\n\t\t\t    }\n\t\t\t    QUnit.reporters.perf.init(QUnit);\n\t\t\t    var config = QUnit.config;\n\t\t\t    var hiddenTests = [];\n\t\t\t    var collapseNext = false;\n\t\t\t    var hasOwn = Object.prototype.hasOwnProperty;\n\t\t\t    var unfilteredUrl = setUrl({\n\t\t\t      filter: undefined,\n\t\t\t      module: undefined,\n\t\t\t      moduleId: undefined,\n\t\t\t      testId: undefined\n\t\t\t    });\n\t\t\t    var dropdownData = null;\n\t\t\t    function trim(string) {\n\t\t\t      if (typeof string.trim === 'function') {\n\t\t\t        return string.trim();\n\t\t\t      } else {\n\t\t\t        return string.replace(/^\\s+|\\s+$/g, '');\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function addEvent(elem, type, fn) {\n\t\t\t      elem.addEventListener(type, fn, false);\n\t\t\t    }\n\t\t\t    function removeEvent(elem, type, fn) {\n\t\t\t      elem.removeEventListener(type, fn, false);\n\t\t\t    }\n\t\t\t    function addEvents(elems, type, fn) {\n\t\t\t      var i = elems.length;\n\t\t\t      while (i--) {\n\t\t\t        addEvent(elems[i], type, fn);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function hasClass(elem, name) {\n\t\t\t      return (' ' + elem.className + ' ').indexOf(' ' + name + ' ') >= 0;\n\t\t\t    }\n\t\t\t    function addClass(elem, name) {\n\t\t\t      if (!hasClass(elem, name)) {\n\t\t\t        elem.className += (elem.className ? ' ' : '') + name;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function toggleClass(elem, name, force) {\n\t\t\t      if (force || typeof force === 'undefined' && !hasClass(elem, name)) {\n\t\t\t        addClass(elem, name);\n\t\t\t      } else {\n\t\t\t        removeClass(elem, name);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function removeClass(elem, name) {\n\t\t\t      var set = ' ' + elem.className + ' ';\n\n\t\t\t      // Class name may appear multiple times\n\t\t\t      while (set.indexOf(' ' + name + ' ') >= 0) {\n\t\t\t        set = set.replace(' ' + name + ' ', ' ');\n\t\t\t      }\n\n\t\t\t      // Trim for prettiness\n\t\t\t      elem.className = trim(set);\n\t\t\t    }\n\t\t\t    function id(name) {\n\t\t\t      return document.getElementById && document.getElementById(name);\n\t\t\t    }\n\t\t\t    function abortTests() {\n\t\t\t      var abortButton = id('qunit-abort-tests-button');\n\t\t\t      if (abortButton) {\n\t\t\t        abortButton.disabled = true;\n\t\t\t        abortButton.innerHTML = 'Aborting...';\n\t\t\t      }\n\t\t\t      QUnit.config.queue.length = 0;\n\t\t\t      return false;\n\t\t\t    }\n\t\t\t    function interceptNavigation(ev) {\n\t\t\t      // Trim potential accidental whitespace so that QUnit doesn't throw an error about no tests matching the filter.\n\t\t\t      var filterInputElem = id('qunit-filter-input');\n\t\t\t      filterInputElem.value = trim(filterInputElem.value);\n\t\t\t      applyUrlParams();\n\t\t\t      if (ev && ev.preventDefault) {\n\t\t\t        ev.preventDefault();\n\t\t\t      }\n\t\t\t      return false;\n\t\t\t    }\n\t\t\t    function getUrlConfigHtml() {\n\t\t\t      var selection = false;\n\t\t\t      var urlConfig = config.urlConfig;\n\t\t\t      var urlConfigHtml = '';\n\t\t\t      for (var i = 0; i < urlConfig.length; i++) {\n\t\t\t        // Options can be either strings or objects with nonempty \"id\" properties\n\t\t\t        var val = config.urlConfig[i];\n\t\t\t        if (typeof val === 'string') {\n\t\t\t          val = {\n\t\t\t            id: val,\n\t\t\t            label: val\n\t\t\t          };\n\t\t\t        }\n\t\t\t        var escaped = escapeText(val.id);\n\t\t\t        var escapedTooltip = escapeText(val.tooltip);\n\t\t\t        if (!val.value || typeof val.value === 'string') {\n\t\t\t          urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'><input id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' type='checkbox'\" + (val.value ? \" value='\" + escapeText(val.value) + \"'\" : '') + (config[val.id] ? \" checked='checked'\" : '') + \" title='\" + escapedTooltip + \"' />\" + escapeText(val.label) + '</label>';\n\t\t\t        } else {\n\t\t\t          urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'>\" + escapeText(val.label) + \": <select id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\t\t\t          if (Array.isArray(val.value)) {\n\t\t\t            for (var j = 0; j < val.value.length; j++) {\n\t\t\t              escaped = escapeText(val.value[j]);\n\t\t\t              urlConfigHtml += \"<option value='\" + escaped + \"'\" + (config[val.id] === val.value[j] ? (selection = true) && \" selected='selected'\" : '') + '>' + escaped + '</option>';\n\t\t\t            }\n\t\t\t          } else {\n\t\t\t            for (var _j in val.value) {\n\t\t\t              if (hasOwn.call(val.value, _j)) {\n\t\t\t                urlConfigHtml += \"<option value='\" + escapeText(_j) + \"'\" + (config[val.id] === _j ? (selection = true) && \" selected='selected'\" : '') + '>' + escapeText(val.value[_j]) + '</option>';\n\t\t\t              }\n\t\t\t            }\n\t\t\t          }\n\t\t\t          if (config[val.id] && !selection) {\n\t\t\t            escaped = escapeText(config[val.id]);\n\t\t\t            urlConfigHtml += \"<option value='\" + escaped + \"' selected='selected' disabled='disabled'>\" + escaped + '</option>';\n\t\t\t          }\n\t\t\t          urlConfigHtml += '</select></label>';\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return urlConfigHtml;\n\t\t\t    }\n\n\t\t\t    // Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n\t\t\t    // Updates the URL with the new state of `config.urlConfig` values.\n\t\t\t    function toolbarChanged() {\n\t\t\t      var field = this;\n\t\t\t      var params = {};\n\n\t\t\t      // Detect if field is a select menu or a checkbox\n\t\t\t      var value;\n\t\t\t      if ('selectedIndex' in field) {\n\t\t\t        value = field.options[field.selectedIndex].value || undefined;\n\t\t\t      } else {\n\t\t\t        value = field.checked ? field.defaultValue || true : undefined;\n\t\t\t      }\n\t\t\t      params[field.name] = value;\n\t\t\t      var updatedUrl = setUrl(params);\n\n\t\t\t      // Check if we can apply the change without a page refresh\n\t\t\t      if (field.name === 'hidepassed' && 'replaceState' in window$1.history) {\n\t\t\t        QUnit.urlParams[field.name] = value;\n\t\t\t        config[field.name] = value || false;\n\t\t\t        var tests = id('qunit-tests');\n\t\t\t        if (tests) {\n\t\t\t          if (field.checked) {\n\t\t\t            var length = tests.children.length;\n\t\t\t            var children = tests.children;\n\t\t\t            for (var i = 0; i < length; i++) {\n\t\t\t              var test = children[i];\n\t\t\t              var className = test ? test.className : '';\n\t\t\t              var classNameHasPass = className.indexOf('pass') > -1;\n\t\t\t              var classNameHasSkipped = className.indexOf('skipped') > -1;\n\t\t\t              if (classNameHasPass || classNameHasSkipped) {\n\t\t\t                hiddenTests.push(test);\n\t\t\t              }\n\t\t\t            }\n\n\t\t\t            // Optimization: Avoid `for-of` iterator overhead.\n\t\t\t            for (var _i = 0; _i < hiddenTests.length; _i++) {\n\t\t\t              tests.removeChild(hiddenTests[_i]);\n\t\t\t            }\n\t\t\t          } else {\n\t\t\t            // Optimization: Avoid `while (arr.length) arr.shift()` which would mutate the array many times.\n\t\t\t            // As of Chrome 126, HTMLElement.append(...hiddenTests) is still slower than\n\t\t\t            // calling appendChild in a loop.\n\t\t\t            for (var _i2 = 0; _i2 < hiddenTests.length; _i2++) {\n\t\t\t              tests.appendChild(hiddenTests[_i2]);\n\t\t\t            }\n\t\t\t            hiddenTests.length = 0;\n\t\t\t          }\n\t\t\t        }\n\t\t\t        window$1.history.replaceState(null, '', updatedUrl);\n\t\t\t      } else {\n\t\t\t        window$1.location = updatedUrl;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function setUrl(params) {\n\t\t\t      var querystring = '?';\n\t\t\t      var location = window$1.location;\n\t\t\t      params = extend(extend({}, QUnit.urlParams), params);\n\t\t\t      for (var key in params) {\n\t\t\t        // Skip inherited or undefined properties\n\t\t\t        if (hasOwn.call(params, key) && params[key] !== undefined) {\n\t\t\t          // Output a parameter for each value of this key\n\t\t\t          // (but usually just one)\n\t\t\t          var arrValue = [].concat(params[key]);\n\t\t\t          for (var i = 0; i < arrValue.length; i++) {\n\t\t\t            querystring += encodeURIComponent(key);\n\t\t\t            if (arrValue[i] !== true) {\n\t\t\t              querystring += '=' + encodeURIComponent(arrValue[i]);\n\t\t\t            }\n\t\t\t            querystring += '&';\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return location.protocol + '//' + location.host + location.pathname + querystring.slice(0, -1);\n\t\t\t    }\n\t\t\t    function applyUrlParams() {\n\t\t\t      var filter = id('qunit-filter-input').value;\n\t\t\t      window$1.location = setUrl({\n\t\t\t        filter: filter === '' ? undefined : filter,\n\t\t\t        moduleId: _toConsumableArray(dropdownData.selectedMap.keys()),\n\t\t\t        // Remove module and testId filter\n\t\t\t        module: undefined,\n\t\t\t        testId: undefined\n\t\t\t      });\n\t\t\t    }\n\t\t\t    function toolbarUrlConfigContainer() {\n\t\t\t      var urlConfigContainer = document.createElement('span');\n\t\t\t      urlConfigContainer.innerHTML = getUrlConfigHtml();\n\t\t\t      addClass(urlConfigContainer, 'qunit-url-config');\n\t\t\t      addEvents(urlConfigContainer.getElementsByTagName('input'), 'change', toolbarChanged);\n\t\t\t      addEvents(urlConfigContainer.getElementsByTagName('select'), 'change', toolbarChanged);\n\t\t\t      return urlConfigContainer;\n\t\t\t    }\n\t\t\t    function abortTestsButton() {\n\t\t\t      var button = document.createElement('button');\n\t\t\t      button.id = 'qunit-abort-tests-button';\n\t\t\t      button.innerHTML = 'Abort';\n\t\t\t      addEvent(button, 'click', abortTests);\n\t\t\t      return button;\n\t\t\t    }\n\t\t\t    function toolbarLooseFilter() {\n\t\t\t      var filter = document.createElement('form');\n\t\t\t      var label = document.createElement('label');\n\t\t\t      var input = document.createElement('input');\n\t\t\t      var button = document.createElement('button');\n\t\t\t      addClass(filter, 'qunit-filter');\n\t\t\t      label.innerHTML = 'Filter: ';\n\t\t\t      input.type = 'text';\n\t\t\t      input.value = config.filter || '';\n\t\t\t      input.name = 'filter';\n\t\t\t      input.id = 'qunit-filter-input';\n\t\t\t      button.innerHTML = 'Go';\n\t\t\t      label.appendChild(input);\n\t\t\t      filter.appendChild(label);\n\t\t\t      filter.appendChild(document.createTextNode(' '));\n\t\t\t      filter.appendChild(button);\n\t\t\t      addEvent(filter, 'submit', interceptNavigation);\n\t\t\t      return filter;\n\t\t\t    }\n\t\t\t    function createModuleListItem(moduleId, name, checked) {\n\t\t\t      return '<li><label class=\"clickable' + (checked ? ' checked' : '') + '\"><input type=\"checkbox\" ' + 'value=\"' + escapeText(moduleId) + '\"' + (checked ? ' checked=\"checked\"' : '') + ' />' + escapeText(name) + '</label></li>';\n\t\t\t    }\n\n\t\t\t    /**\n\t\t\t     * @param {Array} Results from fuzzysort\n\t\t\t     * @return {string} HTML\n\t\t\t     */\n\t\t\t    function moduleListHtml(results) {\n\t\t\t      var html = '';\n\n\t\t\t      // Hoist the already selected items, and show them always\n\t\t\t      // even if not matched by the current search.\n\t\t\t      dropdownData.selectedMap.forEach(function (name, moduleId) {\n\t\t\t        html += createModuleListItem(moduleId, name, true);\n\t\t\t      });\n\t\t\t      for (var i = 0; i < results.length; i++) {\n\t\t\t        var mod = results[i].obj;\n\t\t\t        if (!dropdownData.selectedMap.has(mod.moduleId)) {\n\t\t\t          html += createModuleListItem(mod.moduleId, mod.name, false);\n\t\t\t        }\n\t\t\t      }\n\t\t\t      return html;\n\t\t\t    }\n\t\t\t    function toolbarModuleFilter(beginDetails) {\n\t\t\t      var initialSelected = null;\n\t\t\t      dropdownData = {\n\t\t\t        options: beginDetails.modules.slice(),\n\t\t\t        selectedMap: new StringMap(),\n\t\t\t        isDirty: function isDirty() {\n\t\t\t          return _toConsumableArray(dropdownData.selectedMap.keys()).sort().join(',') !== _toConsumableArray(initialSelected.keys()).sort().join(',');\n\t\t\t        }\n\t\t\t      };\n\t\t\t      if (config.moduleId.length) {\n\t\t\t        // The module dropdown is seeded with the runtime configuration of the last run.\n\t\t\t        //\n\t\t\t        // We don't reference `config.moduleId` directly after this and keep our own\n\t\t\t        // copy because:\n\t\t\t        // 1. This naturally filters out unknown moduleIds.\n\t\t\t        // 2. Gives us a place to manage and remember unsubmitted checkbox changes.\n\t\t\t        // 3. Gives us an efficient way to map a selected moduleId to module name\n\t\t\t        //    during rendering.\n\t\t\t        for (var i = 0; i < beginDetails.modules.length; i++) {\n\t\t\t          var mod = beginDetails.modules[i];\n\t\t\t          if (config.moduleId.indexOf(mod.moduleId) !== -1) {\n\t\t\t            dropdownData.selectedMap.set(mod.moduleId, mod.name);\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t      initialSelected = new StringMap(dropdownData.selectedMap);\n\t\t\t      var moduleSearch = document.createElement('input');\n\t\t\t      moduleSearch.id = 'qunit-modulefilter-search';\n\t\t\t      moduleSearch.autocomplete = 'off';\n\t\t\t      addEvent(moduleSearch, 'input', searchInput);\n\t\t\t      addEvent(moduleSearch, 'input', searchFocus);\n\t\t\t      addEvent(moduleSearch, 'focus', searchFocus);\n\t\t\t      addEvent(moduleSearch, 'click', searchFocus);\n\t\t\t      var label = document.createElement('label');\n\t\t\t      label.htmlFor = 'qunit-modulefilter-search';\n\t\t\t      label.textContent = 'Module:';\n\t\t\t      var searchContainer = document.createElement('span');\n\t\t\t      searchContainer.id = 'qunit-modulefilter-search-container';\n\t\t\t      searchContainer.appendChild(moduleSearch);\n\t\t\t      var applyButton = document.createElement('button');\n\t\t\t      applyButton.textContent = 'Apply';\n\t\t\t      applyButton.title = 'Re-run the selected test modules';\n\t\t\t      addEvent(applyButton, 'click', applyUrlParams);\n\t\t\t      var resetButton = document.createElement('button');\n\t\t\t      resetButton.textContent = 'Reset';\n\t\t\t      resetButton.type = 'reset';\n\t\t\t      resetButton.title = 'Restore the previous module selection';\n\t\t\t      var clearButton = document.createElement('button');\n\t\t\t      clearButton.textContent = 'Select none';\n\t\t\t      clearButton.type = 'button';\n\t\t\t      clearButton.title = 'Clear the current module selection';\n\t\t\t      addEvent(clearButton, 'click', function () {\n\t\t\t        dropdownData.selectedMap.clear();\n\t\t\t        selectionChange();\n\t\t\t        searchInput();\n\t\t\t      });\n\t\t\t      var actions = document.createElement('span');\n\t\t\t      actions.id = 'qunit-modulefilter-actions';\n\t\t\t      actions.appendChild(applyButton);\n\t\t\t      actions.appendChild(resetButton);\n\t\t\t      if (initialSelected.size) {\n\t\t\t        // Only show clear button if functionally different from reset\n\t\t\t        actions.appendChild(clearButton);\n\t\t\t      }\n\t\t\t      var dropDownList = document.createElement('ul');\n\t\t\t      dropDownList.id = 'qunit-modulefilter-dropdown-list';\n\t\t\t      var dropDown = document.createElement('div');\n\t\t\t      dropDown.id = 'qunit-modulefilter-dropdown';\n\t\t\t      dropDown.style.display = 'none';\n\t\t\t      dropDown.appendChild(actions);\n\t\t\t      dropDown.appendChild(dropDownList);\n\t\t\t      addEvent(dropDown, 'change', selectionChange);\n\t\t\t      searchContainer.appendChild(dropDown);\n\t\t\t      // Set initial moduleSearch.placeholder and clearButton/resetButton.\n\t\t\t      selectionChange();\n\t\t\t      var moduleFilter = document.createElement('form');\n\t\t\t      moduleFilter.id = 'qunit-modulefilter';\n\t\t\t      moduleFilter.appendChild(label);\n\t\t\t      moduleFilter.appendChild(document.createTextNode(' '));\n\t\t\t      moduleFilter.appendChild(searchContainer);\n\t\t\t      addEvent(moduleFilter, 'submit', interceptNavigation);\n\t\t\t      addEvent(moduleFilter, 'reset', function () {\n\t\t\t        dropdownData.selectedMap = new StringMap(initialSelected);\n\t\t\t        // Set moduleSearch.placeholder and reflect non-dirty state\n\t\t\t        selectionChange();\n\t\t\t        searchInput();\n\t\t\t      });\n\n\t\t\t      // Enables show/hide for the dropdown\n\t\t\t      function searchFocus() {\n\t\t\t        if (dropDown.style.display !== 'none') {\n\t\t\t          return;\n\t\t\t        }\n\n\t\t\t        // Optimization: Defer rendering options until focussed.\n\t\t\t        // https://github.com/qunitjs/qunit/issues/1664\n\t\t\t        searchInput();\n\t\t\t        dropDown.style.display = 'block';\n\n\t\t\t        // Hide on Escape keydown or on click outside the container\n\t\t\t        addEvent(document, 'click', hideHandler);\n\t\t\t        addEvent(document, 'keydown', hideHandler);\n\t\t\t        function hideHandler(e) {\n\t\t\t          var inContainer = moduleFilter.contains(e.target);\n\t\t\t          if (e.keyCode === 27 || !inContainer) {\n\t\t\t            if (e.keyCode === 27 && inContainer) {\n\t\t\t              moduleSearch.focus();\n\t\t\t            }\n\t\t\t            dropDown.style.display = 'none';\n\t\t\t            removeEvent(document, 'click', hideHandler);\n\t\t\t            removeEvent(document, 'keydown', hideHandler);\n\t\t\t            moduleSearch.value = '';\n\t\t\t            searchInput();\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      /**\n\t\t\t       * @param {string} searchText\n\t\t\t       * @return {string} HTML\n\t\t\t       */\n\t\t\t      function filterModules(searchText) {\n\t\t\t        var results;\n\t\t\t        if (searchText === '') {\n\t\t\t          // Improve on-boarding experience by having an immediate display of\n\t\t\t          // module names, indicating how the interface works. This also makes\n\t\t\t          // for a quicker interaction in the common case of small projects.\n\t\t\t          // Don't mandate typing just to get the menu.\n\t\t\t          results = dropdownData.options.slice(0, 20).map(function (obj) {\n\t\t\t            // Fake empty results. https://github.com/farzher/fuzzysort/issues/41\n\t\t\t            return {\n\t\t\t              obj: obj\n\t\t\t            };\n\t\t\t          });\n\t\t\t        } else {\n\t\t\t          results = fuzzysort.go(searchText, dropdownData.options, {\n\t\t\t            limit: 20,\n\t\t\t            key: 'name',\n\t\t\t            allowTypo: true\n\t\t\t          });\n\t\t\t        }\n\t\t\t        return moduleListHtml(results);\n\t\t\t      }\n\n\t\t\t      // Processes module search box input\n\t\t\t      var searchInputTimeout;\n\t\t\t      function searchInput() {\n\t\t\t        // Use a debounce with a ~0ms timeout. This is effectively instantaneous,\n\t\t\t        // but is better than undebounced because it avoids an ever-growing\n\t\t\t        // backlog of unprocessed now-outdated input events if fuzzysearch or\n\t\t\t        // drodown DOM is slow (e.g. very large test suite).\n\t\t\t        window$1.clearTimeout(searchInputTimeout);\n\t\t\t        searchInputTimeout = window$1.setTimeout(function () {\n\t\t\t          dropDownList.innerHTML = filterModules(moduleSearch.value);\n\t\t\t        });\n\t\t\t      }\n\n\t\t\t      // Processes checkbox change, or a generic render (initial render, or after reset event)\n\t\t\t      // Avoid any dropdown rendering here as this is used by toolbarModuleFilter()\n\t\t\t      // during the initial render, which should not delay test execution.\n\t\t\t      function selectionChange(evt) {\n\t\t\t        var checkbox = evt && evt.target || null;\n\t\t\t        if (checkbox) {\n\t\t\t          // Update internal state\n\t\t\t          if (checkbox.checked) {\n\t\t\t            dropdownData.selectedMap.set(checkbox.value, checkbox.parentNode.textContent);\n\t\t\t          } else {\n\t\t\t            dropdownData.selectedMap.delete(checkbox.value);\n\t\t\t          }\n\n\t\t\t          // Update UI state\n\t\t\t          toggleClass(checkbox.parentNode, 'checked', checkbox.checked);\n\t\t\t        }\n\t\t\t        var textForm = dropdownData.selectedMap.size ? dropdownData.selectedMap.size + ' ' + (dropdownData.selectedMap.size === 1 ? 'module' : 'modules') : 'All modules';\n\t\t\t        moduleSearch.placeholder = textForm;\n\t\t\t        moduleSearch.title = 'Type to search through and reduce the list.';\n\t\t\t        resetButton.disabled = !dropdownData.isDirty();\n\t\t\t        clearButton.style.display = dropdownData.selectedMap.size ? '' : 'none';\n\t\t\t      }\n\t\t\t      return moduleFilter;\n\t\t\t    }\n\t\t\t    function appendToolbar(beginDetails) {\n\t\t\t      var toolbar = id('qunit-testrunner-toolbar');\n\t\t\t      if (toolbar) {\n\t\t\t        toolbar.appendChild(toolbarUrlConfigContainer());\n\t\t\t        var toolbarFilters = document.createElement('span');\n\t\t\t        toolbarFilters.id = 'qunit-toolbar-filters';\n\t\t\t        toolbarFilters.appendChild(toolbarLooseFilter());\n\t\t\t        toolbarFilters.appendChild(toolbarModuleFilter(beginDetails));\n\t\t\t        var clearfix = document.createElement('div');\n\t\t\t        clearfix.className = 'clearfix';\n\t\t\t        toolbar.appendChild(toolbarFilters);\n\t\t\t        toolbar.appendChild(clearfix);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function appendHeader() {\n\t\t\t      var header = id('qunit-header');\n\t\t\t      if (header) {\n\t\t\t        header.innerHTML = \"<a href='\" + escapeText(unfilteredUrl) + \"'>\" + header.innerHTML + '</a> ';\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function appendBanner() {\n\t\t\t      var banner = id('qunit-banner');\n\t\t\t      if (banner) {\n\t\t\t        banner.className = '';\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function appendTestResults() {\n\t\t\t      var tests = id('qunit-tests');\n\t\t\t      var result = id('qunit-testresult');\n\t\t\t      var controls;\n\t\t\t      if (result) {\n\t\t\t        result.parentNode.removeChild(result);\n\t\t\t      }\n\t\t\t      if (tests) {\n\t\t\t        tests.innerHTML = '';\n\t\t\t        result = document.createElement('p');\n\t\t\t        result.id = 'qunit-testresult';\n\t\t\t        result.className = 'result';\n\t\t\t        tests.parentNode.insertBefore(result, tests);\n\t\t\t        result.innerHTML = '<div id=\"qunit-testresult-display\">Running...<br />&#160;</div>' + '<div id=\"qunit-testresult-controls\"></div>' + '<div class=\"clearfix\"></div>';\n\t\t\t        controls = id('qunit-testresult-controls');\n\t\t\t      }\n\t\t\t      if (controls) {\n\t\t\t        controls.appendChild(abortTestsButton());\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function appendFilteredTest() {\n\t\t\t      var testId = QUnit.config.testId;\n\t\t\t      if (!testId || testId.length <= 0) {\n\t\t\t        return '';\n\t\t\t      }\n\t\t\t      return \"<div id='qunit-filteredTest'>Rerunning selected tests: \" + escapeText(testId.join(', ')) + \" <a id='qunit-clearFilter' href='\" + escapeText(unfilteredUrl) + \"'>Run all tests</a></div>\";\n\t\t\t    }\n\t\t\t    function appendUserAgent() {\n\t\t\t      var userAgent = id('qunit-userAgent');\n\t\t\t      if (userAgent) {\n\t\t\t        userAgent.innerHTML = '';\n\t\t\t        userAgent.appendChild(document.createTextNode('QUnit ' + QUnit.version + '; ' + navigator.userAgent));\n\t\t\t      }\n\t\t\t    }\n\t\t\t    function appendInterface(beginDetails) {\n\t\t\t      var qunit = id('qunit');\n\n\t\t\t      // For compat with QUnit 1.2, and to support fully custom theme HTML,\n\t\t\t      // we will use any existing elements if no id=\"qunit\" element exists.\n\t\t\t      //\n\t\t\t      // Note that we don't fail or fallback to creating it ourselves,\n\t\t\t      // because not having id=\"qunit\" (and not having the below elements)\n\t\t\t      // simply means QUnit acts headless, allowing users to use their own\n\t\t\t      // reporters, or for a test runner to listen for events directly without\n\t\t\t      // having the HTML reporter actively render anything.\n\t\t\t      if (qunit) {\n\t\t\t        qunit.setAttribute('role', 'main');\n\n\t\t\t        // Since QUnit 1.3, these are created automatically if the page\n\t\t\t        // contains id=\"qunit\".\n\t\t\t        qunit.innerHTML = \"<h1 id='qunit-header'>\" + escapeText(document.title) + '</h1>' + \"<h2 id='qunit-banner'></h2>\" + \"<div id='qunit-testrunner-toolbar' role='navigation'></div>\" + appendFilteredTest() + \"<h2 id='qunit-userAgent'></h2>\" + \"<ol id='qunit-tests'></ol>\";\n\t\t\t      }\n\t\t\t      appendHeader();\n\t\t\t      appendBanner();\n\t\t\t      appendTestResults();\n\t\t\t      appendUserAgent();\n\t\t\t      appendToolbar(beginDetails);\n\t\t\t    }\n\t\t\t    function appendTest(name, testId, moduleName) {\n\t\t\t      var tests = id('qunit-tests');\n\t\t\t      if (!tests) {\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      var title = document.createElement('strong');\n\t\t\t      title.className = 'qunit-test-name';\n\t\t\t      title.innerHTML = getNameHtml(name, moduleName);\n\t\t\t      var testBlock = document.createElement('li');\n\t\t\t      testBlock.appendChild(title);\n\n\t\t\t      // No ID or rerun link for \"global failure\" blocks\n\t\t\t      if (testId !== undefined) {\n\t\t\t        var rerunTrigger = document.createElement('a');\n\t\t\t        rerunTrigger.innerHTML = 'Rerun';\n\t\t\t        rerunTrigger.href = setUrl({\n\t\t\t          testId: testId\n\t\t\t        });\n\t\t\t        testBlock.id = 'qunit-test-output-' + testId;\n\t\t\t        testBlock.appendChild(rerunTrigger);\n\t\t\t      }\n\t\t\t      var assertList = document.createElement('ol');\n\t\t\t      assertList.className = 'qunit-assert-list';\n\t\t\t      testBlock.appendChild(assertList);\n\t\t\t      tests.appendChild(testBlock);\n\t\t\t      return testBlock;\n\t\t\t    }\n\n\t\t\t    // HTML Reporter initialization and load\n\t\t\t    QUnit.on('runStart', function (runStart) {\n\t\t\t      stats.defined = runStart.testCounts.total;\n\t\t\t    });\n\t\t\t    QUnit.begin(function (beginDetails) {\n\t\t\t      // Initialize QUnit elements\n\t\t\t      // This is done from begin() instead of runStart, because\n\t\t\t      // urlparams.js uses begin(), which we need to wait for.\n\t\t\t      // urlparams.js in turn uses begin() to allow plugins to\n\t\t\t      // add entries to QUnit.config.urlConfig, which may be done\n\t\t\t      // asynchronously.\n\t\t\t      // <https://github.com/qunitjs/qunit/issues/1657>\n\t\t\t      appendInterface(beginDetails);\n\t\t\t    });\n\t\t\t    function getRerunFailedHtml(failedTests) {\n\t\t\t      if (failedTests.length === 0) {\n\t\t\t        return '';\n\t\t\t      }\n\t\t\t      var href = setUrl({\n\t\t\t        testId: failedTests\n\t\t\t      });\n\t\t\t      return [\"<br /><a href='\" + escapeText(href) + \"'>\", failedTests.length === 1 ? 'Rerun 1 failed test' : 'Rerun ' + failedTests.length + ' failed tests', '</a>'].join('');\n\t\t\t    }\n\t\t\t    QUnit.on('runEnd', function (runEnd) {\n\t\t\t      var banner = id('qunit-banner');\n\t\t\t      var tests = id('qunit-tests');\n\t\t\t      var abortButton = id('qunit-abort-tests-button');\n\t\t\t      var assertPassed = config.stats.all - config.stats.bad;\n\t\t\t      var html = [runEnd.testCounts.total, ' tests completed in ', runEnd.runtime, ' milliseconds, with ', runEnd.testCounts.failed, ' failed, ', runEnd.testCounts.skipped, ' skipped, and ', runEnd.testCounts.todo, ' todo.<br />', \"<span class='passed'>\", assertPassed, \"</span> assertions of <span class='total'>\", config.stats.all, \"</span> passed, <span class='failed'>\", config.stats.bad, '</span> failed.', getRerunFailedHtml(stats.failedTests)].join('');\n\t\t\t      var test;\n\t\t\t      var assertLi;\n\t\t\t      var assertList;\n\n\t\t\t      // Update remaining tests to aborted\n\t\t\t      if (abortButton && abortButton.disabled) {\n\t\t\t        html = 'Tests aborted after ' + runEnd.runtime + ' milliseconds.';\n\t\t\t        for (var i = 0; i < tests.children.length; i++) {\n\t\t\t          test = tests.children[i];\n\t\t\t          if (test.className === '' || test.className === 'running') {\n\t\t\t            test.className = 'aborted';\n\t\t\t            assertList = test.getElementsByTagName('ol')[0];\n\t\t\t            assertLi = document.createElement('li');\n\t\t\t            assertLi.className = 'fail';\n\t\t\t            assertLi.innerHTML = 'Test aborted.';\n\t\t\t            assertList.appendChild(assertLi);\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\t\t\t      if (banner && (!abortButton || abortButton.disabled === false)) {\n\t\t\t        banner.className = runEnd.status === 'failed' ? 'qunit-fail' : 'qunit-pass';\n\t\t\t      }\n\t\t\t      if (abortButton) {\n\t\t\t        abortButton.parentNode.removeChild(abortButton);\n\t\t\t      }\n\t\t\t      if (tests) {\n\t\t\t        id('qunit-testresult-display').innerHTML = html;\n\t\t\t      }\n\t\t\t      if (config.altertitle && document.title) {\n\t\t\t        // Show  for good,  for bad suite result in title\n\t\t\t        // use escape sequences in case file gets loaded with non-utf-8\n\t\t\t        // charset\n\t\t\t        document.title = [runEnd.status === 'failed' ? \"\\u2716\" : \"\\u2714\", document.title.replace(/^[\\u2714\\u2716] /i, '')].join(' ');\n\t\t\t      }\n\n\t\t\t      // Scroll back to top to show results\n\t\t\t      if (config.scrolltop && window$1.scrollTo) {\n\t\t\t        window$1.scrollTo(0, 0);\n\t\t\t      }\n\t\t\t    });\n\t\t\t    function getNameHtml(name, module) {\n\t\t\t      var nameHtml = '';\n\t\t\t      if (module) {\n\t\t\t        nameHtml = \"<span class='module-name'>\" + escapeText(module) + '</span>: ';\n\t\t\t      }\n\t\t\t      nameHtml += \"<span class='test-name'>\" + escapeText(name) + '</span>';\n\t\t\t      return nameHtml;\n\t\t\t    }\n\t\t\t    function getProgressHtml(stats) {\n\t\t\t      return [stats.completed, ' / ', stats.defined, ' tests completed.<br />'].join('');\n\t\t\t    }\n\t\t\t    QUnit.testStart(function (details) {\n\t\t\t      var running, bad;\n\t\t\t      appendTest(details.name, details.testId, details.module);\n\t\t\t      running = id('qunit-testresult-display');\n\t\t\t      if (running) {\n\t\t\t        addClass(running, 'running');\n\t\t\t        bad = QUnit.config.reorder && details.previousFailure;\n\t\t\t        running.innerHTML = [getProgressHtml(stats), bad ? 'Rerunning previously failed test: <br />' : 'Running: ', getNameHtml(details.name, details.module), getRerunFailedHtml(stats.failedTests)].join('');\n\t\t\t      }\n\t\t\t    });\n\t\t\t    function stripHtml(string) {\n\t\t\t      // Strip tags, html entity and whitespaces\n\t\t\t      return string.replace(/<\\/?[^>]+(>|$)/g, '').replace(/&quot;/g, '').replace(/\\s+/g, '');\n\t\t\t    }\n\t\t\t    QUnit.log(function (details) {\n\t\t\t      var testItem = id('qunit-test-output-' + details.testId);\n\t\t\t      if (!testItem) {\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      var message = escapeText(details.message) || (details.result ? 'okay' : 'failed');\n\t\t\t      message = \"<span class='test-message'>\" + message + '</span>';\n\t\t\t      message += \"<span class='runtime'>@ \" + details.runtime + ' ms</span>';\n\t\t\t      var expected;\n\t\t\t      var actual;\n\t\t\t      var diff;\n\t\t\t      var showDiff = false;\n\n\t\t\t      // When pushFailure() is called, it is implied that no expected value\n\t\t\t      // or diff should be shown, because both expected and actual as undefined.\n\t\t\t      //\n\t\t\t      // This must check details.expected existence. If it exists as undefined,\n\t\t\t      // that's a regular assertion for which to render actual/expected and a diff.\n\t\t\t      var showAnyValues = !details.result && (details.expected !== undefined || details.actual !== undefined);\n\t\t\t      if (showAnyValues) {\n\t\t\t        if (details.negative) {\n\t\t\t          expected = 'NOT ' + QUnit.dump.parse(details.expected);\n\t\t\t        } else {\n\t\t\t          expected = QUnit.dump.parse(details.expected);\n\t\t\t        }\n\t\t\t        actual = QUnit.dump.parse(details.actual);\n\t\t\t        message += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + escapeText(expected) + '</pre></td></tr>';\n\t\t\t        if (actual !== expected) {\n\t\t\t          message += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText(actual) + '</pre></td></tr>';\n\t\t\t          if (typeof details.actual === 'number' && typeof details.expected === 'number') {\n\t\t\t            if (!isNaN(details.actual) && !isNaN(details.expected)) {\n\t\t\t              showDiff = true;\n\t\t\t              diff = details.actual - details.expected;\n\t\t\t              diff = (diff > 0 ? '+' : '') + diff;\n\t\t\t            }\n\t\t\t          } else if (typeof details.actual !== 'boolean' && typeof details.expected !== 'boolean') {\n\t\t\t            diff = QUnit.diff(expected, actual);\n\n\t\t\t            // don't show diff if there is zero overlap\n\t\t\t            showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;\n\t\t\t          }\n\t\t\t          if (showDiff) {\n\t\t\t            message += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + diff + '</pre></td></tr>';\n\t\t\t          }\n\t\t\t        } else if (expected.indexOf('[object Array]') !== -1 || expected.indexOf('[object Object]') !== -1) {\n\t\t\t          message += \"<tr class='test-message'><th>Message: </th><td>\" + 'Diff suppressed as the depth of object is more than current max depth (' + QUnit.dump.maxDepth + ').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to ' + \" run with a higher max depth or <a href='\" + escapeText(setUrl({\n\t\t\t            maxDepth: 0\n\t\t\t          })) + \"'>\" + 'Rerun without max depth</a>.</p></td></tr>';\n\t\t\t        } else {\n\t\t\t          message += \"<tr class='test-message'><th>Message: </th><td>\" + 'Diff suppressed as the expected and actual results have an equivalent' + ' serialization</td></tr>';\n\t\t\t        }\n\t\t\t        if (details.source) {\n\t\t\t          message += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>';\n\t\t\t        }\n\t\t\t        message += '</table>';\n\n\t\t\t        // This occurs when pushFailure is set and we have an extracted stack trace\n\t\t\t      } else if (!details.result && details.source) {\n\t\t\t        message += '<table>' + \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>' + '</table>';\n\t\t\t      }\n\t\t\t      var assertList = testItem.getElementsByTagName('ol')[0];\n\t\t\t      var assertLi = document.createElement('li');\n\t\t\t      assertLi.className = details.result ? 'pass' : 'fail';\n\t\t\t      assertLi.innerHTML = message;\n\t\t\t      assertList.appendChild(assertLi);\n\t\t\t    });\n\t\t\t    QUnit.testDone(function (details) {\n\t\t\t      var tests = id('qunit-tests');\n\t\t\t      var testItem = id('qunit-test-output-' + details.testId);\n\t\t\t      if (!tests || !testItem) {\n\t\t\t        return;\n\t\t\t      }\n\t\t\t      removeClass(testItem, 'running');\n\t\t\t      var status;\n\t\t\t      if (details.failed > 0) {\n\t\t\t        status = 'failed';\n\t\t\t      } else if (details.todo) {\n\t\t\t        status = 'todo';\n\t\t\t      } else {\n\t\t\t        status = details.skipped ? 'skipped' : 'passed';\n\t\t\t      }\n\t\t\t      var assertList = testItem.getElementsByTagName('ol')[0];\n\t\t\t      var good = details.passed;\n\t\t\t      var bad = details.failed;\n\n\t\t\t      // This test passed if it has no unexpected failed assertions\n\t\t\t      var testPassed = details.failed > 0 ? details.todo : !details.todo;\n\t\t\t      if (testPassed) {\n\t\t\t        // Collapse the passing tests\n\t\t\t        addClass(assertList, 'qunit-collapsed');\n\t\t\t      } else {\n\t\t\t        stats.failedTests.push(details.testId);\n\t\t\t        if (config.collapse) {\n\t\t\t          if (!collapseNext) {\n\t\t\t            // Skip collapsing the first failing test\n\t\t\t            collapseNext = true;\n\t\t\t          } else {\n\t\t\t            // Collapse remaining tests\n\t\t\t            addClass(assertList, 'qunit-collapsed');\n\t\t\t          }\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      // The testItem.firstChild is the test name\n\t\t\t      var testTitle = testItem.firstChild;\n\t\t\t      var testCounts = bad ? \"<b class='failed'>\" + bad + '</b>, ' + \"<b class='passed'>\" + good + '</b>, ' : '';\n\t\t\t      testTitle.innerHTML += \" <b class='counts'>(\" + testCounts + details.assertions.length + ')</b>';\n\t\t\t      stats.completed++;\n\t\t\t      if (details.skipped) {\n\t\t\t        testItem.className = 'skipped';\n\t\t\t        var skipped = document.createElement('em');\n\t\t\t        skipped.className = 'qunit-skipped-label';\n\t\t\t        skipped.innerHTML = 'skipped';\n\t\t\t        testItem.insertBefore(skipped, testTitle);\n\t\t\t      } else {\n\t\t\t        addEvent(testTitle, 'click', function () {\n\t\t\t          toggleClass(assertList, 'qunit-collapsed');\n\t\t\t        });\n\t\t\t        testItem.className = testPassed ? 'pass' : 'fail';\n\t\t\t        if (details.todo) {\n\t\t\t          var todoLabel = document.createElement('em');\n\t\t\t          todoLabel.className = 'qunit-todo-label';\n\t\t\t          todoLabel.innerHTML = 'todo';\n\t\t\t          testItem.className += ' todo';\n\t\t\t          testItem.insertBefore(todoLabel, testTitle);\n\t\t\t        }\n\t\t\t        var time = document.createElement('span');\n\t\t\t        time.className = 'runtime';\n\t\t\t        time.innerHTML = details.runtime + ' ms';\n\t\t\t        testItem.insertBefore(time, assertList);\n\t\t\t      }\n\n\t\t\t      // Show the source of the test when showing assertions\n\t\t\t      if (details.source) {\n\t\t\t        var sourceName = document.createElement('p');\n\t\t\t        sourceName.innerHTML = '<strong>Source: </strong>' + escapeText(details.source);\n\t\t\t        addClass(sourceName, 'qunit-source');\n\t\t\t        if (testPassed) {\n\t\t\t          addClass(sourceName, 'qunit-collapsed');\n\t\t\t        }\n\t\t\t        addEvent(testTitle, 'click', function () {\n\t\t\t          toggleClass(sourceName, 'qunit-collapsed');\n\t\t\t        });\n\t\t\t        testItem.appendChild(sourceName);\n\t\t\t      }\n\t\t\t      if (config.hidepassed && (status === 'passed' || details.skipped)) {\n\t\t\t        // use removeChild instead of remove because of support\n\t\t\t        hiddenTests.push(testItem);\n\t\t\t        tests.removeChild(testItem);\n\t\t\t      }\n\t\t\t    });\n\t\t\t    QUnit.on('error', function (error) {\n\t\t\t      var testItem = appendTest('global failure');\n\t\t\t      if (!testItem) {\n\t\t\t        // HTML Reporter is probably disabled or not yet initialized.\n\t\t\t        return;\n\t\t\t      }\n\n\t\t\t      // Render similar to a failed assertion (see above QUnit.log callback)\n\t\t\t      var message = escapeText(errorString(error));\n\t\t\t      message = \"<span class='test-message'>\" + message + '</span>';\n\t\t\t      if (error && error.stack) {\n\t\t\t        message += '<table>' + \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(error.stack) + '</pre></td></tr>' + '</table>';\n\t\t\t      }\n\t\t\t      var assertList = testItem.getElementsByTagName('ol')[0];\n\t\t\t      var assertLi = document.createElement('li');\n\t\t\t      assertLi.className = 'fail';\n\t\t\t      assertLi.innerHTML = message;\n\t\t\t      assertList.appendChild(assertLi);\n\n\t\t\t      // Make it visible\n\t\t\t      testItem.className = 'fail';\n\t\t\t    });\n\n\t\t\t    // Avoid readyState issue with phantomjs\n\t\t\t    // Ref: #818\n\t\t\t    var usingPhantom = function (p) {\n\t\t\t      return p && p.version && p.version.major > 0;\n\t\t\t    }(window$1.phantom);\n\t\t\t    if (usingPhantom) {\n\t\t\t      console$1.warn('Support for PhantomJS is deprecated and will be removed in QUnit 3.0.');\n\t\t\t    }\n\t\t\t    if (!usingPhantom && document.readyState === 'complete') {\n\t\t\t      QUnit.autostart();\n\t\t\t    } else {\n\t\t\t      addEvent(window$1, 'load', QUnit.autostart);\n\t\t\t    }\n\n\t\t\t    // Wrap window.onerror. We will call the original window.onerror to see if\n\t\t\t    // the existing handler fully handles the error; if not, we will call the\n\t\t\t    // QUnit.onError function.\n\t\t\t    var originalWindowOnError = window$1.onerror;\n\n\t\t\t    // Cover uncaught exceptions\n\t\t\t    // Returning true will suppress the default browser handler,\n\t\t\t    // returning false will let it run.\n\t\t\t    window$1.onerror = function (message, fileName, lineNumber, columnNumber, errorObj) {\n\t\t\t      var ret = false;\n\t\t\t      if (originalWindowOnError) {\n\t\t\t        for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n\t\t\t          args[_key - 5] = arguments[_key];\n\t\t\t        }\n\t\t\t        ret = originalWindowOnError.call.apply(originalWindowOnError, [this, message, fileName, lineNumber, columnNumber, errorObj].concat(args));\n\t\t\t      }\n\n\t\t\t      // Treat return value as window.onerror itself does,\n\t\t\t      // Only do our handling if not suppressed.\n\t\t\t      if (ret !== true) {\n\t\t\t        // If there is a current test that sets the internal `ignoreGlobalErrors` field\n\t\t\t        // (such as during `assert.throws()`), then the error is ignored and native\n\t\t\t        // error reporting is suppressed as well. This is because in browsers, an error\n\t\t\t        // can sometimes end up in `window.onerror` instead of in the local try/catch.\n\t\t\t        // This ignoring of errors does not apply to our general onUncaughtException\n\t\t\t        // method, nor to our `unhandledRejection` handlers, as those are not meant\n\t\t\t        // to receive an \"expected\" error during `assert.throws()`.\n\t\t\t        if (config.current && config.current.ignoreGlobalErrors) {\n\t\t\t          return true;\n\t\t\t        }\n\n\t\t\t        // According to\n\t\t\t        // https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,\n\t\t\t        // most modern browsers support an errorObj argument; use that to\n\t\t\t        // get a full stack trace if it's available.\n\t\t\t        var error = errorObj || new Error(message);\n\t\t\t        if (!error.stack && fileName && lineNumber) {\n\t\t\t          error.stack = \"\".concat(fileName, \":\").concat(lineNumber);\n\t\t\t        }\n\t\t\t        QUnit.onUncaughtException(error);\n\t\t\t      }\n\t\t\t      return ret;\n\t\t\t    };\n\t\t\t    window$1.addEventListener('unhandledrejection', function (event) {\n\t\t\t      QUnit.onUncaughtException(event.reason);\n\t\t\t    });\n\t\t\t  })();\n\n\t\t\t})(); \n\t\t} (qunit$1, qunit$1.exports));\n\t\treturn qunit$1.exports;\n\t}\n\n\tvar qunitExports = requireQunit();\n\tvar defExp = /*@__PURE__*/getDefaultExportFromCjs(qunitExports);\n\n\tvar namedExports = /*#__PURE__*/_mergeNamespaces({\n\t\t__proto__: null,\n\t\tdefault: defExp\n\t}, [qunitExports]);\n\n\tconst defaultExports = Object.isFrozen(defExp) ? Object.assign({}, defExp?.default || defExp || { __emptyModule: true }) : defExp;\n\tObject.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n\tObject.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n\tvar qunit = Object.isFrozen(defExp) ? Object.freeze(defaultExports) : defaultExports;\n\n\treturn qunit;\n\n}));\n",
      "relatedPaths": [
        "/Users/i573017/SAPDevelop/Private/Repositories/com.testing.unit/node_modules/qunit/qunit/qunit.js"
      ],
      "imports": [
        "node.process.js"
      ],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    },
    {
      "name": "node.process",
      "originalName": "node.process",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n  var global$1 = (typeof global !== \"undefined\" ? global :\n    typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window : {});\n\n  // shim for using process in browser\n  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\n  function defaultSetTimout() {\n      throw new Error('setTimeout has not been defined');\n  }\n  function defaultClearTimeout () {\n      throw new Error('clearTimeout has not been defined');\n  }\n  var cachedSetTimeout = defaultSetTimout;\n  var cachedClearTimeout = defaultClearTimeout;\n  if (typeof global$1.setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n  }\n  if (typeof global$1.clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n  }\n\n  function runTimeout(fun) {\n      if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n      }\n      // if setTimeout wasn't available but was latter defined\n      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n      }\n      try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n      } catch(e){\n          try {\n              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n              return cachedSetTimeout.call(null, fun, 0);\n          } catch(e){\n              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n              return cachedSetTimeout.call(this, fun, 0);\n          }\n      }\n\n\n  }\n  function runClearTimeout(marker) {\n      if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n      }\n      // if clearTimeout wasn't available but was latter defined\n      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n      }\n      try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n      } catch (e){\n          try {\n              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n              return cachedClearTimeout.call(null, marker);\n          } catch (e){\n              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n              // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n              return cachedClearTimeout.call(this, marker);\n          }\n      }\n\n\n\n  }\n  var queue = [];\n  var draining = false;\n  var currentQueue;\n  var queueIndex = -1;\n\n  function cleanUpNextTick() {\n      if (!draining || !currentQueue) {\n          return;\n      }\n      draining = false;\n      if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n      } else {\n          queueIndex = -1;\n      }\n      if (queue.length) {\n          drainQueue();\n      }\n  }\n\n  function drainQueue() {\n      if (draining) {\n          return;\n      }\n      var timeout = runTimeout(cleanUpNextTick);\n      draining = true;\n\n      var len = queue.length;\n      while(len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n              if (currentQueue) {\n                  currentQueue[queueIndex].run();\n              }\n          }\n          queueIndex = -1;\n          len = queue.length;\n      }\n      currentQueue = null;\n      draining = false;\n      runClearTimeout(timeout);\n  }\n  function nextTick(fun) {\n      var args = new Array(arguments.length - 1);\n      if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n              args[i - 1] = arguments[i];\n          }\n      }\n      queue.push(new Item(fun, args));\n      if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n      }\n  }\n  // v8 likes predictible objects\n  function Item(fun, array) {\n      this.fun = fun;\n      this.array = array;\n  }\n  Item.prototype.run = function () {\n      this.fun.apply(null, this.array);\n  };\n  var title = 'browser';\n  var platform = 'browser';\n  var browser = true;\n  var env = {};\n  var argv = [];\n  var version = ''; // empty string to avoid regexp issues\n  var versions = {};\n  var release = {};\n  var config = {};\n\n  function noop() {}\n\n  var on = noop;\n  var addListener = noop;\n  var once = noop;\n  var off = noop;\n  var removeListener = noop;\n  var removeAllListeners = noop;\n  var emit = noop;\n\n  function binding(name) {\n      throw new Error('process.binding is not supported');\n  }\n\n  function cwd () { return '/' }\n  function chdir (dir) {\n      throw new Error('process.chdir is not supported');\n  }function umask() { return 0; }\n\n  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\n  var performance = global$1.performance || {};\n  var performanceNow =\n    performance.now        ||\n    performance.mozNow     ||\n    performance.msNow      ||\n    performance.oNow       ||\n    performance.webkitNow  ||\n    function(){ return (new Date()).getTime() };\n\n  // generate timestamp or delta\n  // see http://nodejs.org/api/process.html#process_process_hrtime\n  function hrtime(previousTimestamp){\n    var clocktime = performanceNow.call(performance)*1e-3;\n    var seconds = Math.floor(clocktime);\n    var nanoseconds = Math.floor((clocktime%1)*1e9);\n    if (previousTimestamp) {\n      seconds = seconds - previousTimestamp[0];\n      nanoseconds = nanoseconds - previousTimestamp[1];\n      if (nanoseconds<0) {\n        seconds--;\n        nanoseconds += 1e9;\n      }\n    }\n    return [seconds,nanoseconds]\n  }\n\n  var startTime = new Date();\n  function uptime() {\n    var currentTime = new Date();\n    var dif = currentTime - startTime;\n    return dif / 1000;\n  }\n\n  var browser$1 = {\n    nextTick: nextTick,\n    title: title,\n    browser: browser,\n    env: env,\n    argv: argv,\n    version: version,\n    versions: versions,\n    on: on,\n    addListener: addListener,\n    once: once,\n    off: off,\n    removeListener: removeListener,\n    removeAllListeners: removeAllListeners,\n    emit: emit,\n    binding: binding,\n    cwd: cwd,\n    chdir: chdir,\n    umask: umask,\n    hrtime: hrtime,\n    platform: platform,\n    release: release,\n    config: config,\n    uptime: uptime\n  };\n\n  exports.browser$1 = browser$1;\n  exports.global = global$1;\n\n}));\n",
      "relatedPaths": [],
      "imports": [],
      "dynamicImports": [],
      "generated": true,
      "isWebComponent": false,
      "type": "chunk"
    }
  ]
}